{
  "version": 3,
  "sources": ["../../../../src/browser/sync/authentication_manager.ts"],
  "sourcesContent": ["import { LocalSyncState } from \"./local_state.js\";\nimport { AuthError, Transition } from \"./protocol.js\";\nimport jwtDecode from \"jwt-decode\";\n\n/**\n * An async function returning the JWT-encoded OpenID Connect Identity Token\n * if available.\n *\n * `forceRefreshToken` is `true` if the server rejected a previously\n * returned token, and the client should try to fetch a new one.\n *\n * See {@link ConvexReactClient.setAuth}.\n *\n * @public\n */\nexport type AuthTokenFetcher = (args: {\n  forceRefreshToken: boolean;\n}) => Promise<string | null | undefined>;\n\n/**\n * What is provided to the client.\n */\ntype AuthConfig = {\n  fetchToken: AuthTokenFetcher;\n  onAuthChange: (isAuthenticated: boolean) => void;\n};\n\n/**\n * In general we take 3 steps:\n *   1. Fetch a possibly cached token\n *   2. Immediately fetch a fresh token without using a cache\n *   3. Repeat step 2 before the end of the fresh token's lifetime\n *\n * When we fetch without using a cache we know when the token\n * will expire, and can schedule refetching it.\n *\n * If we get an error before a scheduled refetch, we go back\n * to step 2.\n */\ntype AuthState =\n  | { state: \"noAuth\" }\n  | {\n      state: \"waitingForServerConfirmationOfCachedToken\";\n      config: AuthConfig;\n      hasRetried: boolean;\n    }\n  | {\n      state: \"initialRefetch\";\n      config: AuthConfig;\n    }\n  | {\n      state: \"waitingForServerConfirmationOfFreshToken\";\n      config: AuthConfig;\n      hadAuth: boolean;\n      token: string;\n    }\n  | {\n      state: \"waitingForScheduledRefetch\";\n      config: AuthConfig;\n      refetchTokenTimeoutId: ReturnType<typeof setTimeout>;\n    }\n  // Special/weird state when we got a valid token\n  // but could not fetch a new one.\n  | {\n      state: \"notRefetching\";\n      config: AuthConfig;\n    };\n\n/**\n * Handles the state transitions for auth. The server is the source\n * of truth.\n */\nexport class AuthenticationManager {\n  private authState: AuthState = { state: \"noAuth\" };\n  // Used to detect races involving `setConfig` calls\n  // while a token is being fetched.\n  private configVersion = 0;\n  // Shared by the BaseClient so that the auth manager can easily inspect it\n  private readonly syncState: LocalSyncState;\n  // Passed down by BaseClient, sends a message to the server\n  private readonly authenticate: (token: string) => void;\n  private readonly pauseSocket: () => void;\n  private readonly resumeSocket: () => void;\n  // Passed down by BaseClient, sends a message to the server\n  private readonly clearAuth: () => void;\n  private readonly verbose: boolean;\n\n  constructor(\n    syncState: LocalSyncState,\n    {\n      authenticate,\n      pauseSocket: pause,\n      resumeSocket: resume,\n      clearAuth,\n      verbose,\n    }: {\n      authenticate: (token: string) => void;\n      pauseSocket: () => void;\n      resumeSocket: () => void;\n      clearAuth: () => void;\n      verbose: boolean;\n    }\n  ) {\n    this.syncState = syncState;\n    this.authenticate = authenticate;\n    this.pauseSocket = pause;\n    this.resumeSocket = resume;\n    this.clearAuth = clearAuth;\n    this.verbose = verbose;\n  }\n\n  async setConfig(\n    fetchToken: AuthTokenFetcher,\n    onChange: (isAuthenticated: boolean) => void\n  ) {\n    this.resetAuthState();\n    const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {\n      forceRefreshToken: false,\n    });\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n    if (token.value) {\n      this.setAuthState({\n        state: \"waitingForServerConfirmationOfCachedToken\",\n        config: { fetchToken, onAuthChange: onChange },\n        hasRetried: false,\n      });\n      this.authenticate(token.value);\n    } else {\n      this.setAuthState({\n        state: \"initialRefetch\",\n        config: { fetchToken, onAuthChange: onChange },\n      });\n      // Try again with `forceRefreshToken: true`\n      await this.refetchToken();\n    }\n  }\n\n  onTransition(serverMessage: Transition) {\n    if (\n      !this.syncState.isCurrentOrNewerAuthVersion(\n        serverMessage.endVersion.identity\n      )\n    ) {\n      // This is a stale transition - client has moved on to\n      // a newer auth version.\n      return;\n    }\n    if (\n      serverMessage.endVersion.identity <= serverMessage.startVersion.identity\n    ) {\n      // This transition did not change auth - it is not a response to Authenticate.\n      return;\n    }\n\n    if (this.authState.state === \"waitingForServerConfirmationOfCachedToken\") {\n      this._logVerbose(\"server confirmed auth token is valid\");\n      void this.refetchToken();\n      this.authState.config.onAuthChange(true);\n      return;\n    }\n    if (this.authState.state === \"waitingForServerConfirmationOfFreshToken\") {\n      this._logVerbose(\"server confirmed new auth token is valid\");\n      this.scheduleTokenRefetch(this.authState.token);\n      if (!this.authState.hadAuth) {\n        this.authState.config.onAuthChange(true);\n      }\n    }\n  }\n\n  onAuthError(serverMessage: AuthError) {\n    const { baseVersion } = serverMessage;\n    // Versioned AuthErrors are ignored if the client advanced to\n    // a newer auth identity\n    if (baseVersion !== null && baseVersion !== undefined) {\n      // Error are reporting the previous version, since the server\n      // didn't advance, hence `+ 1`.\n      if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {\n        this._logVerbose(\"ignoring auth error for previous auth attempt\");\n        return;\n      }\n      void this.tryToReauthenticate(serverMessage);\n      return;\n    }\n\n    // TODO: Remove after all AuthErrors are versioned\n    void this.tryToReauthenticate(serverMessage);\n  }\n\n  // This is similar to `refetchToken` defined below, in fact we\n  // don't represent them as different states, but it is different\n  // in that we pause the WebSocket so that mutations\n  // don't retry with bad auth.\n  private async tryToReauthenticate(serverMessage: AuthError) {\n    // We only retry once, to avoid infinite retries\n    if (\n      // No way to fetch another token, kaboom\n      this.authState.state === \"noAuth\" ||\n      // We failed on a fresh token, trying another one won't help\n      this.authState.state === \"waitingForServerConfirmationOfFreshToken\"\n    ) {\n      console.error(\n        `Failed to authenticate: \"${serverMessage.error}\", check your server auth config`\n      );\n      if (this.syncState.hasAuth()) {\n        this.syncState.clearAuth();\n      }\n      if (this.authState.state !== \"noAuth\") {\n        this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n      }\n      return;\n    }\n    this._logVerbose(\"attempting to reauthenticate\");\n    await this.pauseSocket();\n    const token = await this.fetchTokenAndGuardAgainstRace(\n      this.authState.config.fetchToken,\n      {\n        forceRefreshToken: true,\n      }\n    );\n    if (token.isFromOutdatedConfig) {\n      await this.resumeSocket();\n      return;\n    }\n\n    if (token.value && this.syncState.isNewAuth(token.value)) {\n      this.syncState.setAuth(token.value);\n      this.setAuthState({\n        state: \"waitingForServerConfirmationOfFreshToken\",\n        config: this.authState.config,\n        token: token.value,\n        hadAuth:\n          this.authState.state === \"notRefetching\" ||\n          this.authState.state === \"waitingForScheduledRefetch\",\n      });\n    } else {\n      this._logVerbose(\"reauthentication failed, could not fetch a new token\");\n      if (this.syncState.hasAuth()) {\n        this.syncState.clearAuth();\n      }\n      this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n    }\n    await this.resumeSocket();\n  }\n\n  // Force refetch the token and schedule another refetch\n  // before the token expires - an active client should never\n  // need to reauthenticate.\n  private async refetchToken() {\n    if (this.authState.state === \"noAuth\") {\n      return;\n    }\n    this._logVerbose(\"refetching auth token\");\n    const token = await this.fetchTokenAndGuardAgainstRace(\n      this.authState.config.fetchToken,\n      {\n        forceRefreshToken: true,\n      }\n    );\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n\n    if (token.value) {\n      if (this.syncState.isNewAuth(token.value)) {\n        this.setAuthState({\n          state: \"waitingForServerConfirmationOfFreshToken\",\n          hadAuth: this.syncState.hasAuth(),\n          token: token.value,\n          config: this.authState.config,\n        });\n        this.authenticate(token.value);\n      } else {\n        this.setAuthState({\n          state: \"notRefetching\",\n          config: this.authState.config,\n        });\n      }\n    } else {\n      this._logVerbose(\"refetching token failed\");\n      if (this.syncState.hasAuth()) {\n        this.clearAuth();\n      }\n      this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n    }\n  }\n\n  private scheduleTokenRefetch(token: string) {\n    if (this.authState.state === \"noAuth\") {\n      return;\n    }\n    const decodedToken = this.decodeToken(token);\n    if (!decodedToken) {\n      // This is no longer really possible, because\n      // we wait on server response before scheduling token refetch,\n      // and the server currently requires JWT tokens.\n      console.error(\"Auth token is not a valid JWT, cannot refetch the token\");\n      return;\n    }\n    // iat: issued at time, UTC seconds timestamp at which the JWT was issued\n    // exp: expiration time, UTC seconds timestamp at which the JWT will expire\n    const { iat, exp } = decodedToken as { iat?: number; exp?: number };\n    if (!iat || !exp) {\n      console.error(\n        \"Auth token does not have required fields, cannot refetch the token\"\n      );\n      return;\n    }\n    const leewaySeconds = 2;\n    // Because the client and server clocks may be out of sync,\n    // we only know that the token will expire after `exp - iat`,\n    // and since we just fetched a fresh one we know when that\n    // will happen.\n    const delay = (exp - iat - leewaySeconds) * 1000;\n    if (delay <= 0) {\n      console.error(\n        \"Auth token does not live long enough, cannot refetch the token\"\n      );\n      return;\n    }\n    const refetchTokenTimeoutId = setTimeout(() => {\n      void this.refetchToken();\n    }, delay);\n    this.setAuthState({\n      state: \"waitingForScheduledRefetch\",\n      refetchTokenTimeoutId,\n      config: this.authState.config,\n    });\n    this._logVerbose(\n      `scheduled preemptive auth token refetching in ${delay}ms`\n    );\n  }\n\n  // Protects against simultaneous calls to `setConfig`\n  // while we're fetching a token\n  private async fetchTokenAndGuardAgainstRace(\n    fetchToken: AuthTokenFetcher,\n    fetchArgs: {\n      forceRefreshToken: boolean;\n    }\n  ) {\n    const originalConfigVersion = ++this.configVersion;\n    const token = await fetchToken(fetchArgs);\n    if (this.configVersion !== originalConfigVersion) {\n      // This is a stale config\n      return { isFromOutdatedConfig: true };\n    }\n    return { isFromOutdatedConfig: false, value: token };\n  }\n\n  stop() {\n    this.resetAuthState();\n    // Bump this in case we are mid-token-fetch when we get stopped\n    this.configVersion++;\n  }\n\n  private setAndReportAuthFailed(\n    onAuthChange: (authenticated: boolean) => void\n  ) {\n    onAuthChange(false);\n    this.resetAuthState();\n  }\n\n  private resetAuthState() {\n    this.setAuthState({ state: \"noAuth\" });\n  }\n\n  private setAuthState(newAuth: AuthState) {\n    if (this.authState.state === \"waitingForScheduledRefetch\") {\n      clearTimeout(this.authState.refetchTokenTimeoutId);\n\n      // The waitingForScheduledRefetch state is the most quiesced authed state.\n      // Let the syncState know that auth is in a good state, so it can reset failure backoffs\n      this.syncState.markAuthCompletion();\n    }\n    this.authState = newAuth;\n  }\n\n  private decodeToken(token: string) {\n    try {\n      return jwtDecode(token);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  private _logVerbose(message: string) {\n    if (this.verbose) {\n      console.debug(\n        `${new Date().toISOString()} ${message} [v${this.configVersion}]`\n      );\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["jwtDecode"]
}
