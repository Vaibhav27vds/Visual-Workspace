{
  "version": 3,
  "sources": ["../../../src/server/registration.ts"],
  "sourcesContent": ["import {\n  Auth,\n  GenericDatabaseReader,\n  GenericDatabaseWriter,\n  StorageActionWriter,\n  StorageReader,\n  StorageWriter,\n} from \"./index.js\";\nimport {\n  FunctionReference,\n  FunctionReturnType,\n  OptionalRestArgs,\n} from \"../server/api.js\";\nimport { ObjectType, PropertyValidators } from \"../values/validator.js\";\nimport { Id } from \"../values/value.js\";\nimport {\n  GenericDataModel,\n  NamedTableInfo,\n  TableNamesInDataModel,\n  VectorIndexNames,\n} from \"./data_model.js\";\nimport { Scheduler } from \"./scheduler.js\";\nimport { VectorSearchQuery } from \"./vector_search.js\";\nimport { Expand } from \"../type_utils.js\";\n\n/**\n * A set of services for use within Convex mutation functions.\n *\n * The mutation context is passed as the first argument to any Convex mutation\n * function run on the server.\n *\n * If you're using code generation, use the `MutationCtx` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @public\n */\nexport interface GenericMutationCtx<DataModel extends GenericDataModel> {\n  /**\n   * A utility for reading and writing data in the database.\n   */\n  db: GenericDatabaseWriter<DataModel>;\n\n  /**\n   * Information about the currently authenticated user.\n   */\n  auth: Auth;\n\n  /**\n   * A utility for reading and writing files in storage.\n   */\n  storage: StorageWriter;\n\n  /**\n   * A utility for scheduling Convex functions to run in the future.\n   */\n  scheduler: Scheduler;\n}\n\n/**\n * If you're using code generation, use the `MutationCtx` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * If you need an unparameterized MutationCtx use GenericMutationCtx.\n *\n * @public\n * @deprecated\n */\nexport interface MutationCtx<DataModel extends GenericDataModel>\n  extends GenericMutationCtx<DataModel> {}\n\n/**\n * A set of services for use within Convex query functions.\n *\n * The query context is passed as the first argument to any Convex query\n * function run on the server.\n *\n * This differs from the {@link MutationCtx} because all of the services are\n * read-only.\n *\n *\n * @public\n */\nexport interface GenericQueryCtx<DataModel extends GenericDataModel> {\n  /**\n   * A utility for reading data in the database.\n   */\n  db: GenericDatabaseReader<DataModel>;\n\n  /**\n   * Information about the currently authenticated user.\n   */\n  auth: Auth;\n\n  /**\n   * A utility for reading files in storage.\n   */\n  storage: StorageReader;\n}\n\n/**\n * If you're using code generation, use the `QueryCtx` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * If you need an unparameterized QueryCtx use GenericQueryCtx.\n *\n * @public\n * @deprecated\n */\nexport interface QueryCtx<DataModel extends GenericDataModel>\n  extends GenericQueryCtx<DataModel> {}\n\n/**\n * A set of services for use within Convex action functions.\n *\n * The context is passed as the first argument to any Convex action\n * run on the server.\n *\n * If you're using code generation, use the `ActionCtx` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @public\n */\nexport interface GenericActionCtx<DataModel extends GenericDataModel> {\n  /**\n   * Run the Convex query with the given name and arguments.\n   *\n   * Consider using an {@link internalQuery} to prevent users from calling the\n   * query directly.\n   *\n   * @param query - A {@link FunctionReference} for the query to run.\n   * @param args - The arguments to the query function.\n   * @returns A promise of the query's result.\n   */\n  runQuery<Query extends FunctionReference<\"query\", \"public\" | \"internal\">>(\n    query: Query,\n    ...args: OptionalRestArgs<Query>\n  ): Promise<FunctionReturnType<Query>>;\n\n  /**\n   * Run the Convex mutation with the given name and arguments.\n   *\n   * Consider using an {@link internalMutation} to prevent users from calling\n   * the mutation directly.\n   *\n   * @param mutation - A {@link FunctionReference} for the mutation to run.\n   * @param args - The arguments to the mutation function.\n   * @returns A promise of the mutation's result.\n   */\n  runMutation<\n    Mutation extends FunctionReference<\"mutation\", \"public\" | \"internal\">\n  >(\n    mutation: Mutation,\n    ...args: OptionalRestArgs<Mutation>\n  ): Promise<FunctionReturnType<Mutation>>;\n\n  /**\n   * Run the Convex action with the given name and arguments.\n   *\n   * Consider using an {@link internalAction} to prevent users from calling the\n   * action directly.\n   *\n   * @param action - A {@link FunctionReference} for the action to run.\n   * @param args - The arguments to the action function.\n   * @returns A promise of the action's result.\n   */\n  runAction<Action extends FunctionReference<\"action\", \"public\" | \"internal\">>(\n    action: Action,\n    ...args: OptionalRestArgs<Action>\n  ): Promise<FunctionReturnType<Action>>;\n\n  /**\n   * A utility for scheduling Convex functions to run in the future.\n   */\n  scheduler: Scheduler;\n\n  /**\n   * Information about the currently authenticated user.\n   */\n  auth: Auth;\n\n  /**\n   * A utility for reading and writing files in storage.\n   */\n  storage: StorageActionWriter;\n\n  /**\n   * Run a vector search on the given table and index.\n   *\n   * @param tableName - The name of the table to query.\n   * @param indexName - The name of the vector index on the table to query.\n   * @param query - A {@link VectorSearchQuery} containing the vector to query,\n   * the number of results to return, and any filters.\n   * @returns A promise of IDs and scores for the documents with the nearest\n   * vectors\n   */\n  vectorSearch<\n    TableName extends TableNamesInDataModel<DataModel>,\n    IndexName extends VectorIndexNames<NamedTableInfo<DataModel, TableName>>\n  >(\n    tableName: TableName,\n    indexName: IndexName,\n    query: Expand<\n      VectorSearchQuery<NamedTableInfo<DataModel, TableName>, IndexName>\n    >\n  ): Promise<Array<{ _id: Id<TableName>; _score: number }>>;\n}\n\n/**\n * If you're using code generation, use the `ActionCtx` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * If you need an unparameterized ActionCtx use GenericActionCtx.\n *\n * @public\n * @deprecated\n */\nexport interface ActionCtx<\n  DataModel extends GenericDataModel = GenericDataModel\n> extends GenericActionCtx<DataModel> {}\n\n/**\n * The default arguments type for a Convex query, mutation, or action function.\n *\n * Convex functions always take an arguments object that maps the argument\n * names to their values.\n *\n * @public\n */\nexport type DefaultFunctionArgs = Record<string, unknown>;\n\n/**\n * The arguments array for a function that takes arguments.\n *\n * This is an array of a single {@link DefaultFunctionArgs} element.\n */\ntype OneArgArray<ArgsObject extends DefaultFunctionArgs = DefaultFunctionArgs> =\n  [ArgsObject];\n\n/**\n * The arguments to a function that takes no arguments (just an empty array).\n */\ntype NoArgsArray = [];\n\n/**\n * An array of arguments to a Convex function.\n *\n * Convex functions can take either a single {@link DefaultFunctionArgs} object or no\n * args at all.\n *\n * @public\n */\nexport type ArgsArray = OneArgArray | NoArgsArray;\n\n/**\n * A type for the empty object `{}`.\n *\n * Note that we don't use `type EmptyObject = {}` because that matches every object.\n */\nexport type EmptyObject = Record<string, never>;\n\n/**\n * Convert an {@link ArgsArray} into a single object type.\n *\n * Empty arguments arrays are converted to {@link EmptyObject}.\n */\ntype ArgsArrayToObject<Args extends ArgsArray> = Args extends OneArgArray<\n  infer ArgsObject\n>\n  ? ArgsObject\n  : EmptyObject;\n\n/**\n * A type representing the visibility of a Convex function.\n *\n * @public\n */\nexport type FunctionVisibility = \"public\" | \"internal\";\n\n/**\n * Given a {@link FunctionVisibility}, should this function have `isPublic: true`\n * or `isInternal: true`?\n */\ntype VisibilityProperties<Visiblity extends FunctionVisibility> =\n  Visiblity extends \"public\"\n    ? {\n        isPublic: true;\n      }\n    : {\n        isInternal: true;\n      };\n\n/**\n * A mutation function that is part of this app.\n *\n * You can create a mutation by wrapping your function in\n * {@link mutationGeneric} or {@link internalMutationGeneric} and exporting it.\n *\n * @public\n */\nexport type RegisteredMutation<\n  Visibility extends FunctionVisibility,\n  Args extends DefaultFunctionArgs,\n  Output\n> = {\n  (ctx: GenericMutationCtx<any>, args: Args): Output;\n\n  isConvexFunction: true;\n  isMutation: true;\n  isRegistered?: true;\n\n  /** @internal */\n  invokeMutation(argsStr: string): Promise<string>;\n\n  /** @internal */\n  exportArgs(): string;\n} & VisibilityProperties<Visibility>;\n\n/**\n * A query function that is part of this app.\n *\n * You can create a query by wrapping your function in\n * {@link queryGeneric} or {@link internalQueryGeneric} and exporting it.\n *\n * @public\n */\nexport type RegisteredQuery<\n  Visibility extends FunctionVisibility,\n  Args extends DefaultFunctionArgs,\n  Output\n> = {\n  (ctx: GenericQueryCtx<any>, args: Args): Output;\n\n  isConvexFunction: true;\n  isQuery: true;\n  isRegistered?: true;\n\n  /** @internal */\n  invokeQuery(\n    argsStr: string,\n    allowMapsAndSetsInReturnValue: boolean\n  ): Promise<string>;\n\n  /** @internal */\n  exportArgs(): string;\n} & VisibilityProperties<Visibility>;\n\n/**\n * An action that is part of this app.\n *\n * You can create an action by wrapping your function in\n * {@link actionGeneric} or {@link internalActionGeneric} and exporting it.\n *\n * @public\n */\nexport type RegisteredAction<\n  Visibility extends FunctionVisibility,\n  Args extends DefaultFunctionArgs,\n  Output\n> = {\n  (ctx: GenericActionCtx<any>, args: Args): Output;\n\n  isConvexFunction: true;\n  isAction: true;\n  isRegistered?: true;\n\n  /** @internal */\n  invokeAction(requestId: string, argsStr: string): Promise<string>;\n\n  /** @internal */\n  exportArgs(): string;\n} & VisibilityProperties<Visibility>;\n\n/**\n * An HTTP action that is part of this app's public API.\n *\n * You can create public HTTP actions by wrapping your function in\n * {@link httpActionGeneric} and exporting it.\n *\n * @public\n */\nexport type PublicHttpAction = {\n  (ctx: GenericActionCtx<any>, request: Request): Response;\n  isHttp: true;\n  isRegistered?: true;\n\n  /** @internal */\n  invokeHttpAction(request: Request): Promise<Response>;\n};\n\n/**\n * The definition of a Convex query, mutation, or action function without\n * argument validation.\n *\n * Convex functions always take a context object as their first argument\n * and an (optional) args object as their second argument.\n *\n * This can be written as a function like:\n * ```js\n * import { query } from \"./_generated/server\";\n *\n * export const func = query(({ db }, { arg }) => {...});\n * ```\n * or as an object like:\n *\n * ```js\n * import { query } from \"./_generated/server\";\n *\n * export const func = query({\n *   handler: ({ db }, { arg }) => {...},\n * });\n * ```\n * See {@link ValidatedFunction} to add argument validation.\n *\n * @public\n */\nexport type UnvalidatedFunction<Ctx, Args extends ArgsArray, Output> =\n  | ((ctx: Ctx, ...args: Args) => Output)\n  | {\n      handler: (ctx: Ctx, ...args: Args) => Output;\n    };\n\n/**\n * The definition of a Convex query, mutation, or action function with argument\n * validation.\n *\n * Argument validation allows you to assert that the arguments to this function\n * are the expected type.\n *\n * Example:\n *\n * ```js\n * import { query } from \"./_generated/server\";\n * import { v } from \"convex/values\";\n *\n * export const func = query({\n *   args: {\n *     arg: v.string()\n *   },\n *   handler: ({ db }, { arg }) => {...},\n * });\n * ```\n *\n * **For security, argument validation should be added to all public functions in\n * production apps.**\n *\n * See {@link UnvalidatedFunction} for functions without argument validation.\n * @public\n */\nexport interface ValidatedFunction<\n  Ctx,\n  ArgsValidator extends PropertyValidators,\n  Output\n> {\n  /**\n   * A validator for the arguments of this function.\n   *\n   * This is an object mapping argument names to validators constructed with\n   * {@link values.v}.\n   *\n   * ```js\n   * import { v } from \"convex/values\";\n   *\n   * const args = {\n   *   stringArg: v.string(),\n   *   optionalNumberArg: v.optional(v.number()),\n   * }\n   * ```\n   */\n  args: ArgsValidator;\n\n  /**\n   * The implementation of this function.\n   *\n   * This is a function that takes in the appropriate context and arguments\n   * and produces some result.\n   *\n   * @param ctx - The context object. This is one of {@link QueryCtx},\n   * {@link MutationCtx}, or {@link ActionCtx} depending on the function type.\n   * @param args - The arguments object for this function. This will match\n   * the type defined by the argument validator.\n   * @returns\n   */\n  handler: (ctx: Ctx, args: ObjectType<ArgsValidator>) => Output;\n}\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link mutationGeneric} a type specific to your data model.\n * @public\n */\nexport type MutationBuilder<\n  DataModel extends GenericDataModel,\n  Visibility extends FunctionVisibility\n> = {\n  <Output, ArgsValidator extends PropertyValidators>(\n    func: ValidatedFunction<\n      GenericMutationCtx<DataModel>,\n      ArgsValidator,\n      Output\n    >\n  ): RegisteredMutation<Visibility, ObjectType<ArgsValidator>, Output>;\n\n  <Output, Args extends ArgsArray = OneArgArray>(\n    func: UnvalidatedFunction<GenericMutationCtx<DataModel>, Args, Output>\n  ): RegisteredMutation<Visibility, ArgsArrayToObject<Args>, Output>;\n};\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link queryGeneric} a type specific to your data model.\n * @public\n */\nexport type QueryBuilder<\n  DataModel extends GenericDataModel,\n  Visibility extends FunctionVisibility\n> = {\n  <Output, ArgsValidator extends PropertyValidators>(\n    func: ValidatedFunction<GenericQueryCtx<DataModel>, ArgsValidator, Output>\n  ): RegisteredQuery<Visibility, ObjectType<ArgsValidator>, Output>;\n\n  <Output, Args extends ArgsArray = OneArgArray>(\n    func: UnvalidatedFunction<GenericQueryCtx<DataModel>, Args, Output>\n  ): RegisteredQuery<Visibility, ArgsArrayToObject<Args>, Output>;\n};\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link actionGeneric} a type specific to your data model.\n * @public\n */\nexport type ActionBuilder<\n  DataModel extends GenericDataModel,\n  Visibility extends FunctionVisibility\n> = {\n  <Output, ArgsValidator extends PropertyValidators>(\n    func: ValidatedFunction<GenericActionCtx<DataModel>, ArgsValidator, Output>\n  ): RegisteredAction<Visibility, ObjectType<ArgsValidator>, Output>;\n\n  <Output, Args extends ArgsArray = OneArgArray>(\n    func: UnvalidatedFunction<GenericActionCtx<DataModel>, Args, Output>\n  ): RegisteredAction<Visibility, ArgsArrayToObject<Args>, Output>;\n};\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link httpActionGeneric} a type specific to your data model\n * and functions.\n * @public\n */\nexport type HttpActionBuilder = (\n  func: (ctx: GenericActionCtx<any>, request: Request) => Promise<Response>\n) => PublicHttpAction;\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
