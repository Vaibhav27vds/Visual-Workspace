{
  "version": 3,
  "sources": ["../../../src/react/use_paginated_query.ts"],
  "sourcesContent": ["import { useMemo, useState } from \"react\";\n\nimport { OptimisticLocalStore } from \"../browser/index.js\";\nimport {\n  FunctionReturnType,\n  PaginationOptions,\n  paginationOptsValidator,\n  PaginationResult,\n} from \"../server/index.js\";\nimport { convexToJson, Infer, Value } from \"../values/index.js\";\nimport { useQueries } from \"./use_queries.js\";\nimport {\n  FunctionArgs,\n  FunctionReference,\n  getFunctionName,\n} from \"../server/api.js\";\nimport { BetterOmit, Expand } from \"../type_utils.js\";\n\n/**\n * A {@link server.FunctionReference} that is usable with {@link usePaginatedQuery}.\n *\n * This function reference must:\n * - Refer to a public query\n * - Have an argument named \"paginationOpts\" of type {@link server.PaginationOptions}\n * - Have a return type of {@link server.PaginationResult}.\n *\n * @public\n */\nexport type PaginatedQueryReference = FunctionReference<\n  \"query\",\n  \"public\",\n  { paginationOpts: PaginationOptions },\n  PaginationResult<any>\n>;\n\n// Incrementing integer for each page queried in the usePaginatedQuery hook.\ntype QueryPageKey = number;\n\ntype UsePaginatedQueryState = {\n  query: FunctionReference<\"query\">;\n  args: Record<string, Value>;\n  id: number;\n  nextPageKey: QueryPageKey;\n  pageKeys: QueryPageKey[];\n  queries: Record<\n    QueryPageKey,\n    {\n      query: FunctionReference<\"query\">;\n      // Use the validator type as a test that it matches the args\n      // we generate.\n      args: { paginationOpts: Infer<typeof paginationOptsValidator> };\n    }\n  >;\n  ongoingSplits: Record<QueryPageKey, [QueryPageKey, QueryPageKey]>;\n  skip: boolean;\n};\n\nconst splitQuery =\n  (key: QueryPageKey, splitCursor: string, continueCursor: string) =>\n  (prevState: UsePaginatedQueryState) => {\n    const queries = { ...prevState.queries };\n    const splitKey1 = prevState.nextPageKey;\n    const splitKey2 = prevState.nextPageKey + 1;\n    const nextPageKey = prevState.nextPageKey + 2;\n    queries[splitKey1] = {\n      query: prevState.query,\n      args: {\n        ...prevState.args,\n        paginationOpts: {\n          ...prevState.queries[key].args.paginationOpts,\n          endCursor: splitCursor,\n        },\n      },\n    };\n    queries[splitKey2] = {\n      query: prevState.query,\n      args: {\n        ...prevState.args,\n        paginationOpts: {\n          ...prevState.queries[key].args.paginationOpts,\n          cursor: splitCursor,\n          endCursor: continueCursor,\n        },\n      },\n    };\n    const ongoingSplits = { ...prevState.ongoingSplits };\n    ongoingSplits[key] = [splitKey1, splitKey2];\n    return {\n      ...prevState,\n      nextPageKey,\n      queries,\n      ongoingSplits,\n    };\n  };\n\nconst completeSplitQuery =\n  (key: QueryPageKey) => (prevState: UsePaginatedQueryState) => {\n    const completedSplit = prevState.ongoingSplits[key];\n    if (completedSplit === undefined) {\n      return prevState;\n    }\n    const queries = { ...prevState.queries };\n    delete queries[key];\n    const ongoingSplits = { ...prevState.ongoingSplits };\n    delete ongoingSplits[key];\n    let pageKeys = prevState.pageKeys.slice();\n    const pageIndex = prevState.pageKeys.findIndex((v) => v === key);\n    if (pageIndex >= 0) {\n      pageKeys = [\n        ...prevState.pageKeys.slice(0, pageIndex),\n        ...completedSplit,\n        ...prevState.pageKeys.slice(pageIndex + 1),\n      ];\n    }\n    return {\n      ...prevState,\n      queries,\n      pageKeys,\n      ongoingSplits,\n    };\n  };\n\n/**\n * Load data reactively from a paginated query to a create a growing list.\n *\n * This can be used to power \"infinite scroll\" UIs.\n *\n * This hook must be used with public query references that match\n * {@link PaginatedQueryReference}.\n *\n * `usePaginatedQuery` concatenates all the pages of results into a single list\n * and manages the continuation cursors when requesting more items.\n *\n * Example usage:\n * ```typescript\n * const { results, status, isLoading, loadMore } = usePaginatedQuery(\n *   api.messages.list,\n *   { channel: \"#general\" },\n *   { initialNumItems: 5 }\n * );\n * ```\n *\n * If the query reference or arguments change, the pagination state will be reset\n * to the first page. Similarly, if any of the pages result in an InvalidCursor\n * error or an error associated with too much data, the pagination state will also\n * reset to the first page.\n *\n * To learn more about pagination, see [Paginated Queries](https://docs.convex.dev/database/pagination).\n *\n * @param query - A FunctionReference to the public query function to run.\n * @param args - The arguments object for the query function, excluding\n * the `paginationOpts` property. That property is injected by this hook.\n * @param options - An object specifying the `initialNumItems` to be loaded in\n * the first page.\n * @returns A {@link UsePaginatedQueryResult} that includes the currently loaded\n * items, the status of the pagination, and a `loadMore` function.\n *\n * @public\n */\nexport function usePaginatedQuery<Query extends PaginatedQueryReference>(\n  query: Query,\n  args: PaginatedQueryArgs<Query> | \"skip\",\n  options: { initialNumItems: number }\n): UsePaginatedQueryReturnType<Query> {\n  if (\n    typeof options?.initialNumItems !== \"number\" ||\n    options.initialNumItems < 0\n  ) {\n    throw new Error(\n      `\\`options.initialNumItems\\` must be a positive number. Received \\`${options?.initialNumItems}\\`.`\n    );\n  }\n  const skip = args === \"skip\";\n  const argsObject = skip ? {} : args;\n  const queryName = getFunctionName(query);\n  const createInitialState = useMemo(() => {\n    return () => {\n      const id = nextPaginationId();\n      return {\n        query,\n        args: argsObject as Record<string, Value>,\n        id,\n        nextPageKey: 1,\n        pageKeys: skip ? [] : [0],\n        queries: skip\n          ? ({} as UsePaginatedQueryState[\"queries\"])\n          : {\n              0: {\n                query,\n                args: {\n                  ...argsObject,\n                  paginationOpts: {\n                    numItems: options.initialNumItems,\n                    cursor: null,\n                    id,\n                  },\n                },\n              },\n            },\n        ongoingSplits: {},\n        skip,\n      };\n    };\n    // ESLint doesn't like that we're stringifying the args. We do this because\n    // we want to avoid rerendering if the args are a different\n    // object that serializes to the same result.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    JSON.stringify(convexToJson(argsObject as Value)),\n    queryName,\n    options.initialNumItems,\n    skip,\n  ]);\n\n  const [state, setState] =\n    useState<UsePaginatedQueryState>(createInitialState);\n\n  // `currState` is the state that we'll render based on.\n  let currState = state;\n  if (\n    getFunctionName(query) !== getFunctionName(state.query) ||\n    JSON.stringify(convexToJson(argsObject as Value)) !==\n      JSON.stringify(convexToJson(state.args)) ||\n    skip !== state.skip\n  ) {\n    currState = createInitialState();\n    setState(currState);\n  }\n\n  const resultsObject = useQueries(currState.queries);\n\n  const [results, maybeLastResult]: [\n    Value[],\n    undefined | PaginationResult<Value>\n  ] = useMemo(() => {\n    let currResult = undefined;\n\n    const allItems = [];\n    for (const pageKey of currState.pageKeys) {\n      currResult = resultsObject[pageKey];\n      if (currResult === undefined) {\n        break;\n      }\n\n      if (currResult instanceof Error) {\n        if (currResult.message.includes(\"InvalidCursor\")) {\n          // - InvalidCursor: If the cursor is invalid, probably the paginated\n          // database query was data-dependent and changed underneath us. The\n          // cursor in the params or journal no longer matches the current\n          // database query.\n\n          // In all cases, we want to restart pagination to throw away all our\n          // existing cursors.\n          console.warn(\n            \"usePaginatedQuery hit error, resetting pagination state: \" +\n              currResult.message\n          );\n          setState(createInitialState);\n          return [[], undefined];\n        } else {\n          throw currResult;\n        }\n      }\n      const ongoingSplit = currState.ongoingSplits[pageKey];\n      if (ongoingSplit !== undefined) {\n        if (\n          resultsObject[ongoingSplit[0]] !== undefined &&\n          resultsObject[ongoingSplit[1]] !== undefined\n        ) {\n          // Both pages of the split have results now. Swap them in.\n          setState(completeSplitQuery(pageKey));\n        }\n      } else if (\n        currResult.splitCursor &&\n        (currResult.pageStatus === \"SplitRecommended\" ||\n          currResult.pageStatus === \"SplitRequired\" ||\n          currResult.page.length > options.initialNumItems * 2)\n      ) {\n        // If a single page has more than double the expected number of items,\n        // or if the server requests a split, split the page into two.\n        setState(\n          splitQuery(pageKey, currResult.splitCursor, currResult.continueCursor)\n        );\n      }\n      if (currResult.pageStatus === \"SplitRequired\") {\n        // If pageStatus is 'SplitRequired', it means the server was not able to\n        // fetch the full page. So we stop results before the incomplete\n        // page and return 'LoadingMore' while the page is splitting.\n        return [allItems, undefined];\n      }\n      allItems.push(...currResult.page);\n    }\n    return [allItems, currResult];\n  }, [\n    resultsObject,\n    currState.pageKeys,\n    currState.ongoingSplits,\n    options.initialNumItems,\n    createInitialState,\n  ]);\n\n  const statusObject = useMemo(() => {\n    if (maybeLastResult === undefined) {\n      if (currState.nextPageKey === 1) {\n        return {\n          status: \"LoadingFirstPage\",\n          isLoading: true,\n          loadMore: (_numItems: number) => {\n            // Intentional noop.\n          },\n        } as const;\n      } else {\n        return {\n          status: \"LoadingMore\",\n          isLoading: true,\n          loadMore: (_numItems: number) => {\n            // Intentional noop.\n          },\n        } as const;\n      }\n    }\n    if (maybeLastResult.isDone) {\n      return {\n        status: \"Exhausted\",\n        isLoading: false,\n        loadMore: (_numItems: number) => {\n          // Intentional noop.\n        },\n      } as const;\n    }\n    const continueCursor = maybeLastResult.continueCursor;\n    let alreadyLoadingMore = false;\n    return {\n      status: \"CanLoadMore\",\n      isLoading: false,\n      loadMore: (numItems: number) => {\n        if (!alreadyLoadingMore) {\n          alreadyLoadingMore = true;\n          setState((prevState) => {\n            const pageKeys = [...prevState.pageKeys, prevState.nextPageKey];\n            const queries = { ...prevState.queries };\n            queries[prevState.nextPageKey] = {\n              query: prevState.query,\n              args: {\n                ...prevState.args,\n                paginationOpts: {\n                  numItems,\n                  cursor: continueCursor,\n                  id: prevState.id,\n                },\n              },\n            };\n            return {\n              ...prevState,\n              nextPageKey: prevState.nextPageKey + 1,\n              pageKeys,\n              queries,\n            };\n          });\n        }\n      },\n    } as const;\n  }, [maybeLastResult, currState.nextPageKey]);\n\n  return {\n    results,\n    ...statusObject,\n  };\n}\n\nlet paginationId = 0;\n/**\n * Generate a new, unique ID for a pagination session.\n *\n * Every usage of {@link usePaginatedQuery} puts a unique ID into the\n * query function arguments as a \"cache-buster\". This serves two purposes:\n *\n * 1. All calls to {@link usePaginatedQuery} have independent query\n * journals.\n *\n * Every time we start a new pagination session, we'll load the first page of\n * results and receive a fresh journal. Without the ID, we might instead reuse\n * a query subscription already present in our client. This isn't desirable\n * because the existing query function result may have grown or shrunk from the\n * requested `initialNumItems`.\n *\n * 2. We can restart the pagination session on some types of errors.\n *\n * Sometimes we want to restart pagination from the beginning if we hit an error.\n * Similar to (1), we'd like to ensure that this new session actually requests\n * its first page from the server and doesn't reuse a query result already\n * present in the client that may have hit the error.\n *\n * @returns The pagination ID.\n */\nfunction nextPaginationId(): number {\n  paginationId++;\n  return paginationId;\n}\n\n/**\n * Reset pagination id for tests only, so tests know what it is.\n */\nexport function resetPaginationId() {\n  paginationId = 0;\n}\n\n/**\n * The result of calling the {@link usePaginatedQuery} hook.\n *\n * This includes:\n * - `results` - An array of the currently loaded results.\n * - `isLoading` - Whether the hook is currently loading results.\n * - `status` - The status of the pagination. The possible statuses are:\n *   - \"LoadingFirstPage\": The hook is loading the first page of results.\n *   - \"CanLoadMore\": This query may have more items to fetch. Call `loadMore` to\n *   fetch another page.\n *   - \"LoadingMore\": We're currently loading another page of results.\n *   - \"Exhausted\": We've paginated to the end of the list.\n * - `loadMore(n)` A callback to fetch more results. This will only fetch more\n * results if the status is \"CanLoadMore\".\n *\n * @public\n */\nexport type UsePaginatedQueryResult<Item> = {\n  results: Item[];\n  loadMore: (numItems: number) => void;\n} & (\n  | {\n      status: \"LoadingFirstPage\";\n      isLoading: true;\n    }\n  | {\n      status: \"CanLoadMore\";\n      isLoading: false;\n    }\n  | {\n      status: \"LoadingMore\";\n      isLoading: true;\n    }\n  | {\n      status: \"Exhausted\";\n      isLoading: false;\n    }\n);\n\n/**\n * The possible pagination statuses in {@link UsePaginatedQueryResult}.\n *\n * This is a union of string literal types.\n * @public\n */\nexport type PaginationStatus = UsePaginatedQueryResult<any>[\"status\"];\n\n/**\n * Given a {@link PaginatedQueryReference}, get the type of the arguments\n * object for the query, excluding the `paginationOpts` argument.\n *\n * @public\n */\nexport type PaginatedQueryArgs<Query extends PaginatedQueryReference> = Expand<\n  BetterOmit<FunctionArgs<Query>, \"paginationOpts\">\n>;\n\n/**\n * Given a {@link PaginatedQueryReference}, get the type of the item being\n * paginated over.\n * @public\n */\nexport type PaginatedQueryItem<Query extends PaginatedQueryReference> =\n  FunctionReturnType<Query>[\"page\"][number];\n\n/**\n * The return type of {@link usePaginatedQuery}.\n *\n * @public\n */\nexport type UsePaginatedQueryReturnType<Query extends PaginatedQueryReference> =\n  UsePaginatedQueryResult<PaginatedQueryItem<Query>>;\n\n/**\n * Optimistically update the values in a paginated list.\n *\n * This optimistic update is designed to be used to update data loaded with\n * {@link usePaginatedQuery}. It updates the list by applying\n * `updateValue` to each element of the list across all of the loaded pages.\n *\n * This will only apply to queries with a matching names and arguments.\n *\n * Example usage:\n * ```ts\n * const myMutation = useMutation(api.myModule.myMutation)\n * .withOptimisticUpdate((localStore, mutationArg) => {\n *\n *   // Optimistically update the document with ID `mutationArg`\n *   // to have an additional property.\n *\n *   optimisticallyUpdateValueInPaginatedQuery(\n *     localStore,\n *     api.myModule.paginatedQuery\n *     {},\n *     currentValue => {\n *       if (mutationArg === currentValue._id) {\n *         return {\n *           ...currentValue,\n *           \"newProperty\": \"newValue\",\n *         };\n *       }\n *       return currentValue;\n *     }\n *   );\n *\n * });\n * ```\n *\n * @param localStore - An {@link OptimisticLocalStore} to update.\n * @param query - A {@link FunctionReference} for the paginated query to update.\n * @param args - The arguments object to the query function, excluding the\n * `paginationOpts` property.\n * @param updateValue - A function to produce the new values.\n *\n * @public\n */\nexport function optimisticallyUpdateValueInPaginatedQuery<\n  Query extends PaginatedQueryReference\n>(\n  localStore: OptimisticLocalStore,\n  query: Query,\n  args: PaginatedQueryArgs<Query>,\n  updateValue: (\n    currentValue: PaginatedQueryItem<Query>\n  ) => PaginatedQueryItem<Query>\n): void {\n  const expectedArgs = JSON.stringify(convexToJson(args as Value));\n\n  for (const queryResult of localStore.getAllQueries(query)) {\n    if (queryResult.value !== undefined) {\n      const { paginationOpts: _, ...innerArgs } = queryResult.args as {\n        paginationOpts: PaginationOptions;\n      };\n      if (JSON.stringify(convexToJson(innerArgs as Value)) === expectedArgs) {\n        const value = queryResult.value;\n        if (\n          typeof value === \"object\" &&\n          value !== null &&\n          Array.isArray(value.page)\n        ) {\n          localStore.setQuery(query, queryResult.args, {\n            ...value,\n            page: value.page.map(updateValue),\n          });\n        }\n      }\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkC;AASlC,oBAA2C;AAC3C,yBAA2B;AAC3B,iBAIO;AA0CP,MAAM,aACJ,CAAC,KAAmB,aAAqB,mBACzC,CAAC,cAAsC;AACrC,QAAM,UAAU,EAAE,GAAG,UAAU,QAAQ;AACvC,QAAM,YAAY,UAAU;AAC5B,QAAM,YAAY,UAAU,cAAc;AAC1C,QAAM,cAAc,UAAU,cAAc;AAC5C,UAAQ,SAAS,IAAI;AAAA,IACnB,OAAO,UAAU;AAAA,IACjB,MAAM;AAAA,MACJ,GAAG,UAAU;AAAA,MACb,gBAAgB;AAAA,QACd,GAAG,UAAU,QAAQ,GAAG,EAAE,KAAK;AAAA,QAC/B,WAAW;AAAA,MACb;AAAA,IACF;AAAA,EACF;AACA,UAAQ,SAAS,IAAI;AAAA,IACnB,OAAO,UAAU;AAAA,IACjB,MAAM;AAAA,MACJ,GAAG,UAAU;AAAA,MACb,gBAAgB;AAAA,QACd,GAAG,UAAU,QAAQ,GAAG,EAAE,KAAK;AAAA,QAC/B,QAAQ;AAAA,QACR,WAAW;AAAA,MACb;AAAA,IACF;AAAA,EACF;AACA,QAAM,gBAAgB,EAAE,GAAG,UAAU,cAAc;AACnD,gBAAc,GAAG,IAAI,CAAC,WAAW,SAAS;AAC1C,SAAO;AAAA,IACL,GAAG;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEF,MAAM,qBACJ,CAAC,QAAsB,CAAC,cAAsC;AAC5D,QAAM,iBAAiB,UAAU,cAAc,GAAG;AAClD,MAAI,mBAAmB,QAAW;AAChC,WAAO;AAAA,EACT;AACA,QAAM,UAAU,EAAE,GAAG,UAAU,QAAQ;AACvC,SAAO,QAAQ,GAAG;AAClB,QAAM,gBAAgB,EAAE,GAAG,UAAU,cAAc;AACnD,SAAO,cAAc,GAAG;AACxB,MAAI,WAAW,UAAU,SAAS,MAAM;AACxC,QAAM,YAAY,UAAU,SAAS,UAAU,CAAC,MAAM,MAAM,GAAG;AAC/D,MAAI,aAAa,GAAG;AAClB,eAAW;AAAA,MACT,GAAG,UAAU,SAAS,MAAM,GAAG,SAAS;AAAA,MACxC,GAAG;AAAA,MACH,GAAG,UAAU,SAAS,MAAM,YAAY,CAAC;AAAA,IAC3C;AAAA,EACF;AACA,SAAO;AAAA,IACL,GAAG;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAuCK,SAAS,kBACd,OACA,MACA,SACoC;AACpC,MACE,OAAO,SAAS,oBAAoB,YACpC,QAAQ,kBAAkB,GAC1B;AACA,UAAM,IAAI;AAAA,MACR,qEAAqE,SAAS;AAAA,IAChF;AAAA,EACF;AACA,QAAM,OAAO,SAAS;AACtB,QAAM,aAAa,OAAO,CAAC,IAAI;AAC/B,QAAM,gBAAY,4BAAgB,KAAK;AACvC,QAAM,yBAAqB,sBAAQ,MAAM;AACvC,WAAO,MAAM;AACX,YAAM,KAAK,iBAAiB;AAC5B,aAAO;AAAA,QACL;AAAA,QACA,MAAM;AAAA,QACN;AAAA,QACA,aAAa;AAAA,QACb,UAAU,OAAO,CAAC,IAAI,CAAC,CAAC;AAAA,QACxB,SAAS,OACJ,CAAC,IACF;AAAA,UACE,GAAG;AAAA,YACD;AAAA,YACA,MAAM;AAAA,cACJ,GAAG;AAAA,cACH,gBAAgB;AAAA,gBACd,UAAU,QAAQ;AAAA,gBAClB,QAAQ;AAAA,gBACR;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,QACJ,eAAe,CAAC;AAAA,QAChB;AAAA,MACF;AAAA,IACF;AAAA,EAKF,GAAG;AAAA;AAAA,IAED,KAAK,cAAU,4BAAa,UAAmB,CAAC;AAAA,IAChD;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,EACF,CAAC;AAED,QAAM,CAAC,OAAO,QAAQ,QACpB,uBAAiC,kBAAkB;AAGrD,MAAI,YAAY;AAChB,UACE,4BAAgB,KAAK,UAAM,4BAAgB,MAAM,KAAK,KACtD,KAAK,cAAU,4BAAa,UAAmB,CAAC,MAC9C,KAAK,cAAU,4BAAa,MAAM,IAAI,CAAC,KACzC,SAAS,MAAM,MACf;AACA,gBAAY,mBAAmB;AAC/B,aAAS,SAAS;AAAA,EACpB;AAEA,QAAM,oBAAgB,+BAAW,UAAU,OAAO;AAElD,QAAM,CAAC,SAAS,eAAe,QAG3B,sBAAQ,MAAM;AAChB,QAAI,aAAa;AAEjB,UAAM,WAAW,CAAC;AAClB,eAAW,WAAW,UAAU,UAAU;AACxC,mBAAa,cAAc,OAAO;AAClC,UAAI,eAAe,QAAW;AAC5B;AAAA,MACF;AAEA,UAAI,sBAAsB,OAAO;AAC/B,YAAI,WAAW,QAAQ,SAAS,eAAe,GAAG;AAQhD,kBAAQ;AAAA,YACN,8DACE,WAAW;AAAA,UACf;AACA,mBAAS,kBAAkB;AAC3B,iBAAO,CAAC,CAAC,GAAG,MAAS;AAAA,QACvB,OAAO;AACL,gBAAM;AAAA,QACR;AAAA,MACF;AACA,YAAM,eAAe,UAAU,cAAc,OAAO;AACpD,UAAI,iBAAiB,QAAW;AAC9B,YACE,cAAc,aAAa,CAAC,CAAC,MAAM,UACnC,cAAc,aAAa,CAAC,CAAC,MAAM,QACnC;AAEA,mBAAS,mBAAmB,OAAO,CAAC;AAAA,QACtC;AAAA,MACF,WACE,WAAW,gBACV,WAAW,eAAe,sBACzB,WAAW,eAAe,mBAC1B,WAAW,KAAK,SAAS,QAAQ,kBAAkB,IACrD;AAGA;AAAA,UACE,WAAW,SAAS,WAAW,aAAa,WAAW,cAAc;AAAA,QACvE;AAAA,MACF;AACA,UAAI,WAAW,eAAe,iBAAiB;AAI7C,eAAO,CAAC,UAAU,MAAS;AAAA,MAC7B;AACA,eAAS,KAAK,GAAG,WAAW,IAAI;AAAA,IAClC;AACA,WAAO,CAAC,UAAU,UAAU;AAAA,EAC9B,GAAG;AAAA,IACD;AAAA,IACA,UAAU;AAAA,IACV,UAAU;AAAA,IACV,QAAQ;AAAA,IACR;AAAA,EACF,CAAC;AAED,QAAM,mBAAe,sBAAQ,MAAM;AACjC,QAAI,oBAAoB,QAAW;AACjC,UAAI,UAAU,gBAAgB,GAAG;AAC/B,eAAO;AAAA,UACL,QAAQ;AAAA,UACR,WAAW;AAAA,UACX,UAAU,CAAC,cAAsB;AAAA,UAEjC;AAAA,QACF;AAAA,MACF,OAAO;AACL,eAAO;AAAA,UACL,QAAQ;AAAA,UACR,WAAW;AAAA,UACX,UAAU,CAAC,cAAsB;AAAA,UAEjC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,QAAI,gBAAgB,QAAQ;AAC1B,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,WAAW;AAAA,QACX,UAAU,CAAC,cAAsB;AAAA,QAEjC;AAAA,MACF;AAAA,IACF;AACA,UAAM,iBAAiB,gBAAgB;AACvC,QAAI,qBAAqB;AACzB,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,UAAU,CAAC,aAAqB;AAC9B,YAAI,CAAC,oBAAoB;AACvB,+BAAqB;AACrB,mBAAS,CAAC,cAAc;AACtB,kBAAM,WAAW,CAAC,GAAG,UAAU,UAAU,UAAU,WAAW;AAC9D,kBAAM,UAAU,EAAE,GAAG,UAAU,QAAQ;AACvC,oBAAQ,UAAU,WAAW,IAAI;AAAA,cAC/B,OAAO,UAAU;AAAA,cACjB,MAAM;AAAA,gBACJ,GAAG,UAAU;AAAA,gBACb,gBAAgB;AAAA,kBACd;AAAA,kBACA,QAAQ;AAAA,kBACR,IAAI,UAAU;AAAA,gBAChB;AAAA,cACF;AAAA,YACF;AACA,mBAAO;AAAA,cACL,GAAG;AAAA,cACH,aAAa,UAAU,cAAc;AAAA,cACrC;AAAA,cACA;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF,GAAG,CAAC,iBAAiB,UAAU,WAAW,CAAC;AAE3C,SAAO;AAAA,IACL;AAAA,IACA,GAAG;AAAA,EACL;AACF;AAEA,IAAI,eAAe;AAyBnB,SAAS,mBAA2B;AAClC;AACA,SAAO;AACT;AAKO,SAAS,oBAAoB;AAClC,iBAAe;AACjB;AAsHO,SAAS,0CAGd,YACA,OACA,MACA,aAGM;AACN,QAAM,eAAe,KAAK,cAAU,4BAAa,IAAa,CAAC;AAE/D,aAAW,eAAe,WAAW,cAAc,KAAK,GAAG;AACzD,QAAI,YAAY,UAAU,QAAW;AACnC,YAAM,EAAE,gBAAgB,GAAG,GAAG,UAAU,IAAI,YAAY;AAGxD,UAAI,KAAK,cAAU,4BAAa,SAAkB,CAAC,MAAM,cAAc;AACrE,cAAM,QAAQ,YAAY;AAC1B,YACE,OAAO,UAAU,YACjB,UAAU,QACV,MAAM,QAAQ,MAAM,IAAI,GACxB;AACA,qBAAW,SAAS,OAAO,YAAY,MAAM;AAAA,YAC3C,GAAG;AAAA,YACH,MAAM,MAAM,KAAK,IAAI,WAAW;AAAA,UAClC,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}
