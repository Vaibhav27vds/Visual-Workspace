{
  "version": 3,
  "sources": ["../../../src/bundler/index.ts"],
  "sourcesContent": ["import { parse as parseAST } from \"@babel/parser\";\nimport path from \"path\";\nimport chalk from \"chalk\";\nimport esbuild from \"esbuild\";\nimport { Filesystem } from \"./fs.js\";\nimport { Context, logFailure, logWarning } from \"./context.js\";\nimport { wasmPlugin } from \"./wasm.js\";\nimport {\n  ExternalPackage,\n  computeExternalPackages,\n  createExternalPlugin,\n  findExactVersionAndDependencies,\n} from \"./external.js\";\nexport { nodeFs, RecordingFs } from \"./fs.js\";\nexport type { Filesystem } from \"./fs.js\";\n\nexport const actionsDir = \"actions\";\n\n// Returns a generator of { isDir, path } for all paths\n// within dirPath in some topological order (not including\n// dirPath itself).\nexport function* walkDir(\n  fs: Filesystem,\n  dirPath: string\n): Generator<{ isDir: boolean; path: string }, void, void> {\n  for (const dirEntry of fs.listDir(dirPath).sort()) {\n    const childPath = path.join(dirPath, dirEntry.name);\n    if (dirEntry.isDirectory()) {\n      yield { isDir: true, path: childPath };\n      yield* walkDir(fs, childPath);\n    } else if (dirEntry.isFile()) {\n      yield { isDir: false, path: childPath };\n    }\n  }\n}\n\n// Convex specific module environment.\ntype ModuleEnvironment = \"node\" | \"isolate\";\n\nexport interface Bundle {\n  path: string;\n  source: string;\n  sourceMap?: string;\n  environment: ModuleEnvironment;\n}\n\ntype EsBuildResult = esbuild.BuildResult & {\n  outputFiles: esbuild.OutputFile[];\n  // Set of referenced external modules.\n  externalModuleNames: Set<string>;\n  // Set of bundled modules.\n  bundledModuleNames: Set<string>;\n};\n\nasync function doEsbuild(\n  ctx: Context,\n  dir: string,\n  entryPoints: string[],\n  generateSourceMaps: boolean,\n  platform: esbuild.Platform,\n  chunksFolder: string,\n  externalPackages: Map<string, ExternalPackage>\n): Promise<EsBuildResult> {\n  const external = createExternalPlugin(ctx, externalPackages);\n  try {\n    const result = await esbuild.build({\n      entryPoints,\n      bundle: true,\n      platform: platform,\n      format: \"esm\",\n      target: \"esnext\",\n      outdir: \"out\",\n      outbase: dir,\n      conditions: [\"convex\", \"module\"],\n      // The wasmPlugin should be last so it doesn't run on external modules.\n      plugins: [external.plugin, wasmPlugin],\n      write: false,\n      sourcemap: generateSourceMaps,\n      splitting: true,\n      chunkNames: path.join(chunksFolder, \"[hash]\"),\n      treeShaking: true,\n      minify: false,\n      keepNames: true,\n      metafile: true,\n    });\n\n    for (const [relPath, input] of Object.entries(result.metafile!.inputs)) {\n      // TODO: esbuild outputs paths prefixed with \"(disabled)\"\" when bundling our internal\n      // udf-system package. The files do actually exist locally, though.\n      if (\n        relPath.indexOf(\"(disabled):\") !== -1 ||\n        relPath.startsWith(\"wasm-binary:\") ||\n        relPath.startsWith(\"wasm-stub:\")\n      ) {\n        continue;\n      }\n      const absPath = path.resolve(relPath);\n      const st = ctx.fs.stat(absPath);\n      if (st.size !== input.bytes) {\n        logWarning(\n          ctx,\n          `Bundled file ${absPath} changed right after esbuild invocation`\n        );\n        // Consider this a transient error so we'll try again and hopefully\n        // no files change right after esbuild next time.\n        return await ctx.crash(1, \"transient\");\n      }\n      ctx.fs.registerPath(absPath, st);\n    }\n    return {\n      ...result,\n      externalModuleNames: external.externalModuleNames,\n      bundledModuleNames: external.bundledModuleNames,\n    };\n  } catch (err) {\n    // We don't print any error because esbuild already printed\n    // all the relevant information.\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n}\n\nexport async function bundle(\n  ctx: Context,\n  dir: string,\n  entryPoints: string[],\n  generateSourceMaps: boolean,\n  platform: esbuild.Platform,\n  chunksFolder = \"_deps\",\n  externalPackagesAllowList: string[] = []\n): Promise<{\n  modules: Bundle[];\n  externalDependencies: Map<string, string>;\n  bundledModuleNames: Set<string>;\n}> {\n  const availableExternalPackages = await computeExternalPackages(\n    ctx,\n    externalPackagesAllowList\n  );\n  const result = await doEsbuild(\n    ctx,\n    dir,\n    entryPoints,\n    generateSourceMaps,\n    platform,\n    chunksFolder,\n    availableExternalPackages\n  );\n  if (result.errors.length) {\n    for (const error of result.errors) {\n      console.log(chalk.red(`esbuild error: ${error.text}`));\n    }\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n  for (const warning of result.warnings) {\n    console.log(chalk.yellow(`esbuild warning: ${warning.text}`));\n  }\n  const sourceMaps = new Map();\n  const modules: Bundle[] = [];\n  const environment = platform === \"node\" ? \"node\" : \"isolate\";\n  for (const outputFile of result.outputFiles) {\n    const relPath = path.relative(path.normalize(\"out\"), outputFile.path);\n    if (path.extname(relPath) === \".map\") {\n      sourceMaps.set(relPath, outputFile.text);\n      continue;\n    }\n    const posixRelPath = relPath.split(path.sep).join(path.posix.sep);\n    modules.push({ path: posixRelPath, source: outputFile.text, environment });\n  }\n  for (const module of modules) {\n    const sourceMapPath = module.path + \".map\";\n    const sourceMap = sourceMaps.get(sourceMapPath);\n    if (sourceMap) {\n      module.sourceMap = sourceMap;\n    }\n  }\n\n  return {\n    modules,\n    externalDependencies: await externalPackageVersions(\n      ctx,\n      availableExternalPackages,\n      result.externalModuleNames\n    ),\n    bundledModuleNames: result.bundledModuleNames,\n  };\n}\n\n// We could return the full list of availableExternalPackages, but this would be\n// installing more packages that we need. Instead, we collect all external\n// dependencies we found during bundling the /convex function, as well as their\n// respective peer and optional dependencies.\nasync function externalPackageVersions(\n  ctx: Context,\n  availableExternalPackages: Map<string, ExternalPackage>,\n  referencedPackages: Set<string>\n): Promise<Map<string, string>> {\n  const versions = new Map<string, string>();\n  const referencedPackagesQueue = Array.from(referencedPackages.keys());\n\n  for (let i = 0; i < referencedPackagesQueue.length; i++) {\n    const moduleName = referencedPackagesQueue[i];\n    // This assertion is safe because referencedPackages can only contain\n    // packages in availableExternalPackages.\n    const modulePath = availableExternalPackages.get(moduleName)!.path;\n    // Since we don't support lock files and different install commands yet, we\n    // pick up the exact version installed on the local filesystem.\n    const { version, peerAndOptionalDependencies } =\n      await findExactVersionAndDependencies(ctx, moduleName, modulePath);\n    versions.set(moduleName, version);\n\n    for (const dependency of peerAndOptionalDependencies) {\n      if (\n        availableExternalPackages.has(dependency) &&\n        !referencedPackages.has(dependency)\n      ) {\n        referencedPackagesQueue.push(dependency);\n        referencedPackages.add(dependency);\n      }\n    }\n  }\n\n  return versions;\n}\n\nexport async function bundleSchema(ctx: Context, dir: string) {\n  const result = await bundle(\n    ctx,\n    dir,\n    [path.resolve(dir, \"schema.ts\")],\n    true,\n    \"browser\"\n  );\n  return result.modules;\n}\n\nexport async function bundleAuthConfig(ctx: Context, dir: string) {\n  const authConfigPath = path.resolve(dir, \"auth.config.js\");\n  const authConfigTsPath = path.resolve(dir, \"auth.config.ts\");\n  if (!ctx.fs.exists(authConfigPath) && ctx.fs.exists(authConfigTsPath)) {\n    logFailure(\n      ctx,\n      `Auth config file ${authConfigTsPath} found with .ts extension, but auth.config.js must be a JavaScript file.`\n    );\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n  if (!ctx.fs.exists(authConfigPath)) {\n    return [];\n  }\n  const result = await bundle(ctx, dir, [authConfigPath], true, \"browser\");\n  return result.modules;\n}\n\nexport async function entryPoints(\n  ctx: Context,\n  dir: string,\n  verbose: boolean\n): Promise<string[]> {\n  const entryPoints = [];\n\n  const log = (line: string) => {\n    if (verbose) {\n      console.log(line);\n    }\n  };\n\n  for (const { isDir, path: fpath } of walkDir(ctx.fs, dir)) {\n    if (isDir) {\n      continue;\n    }\n    const relPath = path.relative(dir, fpath);\n    const base = path.parse(fpath).base;\n\n    if (relPath.startsWith(\"_deps\" + path.sep)) {\n      logFailure(\n        ctx,\n        `The path \"${fpath}\" is within the \"_deps\" directory, which is reserved for dependencies. Please move your code to another directory.`\n      );\n      return await ctx.crash(1, \"invalid filesystem data\");\n    } else if (relPath.startsWith(\"_generated\" + path.sep)) {\n      log(chalk.yellow(`Skipping ${fpath}`));\n    } else if (base.startsWith(\".\")) {\n      log(chalk.yellow(`Skipping dotfile ${fpath}`));\n    } else if (base === \"README.md\") {\n      log(chalk.yellow(`Skipping ${fpath}`));\n    } else if (base === \"_generated.ts\") {\n      log(chalk.yellow(`Skipping ${fpath}`));\n    } else if (base === \"schema.ts\") {\n      log(chalk.yellow(`Skipping ${fpath}`));\n    } else if ((base.match(/\\./g) || []).length > 1) {\n      log(chalk.yellow(`Skipping ${fpath} that contains multiple dots`));\n    } else if (base === \"tsconfig.json\") {\n      log(chalk.yellow(`Skipping ${fpath}`));\n    } else if (relPath.endsWith(\".config.js\")) {\n      log(chalk.yellow(`Skipping ${fpath}`));\n    } else if (relPath.includes(\" \")) {\n      log(chalk.yellow(`Skipping ${relPath} because it contains a space`));\n    } else if (base.endsWith(\".d.ts\")) {\n      log(chalk.yellow(`Skipping ${fpath} declaration file`));\n    } else if (base.endsWith(\".json\")) {\n      log(chalk.yellow(`Skipping ${fpath} json file`));\n    } else {\n      log(chalk.green(`Preparing ${fpath}`));\n      entryPoints.push(fpath);\n    }\n  }\n\n  // If using TypeScript, require that at least one line starts with `export` or `import`,\n  // a TypeScript requirement. This prevents confusing type errors described in CX-5067.\n  const nonEmptyEntryPoints = entryPoints.filter((fpath) => {\n    // This check only makes sense for TypeScript files\n    if (!fpath.endsWith(\".ts\") && !fpath.endsWith(\".tsx\")) {\n      return true;\n    }\n    const contents = ctx.fs.readUtf8File(fpath);\n    if (/^\\s{0,100}(import|export)/m.test(contents)) {\n      return true;\n    }\n    log(\n      chalk.yellow(\n        `Skipping ${fpath} because it has no export or import to make it a valid TypeScript module`\n      )\n    );\n  });\n\n  return nonEmptyEntryPoints;\n}\n\n// A fallback regex in case we fail to parse the AST.\nexport const useNodeDirectiveRegex = /^\\s*(\"|')use node(\"|');?\\s*$/;\n\nfunction hasUseNodeDirective(\n  fs: Filesystem,\n  fpath: string,\n  verbose: boolean\n): boolean {\n  // Do a quick check for the exact string. If it doesn't exist, don't\n  // bother parsing.\n  const source = fs.readUtf8File(fpath);\n  if (source.indexOf(\"use node\") === -1) {\n    return false;\n  }\n\n  // We parse the AST here to extract the \"use node\" declaration. This is more\n  // robust than doing a regex. We only use regex as a fallback.\n  try {\n    const ast = parseAST(source, {\n      // parse in strict mode and allow module declarations\n      sourceType: \"module\",\n\n      // esbuild supports jsx and typescript by default. Allow the same plugins\n      // here too.\n      plugins: [\"jsx\", \"typescript\"],\n    });\n    return ast.program.directives\n      .map((d) => d.value.value)\n      .includes(\"use node\");\n  } catch (error: any) {\n    // Given that we have failed to parse, we are most likely going to fail in\n    // the esbuild step, which seem to return better formatted error messages.\n    // We don't throw here and fallback to regex.\n    let lineMatches = false;\n    for (const line of source.split(\"\\n\")) {\n      if (line.match(useNodeDirectiveRegex)) {\n        lineMatches = true;\n        break;\n      }\n    }\n\n    if (verbose) {\n      // Log that we failed to parse in verbose node if we need this for debugging.\n      console.warn(\n        `Failed to parse ${fpath}. Use node is set to ${lineMatches} based on regex. Parse error: ${error.toString()}.`\n      );\n    }\n\n    return lineMatches;\n  }\n}\n\nexport function mustBeIsolate(relPath: string): boolean {\n  // Check if the path without extension matches any of the static paths.\n  return [\"http\", \"crons\", \"schema\", \"auth.config\"].includes(\n    relPath.replace(/\\.[^/.]+$/, \"\")\n  );\n}\n\nasync function determineEnvironment(\n  ctx: Context,\n  dir: string,\n  fpath: string,\n  verbose: boolean\n): Promise<ModuleEnvironment> {\n  const relPath = path.relative(dir, fpath);\n\n  const useNodeDirectiveFound = hasUseNodeDirective(ctx.fs, fpath, verbose);\n  if (useNodeDirectiveFound) {\n    if (mustBeIsolate(relPath)) {\n      logFailure(ctx, `\"use node\" directive is not allowed for ${relPath}.`);\n      return await ctx.crash(1, \"invalid filesystem data\");\n    }\n    return \"node\";\n  }\n\n  const actionsPrefix = actionsDir + path.sep;\n  if (relPath.startsWith(actionsPrefix)) {\n    logFailure(\n      ctx,\n      `${relPath} is in /actions subfolder but has no \"use node\"; directive. You can now define actions in any folder and indicate they should run in node by adding \"use node\" directive. /actions is a deprecated way to choose Node.js environment, and we require \"use node\" for all files within that folder to avoid unexpected errors during the migration. See https://docs.convex.dev/functions/actions for more details`\n    );\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n\n  return \"isolate\";\n}\n\nexport async function entryPointsByEnvironment(\n  ctx: Context,\n  dir: string,\n  verbose: boolean\n) {\n  const isolate = [];\n  const node = [];\n  for (const entryPoint of await entryPoints(ctx, dir, verbose)) {\n    const environment = await determineEnvironment(\n      ctx,\n      dir,\n      entryPoint,\n      verbose\n    );\n    if (environment === \"node\") {\n      node.push(entryPoint);\n    } else {\n      isolate.push(entryPoint);\n    }\n  }\n\n  return { isolate, node };\n}\n"],
  "mappings": "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",
  "names": ["import_fs", "path", "entryPoints", "esbuild", "chalk", "module", "parseAST"]
}
