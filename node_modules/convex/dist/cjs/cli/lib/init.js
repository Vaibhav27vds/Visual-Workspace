"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var init_exports = {};
__export(init_exports, {
  finalizeConfiguration: () => finalizeConfiguration,
  init: () => init
});
module.exports = __toCommonJS(init_exports);
var import_chalk = __toESM(require("chalk"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var import_path = __toESM(require("path"), 1);
var import_context = require("../../bundler/context.js");
var import_dashboard = require("../dashboard.js");
var import_api = require("./api.js");
var import_codegen = require("./codegen.js");
var import_config = require("./config.js");
var import_deployment = require("./deployment.js");
var import_envvars = require("./envvars.js");
var import_utils = require("./utils.js");
const cwd = import_path.default.basename(process.cwd());
async function init(ctx, deploymentType = "prod", config) {
  const configPath = await (0, import_config.configFilepath)(ctx);
  const { teamSlug: selectedTeam, chosen: didChooseBetweenTeams } = await (0, import_utils.validateOrSelectTeam)(ctx, config.team, "Team:");
  let projectName = config.project || cwd;
  if (process.stdin.isTTY && !config.project) {
    projectName = (await import_inquirer.default.prompt([
      {
        type: "input",
        name: "project",
        message: "Project name:",
        default: cwd
      }
    ])).project;
  }
  (0, import_context.showSpinner)(ctx, "Creating new Convex project...");
  let projectSlug, teamSlug, deploymentName, url, adminKey, projectsRemaining;
  try {
    ({
      projectSlug,
      teamSlug,
      deploymentName,
      url,
      adminKey,
      projectsRemaining
    } = await (0, import_api.createProjectProvisioningDevOrProd)(
      ctx,
      { teamSlug: selectedTeam, projectName },
      deploymentType
    ));
  } catch (err) {
    (0, import_context.logFailure)(ctx, "Unable to create project.");
    return await (0, import_utils.logAndHandleAxiosError)(ctx, err);
  }
  const teamMessage = didChooseBetweenTeams ? " in team " + import_chalk.default.bold(teamSlug) : "";
  (0, import_context.logFinishedStep)(
    ctx,
    `Created project ${import_chalk.default.bold(
      projectSlug
    )}${teamMessage}, manage it at ${import_chalk.default.bold(
      (0, import_dashboard.dashboardUrl)(teamSlug, projectSlug, null)
    )}`
  );
  if (projectsRemaining <= 2) {
    (0, import_context.logWarning)(
      ctx,
      import_chalk.default.yellow.bold(
        `Your account now has ${projectsRemaining} project${projectsRemaining === 1 ? "" : "s"} remaining.`
      )
    );
  }
  const { projectConfig: existingProjectConfig } = await (0, import_config.readProjectConfig)(ctx);
  const functionsPath = (0, import_utils.functionsDir)(configPath, existingProjectConfig);
  const { wroteToGitIgnore } = await (0, import_deployment.writeDeploymentEnvVar)(
    ctx,
    deploymentType,
    {
      team: teamSlug,
      project: projectSlug,
      deploymentName
    }
  );
  const projectConfig = await (0, import_config.upgradeOldAuthInfoToAuthConfig)(
    ctx,
    existingProjectConfig,
    functionsPath
  );
  await (0, import_config.writeProjectConfig)(ctx, projectConfig);
  await (0, import_codegen.doInitCodegen)({
    ctx,
    functionsDirectoryPath: functionsPath,
    quiet: true
  });
  {
    const functionsDirectoryPath = await (0, import_config.getFunctionsDirectoryPath)(ctx);
    await (0, import_codegen.doCodegen)({
      ctx,
      functionsDirectoryPath,
      // Don't typecheck because there isn't any code to check yet.
      typeCheckMode: "disable",
      quiet: true
    });
  }
  await finalizeConfiguration(
    ctx,
    functionsPath,
    deploymentType,
    url,
    wroteToGitIgnore
  );
  return { deploymentName, adminKey, url };
}
async function finalizeConfiguration(ctx, functionsPath, deploymentType, url, wroteToGitIgnore) {
  const envVarWrite = await (0, import_envvars.writeConvexUrlToEnvFile)(ctx, url);
  if (envVarWrite !== null) {
    (0, import_context.logFinishedStep)(
      ctx,
      `Provisioned a ${deploymentType} deployment and saved its:
    name as CONVEX_DEPLOYMENT to .env.local
    URL as ${envVarWrite.envVar} to ${envVarWrite.envFile}`
    );
  } else {
    (0, import_context.logFinishedStep)(
      ctx,
      `Provisioned ${deploymentType} deployment and saved its name as CONVEX_DEPLOYMENT to .env.local`
    );
  }
  if (wroteToGitIgnore) {
    (0, import_context.logMessage)(ctx, import_chalk.default.gray(`  Added ".env.local" to .gitignore`));
  }
  (0, import_context.logMessage)(
    ctx,
    `
Write your Convex functions in ${import_chalk.default.bold(functionsPath)}
Give us feedback at https://convex.dev/community or support@convex.dev
`
  );
}
//# sourceMappingURL=init.js.map
