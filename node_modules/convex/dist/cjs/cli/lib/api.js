"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var api_exports = {};
__export(api_exports, {
  CONVEX_DEPLOY_KEY_ENV_VAR_NAME: () => CONVEX_DEPLOY_KEY_ENV_VAR_NAME,
  createProjectProvisioningDevOrProd: () => createProjectProvisioningDevOrProd,
  deploymentNameFromAdminKey: () => deploymentNameFromAdminKey,
  fetchDeploymentCredentialsForName: () => fetchDeploymentCredentialsForName,
  fetchDeploymentCredentialsProvisionProd: () => fetchDeploymentCredentialsProvisionProd,
  fetchDeploymentCredentialsProvisioningDevOrProd: () => fetchDeploymentCredentialsProvisioningDevOrProd,
  fetchDeploymentCredentialsProvisioningDevOrProdMaybeThrows: () => fetchDeploymentCredentialsProvisioningDevOrProdMaybeThrows,
  fetchProdDeploymentCredentials: () => fetchProdDeploymentCredentials,
  fetchTeamAndProject: () => fetchTeamAndProject,
  readConfiguredAdminKey: () => readConfiguredAdminKey
});
module.exports = __toCommonJS(api_exports);
var import_chalk = __toESM(require("chalk"), 1);
var import_utils = require("./utils.js");
var import_context = require("../../bundler/context.js");
var import_deployment = require("./deployment.js");
var import_envvars = require("./envvars.js");
var import_login = require("./login.js");
const CONVEX_DEPLOY_KEY_ENV_VAR_NAME = "CONVEX_DEPLOY_KEY";
async function createProjectProvisioningDevOrProd(ctx, {
  teamSlug: selectedTeamSlug,
  projectName
}, firstDeploymentType) {
  const provisioningArgs = {
    team: selectedTeamSlug,
    projectName,
    deploymentType: firstDeploymentType,
    backendVersionOverride: process.env.CONVEX_BACKEND_VERSION_OVERRIDE
  };
  const data = await (0, import_utils.bigBrainAPI)({
    ctx,
    method: "POST",
    url: "create_project",
    data: provisioningArgs
  });
  const {
    projectSlug,
    teamSlug,
    deploymentName,
    adminKey,
    projectsRemaining,
    prodUrl: url
  } = data;
  if (projectSlug === void 0 || teamSlug === void 0 || deploymentName === void 0 || url === void 0 || adminKey === void 0 || projectsRemaining === void 0) {
    const error = "Unexpected response during provisioning: " + JSON.stringify(data);
    (0, import_context.logError)(ctx, import_chalk.default.red(error));
    return await ctx.crash(1, "transient", error);
  }
  return {
    projectSlug,
    teamSlug,
    deploymentName,
    url,
    adminKey,
    projectsRemaining
  };
}
async function fetchDeploymentCredentialsProvisioningDevOrProd(ctx, { teamSlug, projectSlug }, deploymentType) {
  try {
    return fetchDeploymentCredentialsProvisioningDevOrProdMaybeThrows(
      ctx,
      { teamSlug, projectSlug },
      deploymentType
    );
  } catch (error) {
    return await (0, import_utils.logAndHandleAxiosError)(ctx, error);
  }
}
async function fetchDeploymentCredentialsForName(ctx, deploymentName, deploymentType) {
  let data;
  try {
    data = await (0, import_utils.bigBrainAPIMaybeThrows)({
      ctx,
      method: "POST",
      url: "deployment/authorize_for_name",
      data: {
        deploymentName,
        deploymentType
      }
    });
  } catch (error) {
    return { error };
  }
  const adminKey = data.adminKey;
  const url = data.url;
  if (adminKey === void 0 || url === void 0) {
    const msg = "Unknown error during authorization: " + JSON.stringify(data);
    (0, import_context.logError)(ctx, import_chalk.default.red(msg));
    return await ctx.crash(1, "transient", new Error(msg));
  }
  return { deploymentName, adminKey, url };
}
function readConfiguredAdminKey(adminKey) {
  return adminKey ?? process.env[CONVEX_DEPLOY_KEY_ENV_VAR_NAME] ?? void 0;
}
async function fetchProdDeploymentCredentials(ctx, options) {
  const configuredAdminKey = readConfiguredAdminKey(options.adminKey);
  const configuredUrl = options.url ?? await deriveUrlFromAdminKey(ctx, configuredAdminKey);
  const configuredDeployment = (0, import_deployment.readDeploymentEnvVar)();
  if (configuredAdminKey === void 0) {
    const buildEnvironmentExpectsConvexDeployKey = (0, import_envvars.buildEnvironment)();
    if (buildEnvironmentExpectsConvexDeployKey) {
      (0, import_context.logFailure)(
        ctx,
        `${buildEnvironmentExpectsConvexDeployKey} build environment detected but ${CONVEX_DEPLOY_KEY_ENV_VAR_NAME} is not set. Set this environment variable to deploy from this environment. See https://docs.convex.dev/production/hosting`
      );
      await ctx.crash(1);
    }
    const header = await (0, import_utils.getAuthHeaderFromGlobalConfig)(ctx);
    if (!header) {
      (0, import_context.logFailure)(
        ctx,
        `Error: You are not logged in. Log in with \`npx convex dev\` or set the ${CONVEX_DEPLOY_KEY_ENV_VAR_NAME} environment variable. See https://docs.convex.dev/production/hosting`
      );
      await ctx.crash(1);
    }
  }
  if (configuredAdminKey !== void 0 && configuredUrl !== void 0) {
    return { adminKey: configuredAdminKey, url: configuredUrl };
  }
  if (configuredDeployment === null) {
    (0, import_context.logFailure)(
      ctx,
      "No CONVEX_DEPLOYMENT set, run `npx convex dev` to configure a Convex project"
    );
    return await ctx.crash(1);
  }
  const data = await (0, import_utils.bigBrainAPI)({
    ctx,
    method: "POST",
    url: "deployment/authorize_prod",
    data: {
      deploymentName: configuredDeployment
    }
  });
  const prodDeploymentName = data.deploymentName;
  const adminKey = data.adminKey;
  const url = data.url;
  if (adminKey === void 0 || url === void 0 || prodDeploymentName === void 0) {
    const msg = "Unknown error during authorization: " + JSON.stringify(data);
    (0, import_context.logError)(ctx, import_chalk.default.red(msg));
    return await ctx.crash(1, "transient", new Error(msg));
  }
  return {
    deploymentNames: {
      prod: prodDeploymentName,
      configured: configuredDeployment
    },
    adminKey: configuredAdminKey ?? adminKey,
    url: configuredUrl ?? url
  };
}
async function fetchDeploymentCredentialsProvisionProd(ctx, options) {
  const deploymentType = options.prod ? "prod" : "dev";
  if (deploymentType === "prod") {
    const result2 = await fetchProdDeploymentCredentials(ctx, options);
    return {
      url: result2.url,
      adminKey: result2.adminKey,
      deploymentName: result2.deploymentNames?.prod
    };
  }
  const { url, adminKey } = options;
  if (url !== void 0 && adminKey !== void 0) {
    return { url, adminKey };
  }
  if (!await (0, import_login.checkAuthorization)(ctx, false)) {
    await (0, import_login.performLogin)(ctx);
  }
  const configuredDeployment = await (0, import_utils.getConfiguredDeploymentOrCrash)(ctx);
  const result = await fetchExistingDeploymentCredentialsOrCrash(
    ctx,
    configuredDeployment,
    deploymentType
  );
  return {
    url: result.url,
    adminKey: result.adminKey,
    deploymentName: configuredDeployment
  };
}
async function fetchTeamAndProject(ctx, deploymentName) {
  const data = await (0, import_utils.bigBrainAPI)({
    ctx,
    method: "GET",
    url: `deployment/${deploymentName}/team_and_project`
  });
  const { team, project } = data;
  if (team === void 0 || project === void 0) {
    const msg = "Unknown error when fetching team and project: " + JSON.stringify(data);
    (0, import_context.logFailure)(ctx, msg);
    return await ctx.crash(1, "transient", new Error(msg));
  }
  return data;
}
async function fetchDeploymentCredentialsProvisioningDevOrProdMaybeThrows(ctx, { teamSlug, projectSlug }, deploymentType) {
  const data = await await (0, import_utils.bigBrainAPIMaybeThrows)({
    ctx,
    method: "POST",
    url: "deployment/provision_and_authorize",
    data: {
      teamSlug,
      projectSlug,
      deploymentType
    }
  });
  const deploymentName = data.deploymentName;
  const adminKey = data.adminKey;
  const url = data.url;
  if (adminKey === void 0 || url === void 0) {
    const msg = "Unknown error during authorization: " + JSON.stringify(data);
    (0, import_context.logError)(ctx, import_chalk.default.red(msg));
    return await ctx.crash(1, "transient", new Error(msg));
  }
  return { adminKey, url, deploymentName };
}
async function fetchExistingDeploymentCredentialsOrCrash(ctx, deploymentName, deploymentType) {
  const credentials = await fetchDeploymentCredentialsForName(
    ctx,
    deploymentName,
    deploymentType
  );
  if ("error" in credentials) {
    (0, import_context.logFailure)(
      ctx,
      `Failed to authorize "${deploymentName}" configured in CONVEX_DEPLOYMENT, run \`npx convex dev\` to configure a Convex project`
    );
    return await ctx.crash(1, "invalid filesystem data", credentials.error);
  }
  return credentials;
}
async function deriveUrlFromAdminKey(ctx, adminKey) {
  if (!adminKey) {
    return void 0;
  }
  const deploymentName = await deploymentNameFromAdminKey(ctx, adminKey);
  return `https://${deploymentName}.convex.cloud`;
}
const deploymentNameFromAdminKey = async (ctx, adminKey) => {
  const parts = adminKey.split("|");
  if (parts.length === 1) {
    (0, import_context.logFailure)(
      ctx,
      `Please set ${CONVEX_DEPLOY_KEY_ENV_VAR_NAME} to a new key which you can find on your Convex dashboard.`
    );
    await ctx.crash(1);
  }
  return (0, import_deployment.stripDeploymentTypePrefix)(parts[0]);
};
//# sourceMappingURL=api.js.map
