"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  bigBrainAPI: () => bigBrainAPI,
  bigBrainAPIMaybeThrows: () => bigBrainAPIMaybeThrows,
  bigBrainClient: () => bigBrainClient,
  deploymentClient: () => deploymentClient,
  deprecationCheckWarning: () => deprecationCheckWarning,
  ensureHasConvexDependency: () => ensureHasConvexDependency,
  findParentConfigs: () => findParentConfigs,
  formatDuration: () => formatDuration,
  formatSize: () => formatSize,
  functionsDir: () => functionsDir,
  getAuthHeaderFromGlobalConfig: () => getAuthHeaderFromGlobalConfig,
  getConfiguredDeployment: () => getConfiguredDeployment,
  getConfiguredDeploymentOrCrash: () => getConfiguredDeploymentOrCrash,
  getCurrentTimeString: () => getCurrentTimeString,
  globalConfigPath: () => globalConfigPath,
  hasProject: () => hasProject,
  hasProjects: () => hasProjects,
  hasTeam: () => hasTeam,
  isInExistingProject: () => isInExistingProject,
  loadPackageJson: () => loadPackageJson,
  logAndHandleAxiosError: () => logAndHandleAxiosError,
  poll: () => poll,
  productionProvisionHost: () => productionProvisionHost,
  prompt: () => prompt,
  provisionHost: () => provisionHost,
  rootDirectory: () => rootDirectory,
  sorted: () => sorted,
  spawnAsync: () => spawnAsync,
  validateOrSelectProject: () => validateOrSelectProject,
  validateOrSelectTeam: () => validateOrSelectTeam,
  waitForever: () => waitForever
});
module.exports = __toCommonJS(utils_exports);
var import_axios = __toESM(require("axios"), 1);
var import_chalk = __toESM(require("chalk"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var readline = __toESM(require("readline"), 1);
var import_path = __toESM(require("path"), 1);
var import_os = __toESM(require("os"), 1);
var import_zod = require("zod");
var import_context = require("../../bundler/context.js");
var import_version = require("../version.js");
var import_child_process = require("child_process");
var import_deployment = require("./deployment.js");
var import_axios_retry = __toESM(require("axios-retry"), 1);
const productionProvisionHost = "https://provision.convex.dev";
const provisionHost = process.env.CONVEX_PROVISION_HOST || productionProvisionHost;
const BIG_BRAIN_URL = `${provisionHost}/api`;
function prompt(query) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stderr
  });
  return new Promise(
    (resolve) => rl.question(query, (answer) => {
      rl.close();
      resolve(answer);
    })
  );
}
async function logAndHandleAxiosError(ctx, err) {
  if (ctx.spinner) {
    ctx.spinner.fail();
  }
  let error_type = "transient";
  if (err.response) {
    const res = err.response;
    await checkErrorForDeprecation(ctx, res);
    let msg = `${res.status} ${res.statusText}`;
    if (res.data.code && res.data.message) {
      msg = `${msg}: ${res.data.code}: ${res.data.message}`;
    }
    if (res.status === 400) {
      error_type = "invalid filesystem or env vars";
    } else if (res.status === 401) {
      error_type = "fatal";
      msg = `${msg}
Authenticate with \`npx convex dev\``;
    } else if (res.status === 404) {
      error_type = "fatal";
      msg = `${msg}: ${res.config.url}`;
    }
    (0, import_context.logError)(ctx, import_chalk.default.red(msg.trim()));
  } else {
    (0, import_context.logError)(ctx, import_chalk.default.red(err));
  }
  return await ctx.crash(1, error_type, err);
}
function logDeprecationWarning(ctx, deprecationMessage) {
  if (ctx.deprecationMessagePrinted) {
    return;
  }
  ctx.deprecationMessagePrinted = true;
  (0, import_context.logWarning)(ctx, import_chalk.default.yellow(deprecationMessage));
}
async function checkErrorForDeprecation(ctx, resp) {
  const headers = resp.headers;
  if (headers) {
    const deprecationState = headers["x-convex-deprecation-state"];
    const deprecationMessage = headers["x-convex-deprecation-message"];
    switch (deprecationState) {
      case void 0:
        break;
      case "Deprecated":
        (0, import_context.logError)(ctx, import_chalk.default.red(deprecationMessage));
        return await ctx.crash(1, "fatal");
      default:
        logDeprecationWarning(ctx, deprecationMessage);
        break;
    }
  }
}
function deprecationCheckWarning(ctx, resp) {
  const headers = resp.headers;
  if (headers) {
    const deprecationState = headers["x-convex-deprecation-state"];
    const deprecationMessage = headers["x-convex-deprecation-message"];
    switch (deprecationState) {
      case void 0:
        break;
      case "Deprecated":
        throw new Error(
          "Called deprecationCheckWarning on a fatal error. This is a bug."
        );
      default:
        logDeprecationWarning(ctx, deprecationMessage);
        break;
    }
  }
}
async function hasTeam(ctx, teamSlug) {
  const teams = await bigBrainAPI({ ctx, method: "GET", url: "teams" });
  return teams.some((team) => team.slug === teamSlug);
}
async function validateOrSelectTeam(ctx, teamSlug, promptMessage) {
  const teams = await bigBrainAPI({ ctx, method: "GET", url: "teams" });
  if (teams.length === 0) {
    (0, import_context.logFailure)(ctx, import_chalk.default.red("Error: No teams found"));
    await ctx.crash(1, "fatal", "No teams found");
  }
  if (!teamSlug) {
    switch (teams.length) {
      case 1:
        return { teamSlug: teams[0].slug, chosen: false };
      default:
        return {
          teamSlug: (await import_inquirer.default.prompt([
            {
              name: "teamSlug",
              message: promptMessage,
              type: "list",
              choices: teams.map((team) => ({
                name: `${team.name} (${team.slug})`,
                value: team.slug
              }))
            }
          ])).teamSlug,
          chosen: true
        };
    }
  } else {
    if (!teams.find((team) => team.slug === teamSlug)) {
      (0, import_context.logFailure)(
        ctx,
        `Error: Team ${teamSlug} not found, fix the --team option or remove it`
      );
      await ctx.crash(1, "fatal");
    }
    return { teamSlug, chosen: false };
  }
}
async function hasProject(ctx, teamSlug, projectSlug) {
  try {
    const projects = await bigBrainAPIMaybeThrows({
      ctx,
      method: "GET",
      url: `/teams/${teamSlug}/projects`
    });
    return !!projects.find((project) => project.slug === projectSlug);
  } catch (e) {
    return false;
  }
}
async function hasProjects(ctx) {
  return !!await bigBrainAPI({ ctx, method: "GET", url: `/has_projects` });
}
async function validateOrSelectProject(ctx, projectSlug, teamSlug, singleProjectPrompt, multiProjectPrompt) {
  const projects = await bigBrainAPI({
    ctx,
    method: "GET",
    url: `/teams/${teamSlug}/projects`
  });
  if (projects.length === 0) {
    throw new Error("No projects found");
  }
  if (!projectSlug) {
    const nonDemoProjects = projects.filter((project) => !project.isDemo);
    if (nonDemoProjects.length === 0) {
      throw new Error("No projects found");
    }
    switch (nonDemoProjects.length) {
      case 1: {
        const project = nonDemoProjects[0];
        const confirmed = (await import_inquirer.default.prompt([
          {
            type: "confirm",
            name: "confirmed",
            message: `${singleProjectPrompt} ${project.name} (${project.slug})?`
          }
        ])).confirmed;
        if (!confirmed) {
          return null;
        }
        return nonDemoProjects[0].slug;
      }
      default:
        return (await import_inquirer.default.prompt([
          {
            name: "project",
            message: multiProjectPrompt,
            type: "list",
            choices: nonDemoProjects.map((project) => ({
              name: `${project.name} (${project.slug})`,
              value: project.slug
            }))
          }
        ])).project;
    }
  } else {
    if (!projects.find((project) => project.slug === projectSlug)) {
      (0, import_context.logFailure)(
        ctx,
        `Error: Project ${projectSlug} not found, fix the --project option or remove it`
      );
      await ctx.crash(1, "fatal");
    }
    return projectSlug;
  }
}
async function loadPackageJson(ctx) {
  let packageJson;
  try {
    packageJson = ctx.fs.readUtf8File("package.json");
  } catch (err) {
    (0, import_context.logFailure)(
      ctx,
      `Unable to read your package.json: ${err}. Make sure you're running this command from the root directory of a Convex app that contains the package.json`
    );
    return await ctx.crash(1, "invalid filesystem data");
  }
  let obj;
  try {
    obj = JSON.parse(packageJson);
  } catch (err) {
    (0, import_context.logFailure)(ctx, `Unable to parse package.json: ${err}`);
    return await ctx.crash(1, "invalid filesystem data", err);
  }
  if (typeof obj !== "object") {
    (0, import_context.logError)(ctx, "Expected to parse an object from package.json");
    return await ctx.crash(1, "invalid filesystem data");
  }
  const packages = {
    ...obj.dependencies ?? {},
    ...obj.devDependencies ?? {}
  };
  return packages;
}
async function ensureHasConvexDependency(ctx, cmd) {
  const packages = await loadPackageJson(ctx);
  const hasConvexDependency = "convex" in packages;
  if (!hasConvexDependency) {
    (0, import_context.logFailure)(
      ctx,
      `In order to ${cmd}, add \`convex\` to your package.json dependencies.`
    );
    return await ctx.crash(1, "invalid filesystem data");
  }
}
const sorted = (arr, key) => {
  const newArr = [...arr];
  const cmp = (a, b) => {
    if (key(a) < key(b))
      return -1;
    if (key(a) > key(b))
      return 1;
    return 0;
  };
  return newArr.sort(cmp);
};
function functionsDir(configPath, projectConfig) {
  return import_path.default.join(import_path.default.dirname(configPath), projectConfig.functions);
}
function rootDirectory() {
  let dirName;
  if (process.env.CONVEX_PROVISION_HOST) {
    const port = process.env.CONVEX_PROVISION_HOST.split(":")[2];
    if (port === void 0 || port === "8050") {
      dirName = `.convex-test`;
    } else {
      dirName = `.convex-test-${port}`;
    }
  } else {
    dirName = ".convex";
  }
  return import_path.default.join(import_os.default.homedir(), dirName);
}
function globalConfigPath() {
  return import_path.default.join(rootDirectory(), "config.json");
}
async function readGlobalConfig(ctx) {
  const configPath = globalConfigPath();
  let configFile;
  try {
    configFile = ctx.fs.readUtf8File(configPath);
  } catch (err) {
    return null;
  }
  try {
    const schema = import_zod.z.object({
      accessToken: import_zod.z.string().min(1)
    });
    const config = schema.parse(JSON.parse(configFile));
    return config;
  } catch (err) {
    (0, import_context.logError)(
      ctx,
      import_chalk.default.red(
        `Failed to parse global config in ${configPath} with error ${err}.`
      )
    );
    return null;
  }
}
async function getAuthHeaderFromGlobalConfig(ctx) {
  if (process.env.CONVEX_OVERRIDE_ACCESS_TOKEN) {
    return `Bearer ${process.env.CONVEX_OVERRIDE_ACCESS_TOKEN}`;
  }
  const globalConfig = await readGlobalConfig(ctx);
  if (globalConfig) {
    return `Bearer ${globalConfig.accessToken}`;
  }
  return null;
}
async function bigBrainClient(ctx, getAuthHeader) {
  const authHeader = await getAuthHeader(ctx);
  const headers = authHeader ? {
    Authorization: authHeader,
    "Convex-Client": `npm-cli-${import_version.version}`
  } : {
    "Convex-Client": `npm-cli-${import_version.version}`
  };
  return import_axios.default.create({
    headers,
    baseURL: BIG_BRAIN_URL
  });
}
async function bigBrainAPI({
  ctx,
  method,
  url,
  getAuthHeader,
  data
}) {
  try {
    return await bigBrainAPIMaybeThrows({
      ctx,
      method,
      url,
      getAuthHeader,
      data
    });
  } catch (err) {
    return await logAndHandleAxiosError(ctx, err);
  }
}
async function bigBrainAPIMaybeThrows({
  ctx,
  method,
  url,
  getAuthHeader,
  data
}) {
  const client = await bigBrainClient(
    ctx,
    getAuthHeader ?? getAuthHeaderFromGlobalConfig
  );
  const res = await client.request({ url, method, data });
  deprecationCheckWarning(ctx, res);
  return res.data;
}
const poll = async function(fetch, condition, waitMs = 1e3) {
  let result = await fetch();
  while (!condition(result)) {
    await wait(waitMs);
    result = await fetch();
  }
  return result;
};
const wait = function(waitMs) {
  return new Promise((resolve) => {
    setTimeout(resolve, waitMs);
  });
};
function waitForever() {
  return new Promise((_) => {
  });
}
function formatSize(n) {
  if (n < 1024) {
    return `${n} B`;
  }
  if (n < 1024 * 1024) {
    return `${Math.floor(n / 1024)} KB`;
  }
  if (n < 1024 * 1024 * 1024) {
    return `${Math.floor(n / 1024 / 1024)} MB`;
  }
  return `${n} B`;
}
function formatDuration(ms) {
  const twoDigits = (n, unit) => `${n.toLocaleString("en-US", { maximumFractionDigits: 2 })}${unit}`;
  if (ms < 1e-3) {
    return twoDigits(ms * 1e9, "ns");
  }
  if (ms < 1) {
    return twoDigits(ms * 1e3, "\xB5s");
  }
  if (ms < 1e3) {
    return twoDigits(ms, "ms");
  }
  const s = ms / 1e3;
  if (s < 60) {
    return twoDigits(ms / 1e3, "s");
  }
  return twoDigits(s / 60, "m");
}
function getCurrentTimeString() {
  const now = /* @__PURE__ */ new Date();
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${hours}:${minutes}:${seconds}`;
}
async function findParentConfigs(ctx) {
  const parentPackageJson = findUp(ctx, "package.json");
  if (!parentPackageJson) {
    (0, import_context.logFailure)(
      ctx,
      "No package.json found. To create a new project using Convex, see https://docs.convex.dev/home#quickstarts"
    );
    return await ctx.crash(1, "invalid filesystem data");
  }
  const candidateConvexJson = parentPackageJson && import_path.default.join(import_path.default.dirname(parentPackageJson), "convex.json");
  const parentConvexJson = candidateConvexJson && ctx.fs.exists(candidateConvexJson) ? candidateConvexJson : void 0;
  return {
    parentPackageJson,
    parentConvexJson
  };
}
function findUp(ctx, filename) {
  let curDir = import_path.default.resolve(".");
  let parentDir = curDir;
  do {
    const candidate = import_path.default.join(curDir, filename);
    if (ctx.fs.exists(candidate)) {
      return candidate;
    }
    curDir = parentDir;
    parentDir = import_path.default.dirname(curDir);
  } while (parentDir !== curDir);
  return;
}
async function isInExistingProject(ctx) {
  const { parentPackageJson, parentConvexJson } = await findParentConfigs(ctx);
  if (parentPackageJson !== import_path.default.resolve("package.json")) {
    (0, import_context.logFailure)(ctx, "Run this command from the root directory of a project.");
    return await ctx.crash(1, "invalid filesystem data");
  }
  return !!parentConvexJson;
}
async function getConfiguredDeploymentOrCrash(ctx) {
  const configuredDeployment = await getConfiguredDeployment(ctx);
  if (configuredDeployment !== null) {
    return configuredDeployment;
  }
  (0, import_context.logFailure)(
    ctx,
    "No CONVEX_DEPLOYMENT set, run `npx convex dev` to configure a Convex project"
  );
  return await ctx.crash(1, "invalid filesystem data");
}
async function getConfiguredDeployment(ctx) {
  const { parentPackageJson } = await findParentConfigs(ctx);
  if (parentPackageJson !== import_path.default.resolve("package.json")) {
    (0, import_context.logFailure)(ctx, "Run this command from the root directory of a project.");
    return await ctx.crash(1, "invalid filesystem data");
  }
  return (0, import_deployment.readDeploymentEnvVar)();
}
function spawnAsync(ctx, command, args, options) {
  return new Promise((resolve, reject) => {
    const child = (0, import_child_process.spawn)(command, args);
    let stdout = "";
    let stderr = "";
    const pipeOutput = options?.stdio === "inherit";
    if (pipeOutput) {
      child.stdout.on(
        "data",
        (text) => (0, import_context.logMessage)(ctx, text.toString("utf-8").trimEnd())
      );
      child.stderr.on(
        "data",
        (text) => (0, import_context.logError)(ctx, text.toString("utf-8").trimEnd())
      );
    } else {
      child.stdout.on("data", (data) => {
        stdout += data.toString("utf-8");
      });
      child.stderr.on("data", (data) => {
        stderr += data.toString("utf-8");
      });
    }
    const completionListener = (code) => {
      child.removeListener("error", errorListener);
      const result = pipeOutput ? { status: code } : { stdout, stderr, status: code };
      if (code !== 0) {
        const argumentString = args && args.length > 0 ? ` ${args.join(" ")}` : "";
        const error = new Error(
          `\`${command}${argumentString}\` exited with non-zero code: ${code}`
        );
        if (pipeOutput) {
          reject({ ...result, error });
        } else {
          resolve({ ...result, error });
        }
      } else {
        resolve(result);
      }
    };
    const errorListener = (error) => {
      child.removeListener("exit", completionListener);
      child.removeListener("close", completionListener);
      if (pipeOutput) {
        reject({ error, status: null });
      } else {
        resolve({ error, status: null });
      }
    };
    if (pipeOutput) {
      child.once("exit", completionListener);
    } else {
      child.once("close", completionListener);
    }
    child.once("error", errorListener);
  });
}
function deploymentClient(deploymentURL) {
  const client = import_axios.default.create({
    baseURL: deploymentURL
  });
  (0, import_axios_retry.default)(client, {
    retries: 6,
    retryDelay: import_axios_retry.default.exponentialDelay,
    retryCondition: (error) => {
      return error.response?.status === 404 || false;
    }
  });
  return client;
}
//# sourceMappingURL=utils.js.map
