"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var codegen_exports = {};
__export(codegen_exports, {
  doCodegen: () => doCodegen,
  doInitCodegen: () => doInitCodegen
});
module.exports = __toCommonJS(codegen_exports);
var import_path = __toESM(require("path"), 1);
var import_prettier = __toESM(require("prettier"), 1);
var import_fs = require("../../bundler/fs.js");
var import_bundler = require("../../bundler/index.js");
var import_api = require("../codegen_templates/api.js");
var import_api_cjs = require("../codegen_templates/api_cjs.js");
var import_dataModel = require("../codegen_templates/dataModel.js");
var import_readme = require("../codegen_templates/readme.js");
var import_server = require("../codegen_templates/server.js");
var import_tsconfig = require("../codegen_templates/tsconfig.js");
var import_context = require("../../bundler/context.js");
var import_typecheck = require("./typecheck.js");
var import_config = require("./config.js");
function format(source, filetype) {
  return import_prettier.default.format(source, { parser: filetype, pluginSearchDirs: false });
}
function writeFile(ctx, filename, source, dir, dryRun, debug, quiet, filetype = "typescript") {
  const formattedSource = format(source, filetype);
  const dest = import_path.default.join(dir.tmpPath, filename);
  if (debug) {
    (0, import_context.logOutput)(ctx, `# ${filename}`);
    (0, import_context.logOutput)(ctx, formattedSource);
    return;
  }
  if (dryRun) {
    if (ctx.fs.exists(dest)) {
      const fileText = ctx.fs.readUtf8File(dest);
      if (fileText !== formattedSource) {
        (0, import_context.logOutput)(ctx, `Command would replace file: ${dest}`);
      }
    } else {
      (0, import_context.logOutput)(ctx, `Command would create file: ${dest}`);
    }
    return;
  }
  if (!quiet) {
    (0, import_context.logMessage)(ctx, `writing ${filename}`);
  }
  import_fs.nodeFs.writeUtf8File(dest, formattedSource);
}
async function writeJsWithTypes(ctx, name, content, codegenDir, dryRun, debug, quiet) {
  const [jsName, dtsName] = name.endsWith(".cjs") ? [name, `${name.slice(0, -4)}.d.cts`] : name.endsWith(".mjs") ? [name, `${name.slice(0, -4)}.d.mts`] : name.endsWith(".js") ? [name, `${name.slice(0, -3)}.d.ts`] : [`${name}.js`, `${name}.d.ts`];
  writeFile(ctx, dtsName, content.DTS, codegenDir, dryRun, debug, quiet);
  if (content.JS) {
    writeFile(ctx, jsName, content.JS, codegenDir, dryRun, debug, quiet);
  }
}
async function doServerCodegen(ctx, codegenDir, dryRun, hasSchemaFile, debug, quiet = false) {
  if (hasSchemaFile) {
    await writeJsWithTypes(
      ctx,
      "dataModel",
      import_dataModel.dataModel,
      codegenDir,
      dryRun,
      debug,
      quiet
    );
  } else {
    await writeJsWithTypes(
      ctx,
      "dataModel",
      import_dataModel.dataModelWithoutSchema,
      codegenDir,
      dryRun,
      debug,
      quiet
    );
  }
  await writeJsWithTypes(
    ctx,
    "server",
    (0, import_server.serverCodegen)(),
    codegenDir,
    dryRun,
    debug,
    quiet
  );
}
async function doApiCodegen(ctx, functionsDir, codegenDir, dryRun, debug, quiet = false, commonjs = false) {
  const modulePaths = (await (0, import_bundler.entryPoints)(ctx, functionsDir, false)).map(
    (entryPoint) => import_path.default.relative(functionsDir, entryPoint)
  );
  await writeJsWithTypes(
    ctx,
    "api",
    (0, import_api.apiCodegen)(modulePaths),
    codegenDir,
    dryRun,
    debug,
    quiet
  );
  if (commonjs) {
    await writeJsWithTypes(
      ctx,
      "api_cjs.cjs",
      (0, import_api_cjs.apiCjsCodegen)(modulePaths),
      codegenDir,
      dryRun,
      debug,
      quiet
    );
  }
}
async function doCodegen({
  ctx,
  functionsDirectoryPath,
  typeCheckMode,
  dryRun = false,
  debug = false,
  quiet = false,
  generateCommonJSApi = false
}) {
  const { projectConfig } = await (0, import_config.readProjectConfig)(ctx);
  const legacyCodegenPath = import_path.default.join(functionsDirectoryPath, "_generated.ts");
  if (ctx.fs.exists(legacyCodegenPath)) {
    if (!dryRun) {
      (0, import_context.logError)(ctx, `Deleting legacy codegen file: ${legacyCodegenPath}}`);
      ctx.fs.unlink(legacyCodegenPath);
    } else {
      (0, import_context.logError)(
        ctx,
        `Command would delete legacy codegen file: ${legacyCodegenPath}}`
      );
    }
  }
  ctx.fs.mkdir(functionsDirectoryPath, { allowExisting: true });
  const schemaPath = import_path.default.join(functionsDirectoryPath, "schema.ts");
  const hasSchemaFile = ctx.fs.exists(schemaPath);
  await (0, import_fs.mkdtemp)("_generated", async (tempCodegenDir) => {
    await doServerCodegen(
      ctx,
      tempCodegenDir,
      dryRun,
      hasSchemaFile,
      debug,
      quiet
    );
    await doApiCodegen(
      ctx,
      functionsDirectoryPath,
      tempCodegenDir,
      dryRun,
      debug,
      quiet,
      generateCommonJSApi || projectConfig.generateCommonJSApi
    );
    if (!debug && !dryRun) {
      const codegenDir = import_path.default.join(functionsDirectoryPath, "_generated");
      if (!canSkipSync(ctx, tempCodegenDir, codegenDir)) {
        syncFromTemp(ctx, tempCodegenDir, codegenDir, true);
      }
    }
    await (0, import_typecheck.typeCheckFunctionsInMode)(ctx, typeCheckMode, functionsDirectoryPath);
  });
}
function zipLongest(a, b) {
  return [...Array(Math.max(a.length, b.length)).keys()].map((i) => [
    a[i],
    b[i]
  ]);
}
function canSkipSync(ctx, tempDir, destDir) {
  if (!ctx.fs.exists(destDir))
    return false;
  for (const [tmp, dest] of zipLongest(
    [...(0, import_bundler.walkDir)(ctx.fs, tempDir.tmpPath)],
    [...(0, import_bundler.walkDir)(ctx.fs, destDir)]
  )) {
    if (!tmp || !dest)
      return false;
    const tmpRelPath = import_path.default.relative(tempDir.tmpPath, tmp.path);
    const destRelPath = import_path.default.relative(destDir, dest.path);
    if (tmpRelPath !== destRelPath)
      return false;
    if (tmp.isDir !== dest.isDir)
      return false;
    if (tmp.isDir)
      continue;
    if (ctx.fs.readUtf8File(tmp.path) !== ctx.fs.readUtf8File(dest.path)) {
      return false;
    }
  }
  return true;
}
function syncFromTemp(ctx, tempDir, destDir, eliminateExtras) {
  ctx.fs.mkdir(destDir, { allowExisting: true });
  const added = /* @__PURE__ */ new Set();
  for (const { isDir, path: fpath } of Array.from(
    (0, import_bundler.walkDir)(ctx.fs, tempDir.tmpPath)
  )) {
    const relPath = import_path.default.relative(tempDir.tmpPath, fpath);
    const destPath = import_path.default.join(destDir, relPath);
    if (ctx.fs.exists(destPath)) {
      if (ctx.fs.stat(destPath).isDirectory()) {
        if (!isDir) {
          ctx.fs.rm(destPath, { recursive: true });
        }
      } else {
        ctx.fs.unlink(destPath);
      }
    }
    if (isDir) {
      ctx.fs.mkdir(destPath, { allowExisting: true });
    } else {
      ctx.fs.renameFile(fpath, destPath);
    }
    added.add(destPath);
  }
  if (eliminateExtras) {
    const destEntries = Array.from((0, import_bundler.walkDir)(ctx.fs, destDir)).reverse();
    for (const { isDir, path: fpath } of destEntries) {
      if (!added.has(fpath)) {
        if (isDir) {
          ctx.fs.rmdir(fpath);
        } else {
          ctx.fs.unlink(fpath);
        }
      }
    }
  }
}
async function doInitCodegen({
  ctx,
  functionsDirectoryPath,
  dryRun = false,
  debug = false,
  quiet = false,
  overwrite = false
}) {
  await (0, import_fs.mkdtemp)("convex", async (tempFunctionsDir) => {
    doReadmeCodegen(
      ctx,
      tempFunctionsDir,
      dryRun,
      debug,
      quiet,
      overwrite ? void 0 : functionsDirectoryPath
    );
    doTsconfigCodegen(
      ctx,
      tempFunctionsDir,
      dryRun,
      debug,
      quiet,
      overwrite ? void 0 : functionsDirectoryPath
    );
    syncFromTemp(ctx, tempFunctionsDir, functionsDirectoryPath, false);
  });
}
function doReadmeCodegen(ctx, tempFunctionsDir, dryRun = false, debug = false, quiet = false, dontOverwriteFinalDestination) {
  if (dontOverwriteFinalDestination && ctx.fs.exists(import_path.default.join(dontOverwriteFinalDestination, "README.md"))) {
    (0, import_context.logMessage)(ctx, `not overwriting README.md`);
    return;
  }
  writeFile(
    ctx,
    "README.md",
    (0, import_readme.readmeCodegen)(),
    tempFunctionsDir,
    dryRun,
    debug,
    quiet,
    "markdown"
  );
}
function doTsconfigCodegen(ctx, tempFunctionsDir, dryRun = false, debug = false, quiet = false, dontOverwriteFinalDestination) {
  if (dontOverwriteFinalDestination && ctx.fs.exists(import_path.default.join(dontOverwriteFinalDestination, "tsconfig.json"))) {
    (0, import_context.logMessage)(ctx, `not overwriting tsconfig.json`);
    return;
  }
  writeFile(
    ctx,
    "tsconfig.json",
    (0, import_tsconfig.tsconfigCodegen)(),
    tempFunctionsDir,
    dryRun,
    debug,
    quiet,
    "json"
  );
}
//# sourceMappingURL=codegen.js.map
