"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var deploy_exports = {};
__export(deploy_exports, {
  deploy: () => deploy
});
module.exports = __toCommonJS(deploy_exports);
var import_chalk = __toESM(require("chalk"), 1);
var import_commander = require("commander");
var import_inquirer = __toESM(require("inquirer"), 1);
var import_context = require("../bundler/context.js");
var import_api = require("./lib/api.js");
var import_envvars = require("./lib/envvars.js");
var import_push = require("./lib/push.js");
var import_utils = require("./lib/utils.js");
var import_child_process = require("child_process");
var import_run = require("./lib/run.js");
var import_usage = require("./lib/usage.js");
const deploy = new import_commander.Command("deploy").description("Deploy to a Convex deployment").option("-v, --verbose", "Show full listing of changes").option(
  "--dry-run",
  "Print out the generated configuration without deploying to your Convex deployment"
).option("-y, --yes", "Skip confirmation prompt when running locally").addOption(
  new import_commander.Option(
    "--typecheck <mode>",
    `Whether to check TypeScript files with \`tsc --noEmit\` before deploying.`
  ).choices(["enable", "try", "disable"]).default("try")
).addOption(
  new import_commander.Option(
    "--codegen <mode>",
    "Whether to regenerate code in `convex/_generated/` before pushing."
  ).choices(["enable", "disable"]).default("enable")
).addOption(
  new import_commander.Option(
    "--cmd <command>",
    "Command to run as part of deploying your app (e.g. `vite build`). This command can depend on the environment variables specified in `--cmd-url-env-var-name` being set."
  )
).addOption(
  new import_commander.Option(
    "--cmd-url-env-var-name <name>",
    "Environment variable name to set Convex deployment URL (e.g. `VITE_CONVEX_URL`) when using `--cmd`"
  )
).addOption(
  new import_commander.Option(
    "--preview-run <functionName>",
    "Function to run if deploying to a preview deployment. This is ignored if deploying to a production deployment."
  )
).addOption(
  new import_commander.Option(
    "--preview-name <name>",
    "The name to associate with this deployment if deploying to a preview deployment. Defaults to the current Git branch name in Vercel, Netlify and Github CI. This is ignored if deploying to a production deployment."
  )
).addOption(
  new import_commander.Option(
    "--check-build-environment",
    "Whether to check for a non-production build environment before deploying to a production Convex deployment."
  ).choices(["enable", "disable"]).default("enable").hideHelp()
).addOption(new import_commander.Option("--debug-bundle-path <path>").hideHelp()).addOption(new import_commander.Option("--debug").hideHelp()).addOption(new import_commander.Option("--admin-key <adminKey>").hideHelp()).addOption(new import_commander.Option("--url <url>").hideHelp()).addOption(new import_commander.Option("--log-deployment-name").hideHelp()).showHelpAfterError().action(
  async (cmdOptions) => {
    const ctx = import_context.oneoffContext;
    const configuredDeployKey = (0, import_api.readConfiguredAdminKey)(cmdOptions.adminKey) ?? null;
    if (cmdOptions.checkBuildEnvironment === "enable" && (0, import_envvars.isNonProdBuildEnvironment)() && configuredDeployKey?.startsWith("prod:")) {
      (0, import_context.logError)(
        ctx,
        `Detected a non-production build environment and "${import_api.CONVEX_DEPLOY_KEY_ENV_VAR_NAME}" for a production Convex deployment.

          This is probably unintentional.
          `
      );
      await ctx.crash(1);
    }
    await (0, import_usage.usageStateWarning)(ctx);
    if (configuredDeployKey !== null && configuredDeployKey.startsWith("preview:")) {
      await handlePreview(ctx, { ...cmdOptions, configuredDeployKey });
    } else {
      await handleProduction(ctx, cmdOptions);
    }
  }
);
async function handlePreview(ctx, options) {
  const previewName = options.previewName ?? (0, import_envvars.gitBranchFromEnvironment)();
  if (previewName === null) {
    (0, import_context.logError)(
      ctx,
      "`npx convex deploy` to a preview deployment could not determine the preview name. Provide one using `--preview-name`"
    );
    await ctx.crash(1);
  }
  if (options.dryRun) {
    (0, import_context.logFinishedStep)(
      ctx,
      `Would have claimed preview deployment for "${previewName}"`
    );
    await runCommand(ctx, {
      cmdUrlEnvVarName: options.cmdUrlEnvVarName,
      cmd: options.cmd,
      dryRun: !!options.dryRun,
      url: "https://<PREVIEW DEPLOYMENT>.convex.cloud"
    });
    (0, import_context.logFinishedStep)(
      ctx,
      `Would have deployed Convex functions to preview deployment for "${previewName}"`
    );
    if (options.previewRun !== void 0) {
      (0, import_context.logMessage)(ctx, `Would have run function "${options.previewRun}"`);
    }
    return;
  }
  const data = await (0, import_utils.bigBrainAPI)({
    ctx,
    method: "POST",
    url: "claim_preview_deployment",
    getAuthHeader: () => Promise.resolve(`Bearer ${options.configuredDeployKey}`),
    data: {
      identifier: previewName
    }
  });
  const previewAdminKey = data.adminKey;
  const previewUrl = data.instanceUrl;
  await runCommand(ctx, { ...options, url: previewUrl });
  const pushOptions = {
    adminKey: previewAdminKey,
    verbose: !!options.verbose,
    dryRun: false,
    typecheck: options.typecheck,
    debug: !!options.debug,
    debugBundlePath: options.debugBundlePath,
    codegen: options.codegen === "enable",
    url: previewUrl
  };
  (0, import_context.showSpinner)(ctx, `Deploying to ${previewUrl}...`);
  await (0, import_push.runPush)(import_context.oneoffContext, pushOptions);
  (0, import_context.logFinishedStep)(ctx, `Deployed Convex functions to ${previewUrl}`);
  if (options.previewRun !== void 0) {
    await (0, import_run.runFunctionAndLog)(
      ctx,
      previewUrl,
      previewAdminKey,
      options.previewRun,
      {},
      {
        onSuccess: () => {
          (0, import_context.logFinishedStep)(
            ctx,
            `Finished running function "${options.previewRun}"`
          );
        }
      }
    );
  }
  if (options.logDeploymentName) {
    const deploymentName = await (0, import_api.deploymentNameFromAdminKey)(
      ctx,
      previewAdminKey
    );
    (0, import_context.logOutput)(ctx, deploymentName);
  }
}
async function handleProduction(ctx, options) {
  const { adminKey, url, deploymentNames } = await (0, import_api.fetchProdDeploymentCredentials)(ctx, options);
  if (deploymentNames !== void 0) {
    const shouldPushToProd = deploymentNames.prod === deploymentNames.configured || (options.yes ?? await askToConfirmPush(ctx, deploymentNames, url));
    if (!shouldPushToProd) {
      await ctx.crash(1);
    }
  }
  await runCommand(ctx, { ...options, url });
  const pushOptions = {
    adminKey,
    verbose: !!options.verbose,
    dryRun: !!options.dryRun,
    typecheck: options.typecheck,
    debug: !!options.debug,
    debugBundlePath: options.debugBundlePath,
    codegen: options.codegen === "enable",
    url
  };
  (0, import_context.showSpinner)(
    ctx,
    `Deploying to ${url}...${options.dryRun ? " [dry run]" : ""}`
  );
  await (0, import_push.runPush)(import_context.oneoffContext, pushOptions);
  (0, import_context.logFinishedStep)(
    ctx,
    `${options.dryRun ? "Would have deployed" : "Deployed"} Convex functions to ${url}`
  );
  if (options.logDeploymentName) {
    const deploymentName = await (0, import_api.deploymentNameFromAdminKey)(ctx, adminKey);
    (0, import_context.logOutput)(ctx, deploymentName);
  }
}
async function runCommand(ctx, options) {
  if (options.cmd === void 0) {
    return;
  }
  const urlVar = options.cmdUrlEnvVarName ?? (await (0, import_envvars.suggestedEnvVarName)(ctx)).envVar;
  (0, import_context.showSpinner)(
    ctx,
    `Running '${options.cmd}' with environment variable "${urlVar}" set...${options.dryRun ? " [dry run]" : ""}`
  );
  if (!options.dryRun) {
    const env = { ...process.env };
    env[urlVar] = options.url;
    const result = (0, import_child_process.spawnSync)(options.cmd, {
      env,
      stdio: "inherit",
      shell: true
    });
    if (result.status !== 0) {
      (0, import_context.logFailure)(ctx, `'${options.cmd}' failed`);
      await ctx.crash(1);
    }
  }
  (0, import_context.logFinishedStep)(
    ctx,
    `${options.dryRun ? "Would have run" : "Ran"} "${options.cmd}" with environment variable "${urlVar}" set`
  );
}
async function askToConfirmPush(ctx, deploymentNames, prodUrl) {
  (0, import_context.logMessage)(
    ctx,
    `You're currently developing against your ${import_chalk.default.bold("dev")} deployment

  ${deploymentNames.configured} (set in CONVEX_DEPLOYMENT)

Your ${import_chalk.default.bold("prod")} deployment ${import_chalk.default.bold(
      deploymentNames.prod
    )} serves traffic at:

  ${(await (0, import_envvars.suggestedEnvVarName)(ctx)).envVar}=${import_chalk.default.bold(prodUrl)}

Make sure that your published client is configured with this URL (for instructions see https://docs.convex.dev/hosting)
`
  );
  return (await import_inquirer.default.prompt([
    {
      type: "confirm",
      name: "shouldPush",
      message: `Do you want to push your code to your prod deployment ${deploymentNames.prod} now?`,
      default: true
    }
  ])).shouldPush;
}
//# sourceMappingURL=deploy.js.map
