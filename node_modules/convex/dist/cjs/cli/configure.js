"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var configure_exports = {};
__export(configure_exports, {
  deploymentCredentialsOrConfigure: () => deploymentCredentialsOrConfigure,
  initOrReinitForDeprecatedCommands: () => initOrReinitForDeprecatedCommands,
  promptToInitWithProjects: () => promptToInitWithProjects,
  promptToReconfigure: () => promptToReconfigure
});
module.exports = __toCommonJS(configure_exports);
var import_chalk = __toESM(require("chalk"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var import_context = require("../bundler/context.js");
var import_api = require("./lib/api.js");
var import_config = require("./lib/config.js");
var import_deployment = require("./lib/deployment.js");
var import_init = require("./lib/init.js");
var import_reinit = require("./lib/reinit.js");
var import_utils = require("./lib/utils.js");
var import_envvars = require("./lib/envvars.js");
async function initOrReinitForDeprecatedCommands(ctx, cmdOptions) {
  const { url } = await deploymentCredentialsOrConfigure(ctx, null, {
    ...cmdOptions,
    prod: false
  });
  const envVarWrite = await (0, import_envvars.writeConvexUrlToEnvFile)(ctx, url);
  if (envVarWrite !== null) {
    (0, import_context.logMessage)(
      ctx,
      import_chalk.default.green(
        `Saved the dev deployment URL as ${envVarWrite.envVar} to ${envVarWrite.envFile}`
      )
    );
  }
}
async function deploymentCredentialsOrConfigure(ctx, chosenConfiguration, cmdOptions) {
  const { url, adminKey } = cmdOptions;
  if (url !== void 0 && adminKey !== void 0) {
    const didErase = await (0, import_deployment.eraseDeploymentEnvVar)(ctx);
    if (didErase) {
      (0, import_context.logMessage)(
        ctx,
        import_chalk.default.yellowBright(
          `Removed the CONVEX_DEPLOYMENT environment variable from .env.local`
        )
      );
    }
    const envVarWrite = await (0, import_envvars.writeConvexUrlToEnvFile)(ctx, url);
    if (envVarWrite !== null) {
      (0, import_context.logMessage)(
        ctx,
        import_chalk.default.green(
          `Saved the given --url as ${envVarWrite.envVar} to ${envVarWrite.envFile}`
        )
      );
    }
    return { url, adminKey };
  }
  const deploymentType = cmdOptions.prod ? "prod" : "dev";
  const configuredDeployment = chosenConfiguration === null ? await getConfiguredDeploymentOrUpgrade(ctx, deploymentType) : null;
  if (configuredDeployment === null) {
    const choice2 = chosenConfiguration !== "ask" && chosenConfiguration !== null ? chosenConfiguration : await askToConfigure(ctx);
    return await initOrReinit(ctx, choice2, deploymentType, cmdOptions);
  }
  if ("error" in configuredDeployment) {
    const projectConfig = (await (0, import_config.readProjectConfig)(ctx)).projectConfig;
    const choice2 = await askToReconfigure(
      ctx,
      projectConfig,
      configuredDeployment.error
    );
    return initOrReinit(ctx, choice2, deploymentType, cmdOptions);
  }
  const { deploymentName } = configuredDeployment;
  const adminKeyAndUrlForConfiguredDeployment = await (0, import_api.fetchDeploymentCredentialsForName)(
    ctx,
    deploymentName,
    deploymentType
  );
  if (!("error" in adminKeyAndUrlForConfiguredDeployment)) {
    return adminKeyAndUrlForConfiguredDeployment;
  }
  await checkForDeploymentTypeError(
    ctx,
    adminKeyAndUrlForConfiguredDeployment.error,
    deploymentType
  );
  const choice = await askToReconfigureNew(ctx, deploymentName);
  return initOrReinit(ctx, choice, deploymentType, cmdOptions);
}
async function checkForDeploymentTypeError(ctx, error, deploymentType) {
  if (error.response?.data?.code === "DeploymentTypeMismatch") {
    if (deploymentType === "prod") {
      (0, import_context.logFailure)(
        ctx,
        "Use `npx convex deploy` to push changes to your production deployment"
      );
    } else {
      (0, import_context.logFailure)(
        ctx,
        "CONVEX_DEPLOYMENT is a production deployment, but --prod flag was not specified. Use `npx convex dev --prod` to develop against this production deployment."
      );
    }
    (0, import_context.logError)(ctx, import_chalk.default.red(error.response.data.message));
    await ctx.crash(1, "invalid filesystem data", error);
  }
}
async function getConfiguredDeploymentOrUpgrade(ctx, deploymentType) {
  const deploymentName = await (0, import_utils.getConfiguredDeployment)(ctx);
  if (deploymentName !== null) {
    return { deploymentName };
  }
  return await upgradeOldConfigToDeploymentVar(ctx, deploymentType);
}
async function initOrReinit(ctx, choice, deploymentType, cmdOptions) {
  switch (choice) {
    case "new":
      return await (0, import_init.init)(ctx, deploymentType, cmdOptions);
    case "existing": {
      return await (0, import_reinit.reinit)(ctx, deploymentType, cmdOptions);
    }
    default: {
      return choice;
    }
  }
}
async function upgradeOldConfigToDeploymentVar(ctx, deploymentType) {
  const { configPath, projectConfig } = await (0, import_config.readProjectConfig)(ctx);
  const { team, project } = projectConfig;
  if (typeof team !== "string" || typeof project !== "string") {
    return null;
  }
  let devDeploymentName;
  try {
    const { deploymentName } = await (0, import_api.fetchDeploymentCredentialsProvisioningDevOrProdMaybeThrows)(
      ctx,
      { teamSlug: team, projectSlug: project },
      deploymentType
    );
    devDeploymentName = deploymentName;
  } catch (error) {
    return { error };
  }
  await (0, import_deployment.writeDeploymentEnvVar)(ctx, deploymentType, {
    team,
    project,
    deploymentName: devDeploymentName
  });
  (0, import_context.logMessage)(
    ctx,
    import_chalk.default.green(
      `Saved the ${deploymentType} deployment name as CONVEX_DEPLOYMENT to .env.local`
    )
  );
  const projectConfigWithoutAuthInfo = await (0, import_config.upgradeOldAuthInfoToAuthConfig)(
    ctx,
    projectConfig,
    (0, import_utils.functionsDir)(configPath, projectConfig)
  );
  await (0, import_config.writeProjectConfig)(ctx, projectConfigWithoutAuthInfo, {
    deleteIfAllDefault: true
  });
  return { deploymentName: devDeploymentName };
}
async function askToConfigure(ctx) {
  if (!await (0, import_utils.hasProjects)(ctx)) {
    return "new";
  }
  return await promptToInitWithProjects();
}
async function askToReconfigure(ctx, projectConfig, error) {
  const team = await (0, import_config.enforceDeprecatedConfigField)(ctx, projectConfig, "team");
  const project = await (0, import_config.enforceDeprecatedConfigField)(
    ctx,
    projectConfig,
    "project"
  );
  const [isExistingTeam, existingProject, hasAnyProjects] = await Promise.all([
    await (0, import_utils.hasTeam)(ctx, team),
    await (0, import_utils.hasProject)(ctx, team, project),
    await (0, import_utils.hasProjects)(ctx)
  ]);
  if (isExistingTeam && existingProject) {
    return await (0, import_utils.logAndHandleAxiosError)(ctx, error);
  }
  if (isExistingTeam) {
    (0, import_context.logFailure)(
      ctx,
      `Project ${import_chalk.default.bold(project)} does not exist in your team ${import_chalk.default.bold(
        team
      )}, as configured in ${import_chalk.default.bold("convex.json")}`
    );
  } else {
    (0, import_context.logFailure)(
      ctx,
      `You don't have access to team ${import_chalk.default.bold(
        team
      )}, as configured in ${import_chalk.default.bold("convex.json")}`
    );
  }
  if (!hasAnyProjects) {
    const { confirmed } = await import_inquirer.default.prompt([
      {
        type: "confirm",
        name: "confirmed",
        message: `Create a new project?`,
        default: true
      }
    ]);
    if (!confirmed) {
      (0, import_context.logFailure)(
        ctx,
        "Run `npx convex dev` in a directory with a valid convex.json."
      );
      return await ctx.crash(1, "invalid filesystem data");
    }
    return "new";
  }
  return await promptToReconfigure();
}
async function askToReconfigureNew(ctx, configuredDeploymentName) {
  (0, import_context.logFailure)(
    ctx,
    `You don't have access to the project with deployment ${import_chalk.default.bold(
      configuredDeploymentName
    )}, as configured in ${import_chalk.default.bold("CONVEX_DEPLOYMENT")}`
  );
  const hasAnyProjects = await (0, import_utils.hasProjects)(ctx);
  if (!hasAnyProjects) {
    const { confirmed } = await import_inquirer.default.prompt([
      {
        type: "confirm",
        name: "confirmed",
        message: `Configure a new project?`,
        default: true
      }
    ]);
    if (!confirmed) {
      (0, import_context.logFailure)(
        ctx,
        "Run `npx convex dev` in a directory with a valid CONVEX_DEPLOYMENT set"
      );
      return await ctx.crash(1, "invalid filesystem data");
    }
    return "new";
  }
  return await promptToReconfigure();
}
async function promptToInitWithProjects() {
  const { choice } = await import_inquirer.default.prompt([
    {
      type: "list",
      name: "choice",
      message: `What would you like to configure?`,
      default: "new",
      choices: [
        { name: "a new project", value: "new" },
        { name: "an existing project", value: "existing" }
      ]
    }
  ]);
  return choice;
}
async function promptToReconfigure() {
  const { choice } = await import_inquirer.default.prompt([
    {
      type: "list",
      name: "choice",
      message: `Configure a different project?`,
      default: "new",
      choices: [
        { name: "create new project", value: "new" },
        { name: "choose an existing project", value: "existing" }
      ]
    }
  ]);
  return choice;
}
//# sourceMappingURL=configure.js.map
