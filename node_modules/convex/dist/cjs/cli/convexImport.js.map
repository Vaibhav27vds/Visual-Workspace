{
  "version": 3,
  "sources": ["../../../src/cli/convexImport.ts"],
  "sourcesContent": ["import { Command, Option } from \"commander\";\nimport chalk from \"chalk\";\nimport {\n  ensureHasConvexDependency,\n  logAndHandleAxiosError,\n  formatSize,\n  deploymentClient,\n} from \"./lib/utils.js\";\nimport { AxiosResponse } from \"axios\";\nimport { version } from \"./version.js\";\nimport {\n  logFailure,\n  oneoffContext,\n  Context,\n  showSpinner,\n  logFinishedStep,\n  logWarning,\n} from \"../bundler/context.js\";\nimport { fetchDeploymentCredentialsProvisionProd } from \"./lib/api.js\";\nimport path from \"path\";\n\nexport const convexImport = new Command(\"import\")\n  .description(\n    \"Import data from a file\\n\\n\" +\n      \"  From a snapshot: `npx convex import snapshot.zip`\\n\" +\n      \"  For a single table: `npx convex --table tableName file.json`\\n\"\n  )\n  .addOption(\n    new Option(\n      \"--table <table>\",\n      \"Destination table name. Required if format is csv, jsonLines, or jsonArray. Not supported if format is zip.\"\n    )\n  )\n  .addOption(\n    new Option(\n      \"--format <format>\",\n      \"Input file format. This flag is only required if the filename is missing an extension.\\n\" +\n        \"CSV files must have a header, and each row's entries are interpreted either as a (floating point) number or a string.\\n\" +\n        \"JSON files must be an array of JSON objects.\\n\" +\n        \"JSONLines files must have a JSON object per line.\\n\" +\n        \"ZIP files must have one directory per table, containing <table>/documents.jsonl. Snapshot exports from the Convex dashboard have this format.\"\n    ).choices([\"csv\", \"jsonLines\", \"jsonArray\", \"zip\"])\n  )\n  .option(\n    \"--prod\",\n    \"Import data into this project's production deployment. Defaults to your dev deployment without this flag.\"\n  )\n  .addOption(\n    new Option(\n      \"--replace\",\n      \"Replace all existing data in any of the imported tables\"\n    ).conflicts(\"--append\")\n  )\n  .addOption(\n    new Option(\n      \"--append\",\n      \"Append imported data to any existing tables\"\n    ).conflicts(\"--replace\")\n  )\n  .addOption(new Option(\"--url <url>\").hideHelp())\n  .addOption(new Option(\"--admin-key <adminKey>\").hideHelp())\n  .argument(\"<path>\", \"Path to the input file\")\n  .showHelpAfterError()\n  .action(async (filePath: string, options: any, command: any) => {\n    const ctx = oneoffContext;\n\n    if (command.args.length > 1) {\n      logFailure(\n        ctx,\n        `Error: Too many positional arguments. If you're specifying a table name, use the \\`--table\\` option.`\n      );\n      return await ctx.crash(1, \"fatal\");\n    }\n\n    const { adminKey, url: deploymentUrl } =\n      await fetchDeploymentCredentialsProvisionProd(ctx, options);\n\n    if (!ctx.fs.exists(filePath)) {\n      logFailure(ctx, `Error: Path ${chalk.bold(filePath)} does not exist.`);\n      return await ctx.crash(1, \"invalid filesystem data\");\n    }\n\n    const format = await determineFormat(ctx, filePath, options.format ?? null);\n    const tableName = options.table ?? null;\n    if (tableName === null) {\n      if (format !== \"zip\") {\n        logFailure(\n          ctx,\n          `Error: The \\`--table\\` option is required for format ${format}`\n        );\n        return await ctx.crash(1, \"fatal\");\n      }\n    } else {\n      if (format === \"zip\") {\n        logFailure(\n          ctx,\n          `Error: The \\`--table\\` option is not allowed for format ${format}`\n        );\n        return await ctx.crash(1, \"fatal\");\n      }\n    }\n\n    await ensureHasConvexDependency(ctx, \"import\");\n\n    const data = ctx.fs.createReadStream(filePath);\n    const fileStats = ctx.fs.stat(filePath);\n\n    showSpinner(ctx, `Importing ${filePath} (${formatSize(fileStats.size)})`);\n\n    const urlName =\n      tableName === null ? \"\" : `&tableName=${encodeURIComponent(tableName)}`;\n    const urlFormat = encodeURIComponent(format);\n    const client = deploymentClient(deploymentUrl);\n    let resp: AxiosResponse;\n    let mode = \"requireEmpty\";\n    if (options.append) {\n      mode = \"append\";\n    } else if (options.replace) {\n      mode = \"replace\";\n    }\n    const deploymentNotice = options.prod\n      ? ` in your ${chalk.bold(\"prod\")} deployment`\n      : \"\";\n    const tableNotice = tableName ? ` to table \"${chalk.bold(tableName)}\"` : \"\";\n    try {\n      const url = `/api/import?format=${urlFormat}&mode=${mode}${urlName}`;\n      resp = await client.post(url, data, {\n        headers: {\n          Authorization: `Convex ${adminKey}`,\n          \"Content-Type\": \"text/plain\",\n          \"Convex-Client\": `npm-cli-${version}`,\n        },\n      });\n    } catch (e) {\n      logFailure(\n        ctx,\n        `Importing data from \"${chalk.bold(\n          filePath\n        )}\"${tableNotice}${deploymentNotice} failed`\n      );\n      return await logAndHandleAxiosError(ctx, e);\n    }\n    logFinishedStep(\n      ctx,\n      `Added ${resp.data.numWritten} documents${tableNotice}${deploymentNotice}.`\n    );\n  });\n\nasync function determineFormat(\n  ctx: Context,\n  filePath: string,\n  format: string | null\n) {\n  const fileExtension = path.extname(filePath);\n  if (fileExtension !== \"\") {\n    const formatToExtension: Record<string, string> = {\n      csv: \".csv\",\n      jsonLines: \".jsonl\",\n      jsonArray: \".json\",\n      zip: \".zip\",\n    };\n    const extensionToFormat = Object.fromEntries(\n      Object.entries(formatToExtension).map((a) => a.reverse())\n    );\n    if (format !== null && fileExtension !== formatToExtension[format]) {\n      logWarning(\n        ctx,\n        chalk.yellow(\n          `Warning: Extension of file ${filePath} (${fileExtension}) does not match specified format: ${format} (${formatToExtension[format]}).`\n        )\n      );\n    }\n    format ??= extensionToFormat[fileExtension] ?? null;\n  }\n  if (format === null) {\n    logFailure(\n      ctx,\n      \"No input file format inferred by the filename extension or specified. Specify your input file's format using the `--format` flag.\"\n    );\n    return await ctx.crash(1, \"fatal\");\n  }\n  return format;\n}\n"],
  "mappings": "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",
  "names": ["chalk", "path"]
}
