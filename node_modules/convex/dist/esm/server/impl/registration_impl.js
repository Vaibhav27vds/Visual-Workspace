"use strict";
import {
  convexToJson,
  jsonToConvex,
  v
} from "../../values/index.js";
import { setupActionCalls } from "./actions_impl.js";
import { setupActionVectorSearch } from "./vector_search_impl.js";
import { setupAuth } from "./authentication_impl.js";
import { setupReader, setupWriter } from "./database_impl.js";
import { QueryImpl, QueryInitializerImpl } from "./query_impl.js";
import {
  setupActionScheduler,
  setupMutationScheduler
} from "./scheduler_impl.js";
import {
  setupStorageActionWriter,
  setupStorageReader,
  setupStorageWriter
} from "./storage_impl.js";
async function invokeMutation(func, argsStr) {
  const requestId = "";
  const args = jsonToConvex(JSON.parse(argsStr), false);
  const mutationCtx = {
    db: setupWriter(),
    auth: setupAuth(requestId),
    storage: setupStorageWriter(requestId),
    scheduler: setupMutationScheduler()
  };
  const result = await invokeFunction(func, mutationCtx, args);
  validateReturnValue(result);
  return JSON.stringify(convexToJson(result === void 0 ? null : result));
}
function validateReturnValue(v2) {
  if (v2 instanceof QueryInitializerImpl || v2 instanceof QueryImpl) {
    throw new Error(
      "Return value is a Query. Results must be retrieved with `.collect()`, `.take(n), `.unique()`, or `.first()`."
    );
  }
}
async function invokeFunction(func, ctx, args) {
  let result;
  try {
    result = await Promise.resolve(func(ctx, ...args));
  } catch (thrown) {
    throw serializeConvexErrorData(thrown);
  }
  return result;
}
function serializeConvexErrorData(thrown) {
  if (typeof thrown === "object" && thrown !== null && Symbol.for("ConvexError") in thrown) {
    const error = thrown;
    error.data = JSON.stringify(
      convexToJson(error.data === void 0 ? null : error.data)
    );
    error.ConvexErrorSymbol = Symbol.for("ConvexError");
    return error;
  } else {
    return thrown;
  }
}
function assertNotBrowser() {
  if (typeof window === "undefined" || !window.__convexAllowFunctionsInBrowser) {
    return;
  }
  const isRealBrowser = Object.getOwnPropertyDescriptor(globalThis, "window")?.get?.toString().includes("[native code]") ?? false;
  if (isRealBrowser) {
    throw new Error("Convex functions should not be imported in the browser.");
  }
}
function exportArgs(functionDefinition) {
  return () => {
    let args = v.any();
    if (typeof functionDefinition === "object" && functionDefinition.args !== void 0) {
      args = v.object(functionDefinition.args);
    }
    return JSON.stringify(args.json);
  };
}
export const mutationGeneric = (functionDefinition) => {
  const func = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
  if (func.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  assertNotBrowser();
  func.isRegistered = true;
  func.isMutation = true;
  func.isPublic = true;
  func.invokeMutation = (argsStr) => invokeMutation(func, argsStr);
  func.exportArgs = exportArgs(functionDefinition);
  return func;
};
export const internalMutationGeneric = (functionDefinition) => {
  const func = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
  if (func.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  assertNotBrowser();
  func.isRegistered = true;
  func.isMutation = true;
  func.isInternal = true;
  func.invokeMutation = (argsStr) => invokeMutation(func, argsStr);
  func.exportArgs = exportArgs(functionDefinition);
  return func;
};
async function invokeQuery(func, argsStr, allowMapsAndSetsInReturnValue) {
  const requestId = "";
  const args = jsonToConvex(JSON.parse(argsStr), false);
  const queryCtx = {
    db: setupReader(),
    auth: setupAuth(requestId),
    storage: setupStorageReader(requestId)
  };
  const result = await invokeFunction(func, queryCtx, args);
  validateReturnValue(result);
  return JSON.stringify(
    convexToJson(
      result === void 0 ? null : result,
      allowMapsAndSetsInReturnValue
    )
  );
}
export const queryGeneric = (functionDefinition) => {
  const func = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
  if (func.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  assertNotBrowser();
  func.isRegistered = true;
  func.isQuery = true;
  func.isPublic = true;
  func.invokeQuery = (argsStr, allowMapsAndSetsInReturnValue) => invokeQuery(func, argsStr, allowMapsAndSetsInReturnValue);
  func.exportArgs = exportArgs(functionDefinition);
  return func;
};
export const internalQueryGeneric = (functionDefinition) => {
  const func = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
  if (func.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  assertNotBrowser();
  func.isRegistered = true;
  func.isQuery = true;
  func.isInternal = true;
  func.invokeQuery = (argsStr) => invokeQuery(func, argsStr, false);
  func.exportArgs = exportArgs(functionDefinition);
  return func;
};
async function invokeAction(func, requestId, argsStr) {
  const args = jsonToConvex(JSON.parse(argsStr), false);
  const calls = setupActionCalls(requestId);
  const ctx = {
    ...calls,
    auth: setupAuth(requestId),
    scheduler: setupActionScheduler(requestId),
    storage: setupStorageActionWriter(requestId),
    vectorSearch: setupActionVectorSearch(requestId)
  };
  const result = await invokeFunction(func, ctx, args);
  return JSON.stringify(convexToJson(result === void 0 ? null : result));
}
export const actionGeneric = (functionDefinition) => {
  const func = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
  if (func.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  assertNotBrowser();
  func.isRegistered = true;
  func.isAction = true;
  func.isPublic = true;
  func.invokeAction = (requestId, argsStr) => invokeAction(func, requestId, argsStr);
  func.exportArgs = exportArgs(functionDefinition);
  return func;
};
export const internalActionGeneric = (functionDefinition) => {
  const func = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
  if (func.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  assertNotBrowser();
  func.isRegistered = true;
  func.isAction = true;
  func.isInternal = true;
  func.invokeAction = (requestId, argsStr) => invokeAction(func, requestId, argsStr);
  func.exportArgs = exportArgs(functionDefinition);
  return func;
};
async function invokeHttpAction(func, request) {
  const requestId = "";
  const calls = setupActionCalls(requestId);
  const ctx = {
    ...calls,
    auth: setupAuth(requestId),
    storage: setupStorageActionWriter(requestId),
    scheduler: setupActionScheduler(requestId),
    vectorSearch: setupActionVectorSearch(requestId)
  };
  return await invokeFunction(func, ctx, [request]);
}
export const httpActionGeneric = (func) => {
  const q = func;
  if (q.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  assertNotBrowser();
  q.isRegistered = true;
  q.isHttp = true;
  q.invokeHttpAction = (request) => invokeHttpAction(func, request);
  return q;
};
//# sourceMappingURL=registration_impl.js.map
