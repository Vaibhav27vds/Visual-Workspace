{
  "version": 3,
  "sources": ["../../../../src/server/impl/registration_impl.ts"],
  "sourcesContent": ["import {\n  ConvexError,\n  convexToJson,\n  jsonToConvex,\n  v,\n  Validator,\n} from \"../../values/index.js\";\nimport { GenericDataModel } from \"../data_model.js\";\nimport {\n  ActionCtx,\n  MutationCtx,\n  RegisteredAction,\n  PublicHttpAction,\n  RegisteredMutation,\n  RegisteredQuery,\n  QueryCtx,\n  DefaultFunctionArgs,\n  MutationBuilder,\n  QueryBuilder,\n  ActionBuilder,\n} from \"../registration.js\";\nimport { setupActionCalls } from \"./actions_impl.js\";\nimport { setupActionVectorSearch } from \"./vector_search_impl.js\";\nimport { setupAuth } from \"./authentication_impl.js\";\nimport { setupReader, setupWriter } from \"./database_impl.js\";\nimport { QueryImpl, QueryInitializerImpl } from \"./query_impl.js\";\nimport {\n  setupActionScheduler,\n  setupMutationScheduler,\n} from \"./scheduler_impl.js\";\nimport {\n  setupStorageActionWriter,\n  setupStorageReader,\n  setupStorageWriter,\n} from \"./storage_impl.js\";\n\nasync function invokeMutation<\n  F extends (ctx: MutationCtx<GenericDataModel>, ...args: any) => any\n>(func: F, argsStr: string) {\n  // TODO(presley): Change the function signature and propagate the requestId from Rust.\n  // Ok, to mock it out for now, since queries are only running in V8.\n  const requestId = \"\";\n  const args = jsonToConvex(JSON.parse(argsStr), false);\n  const mutationCtx = {\n    db: setupWriter(),\n    auth: setupAuth(requestId),\n    storage: setupStorageWriter(requestId),\n    scheduler: setupMutationScheduler(),\n  };\n  const result = await invokeFunction(func, mutationCtx, args as any);\n  validateReturnValue(result);\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\nfunction validateReturnValue(v: any) {\n  if (v instanceof QueryInitializerImpl || v instanceof QueryImpl) {\n    throw new Error(\n      \"Return value is a Query. Results must be retrieved with `.collect()`, `.take(n), `.unique()`, or `.first()`.\"\n    );\n  }\n}\n\nasync function invokeFunction<\n  Ctx,\n  Args extends any[],\n  F extends (ctx: Ctx, ...args: Args) => any\n>(func: F, ctx: Ctx, args: Args) {\n  let result;\n  try {\n    result = await Promise.resolve(func(ctx, ...args));\n  } catch (thrown: unknown) {\n    throw serializeConvexErrorData(thrown);\n  }\n  return result;\n}\n\n// Keep in sync with node executor\nfunction serializeConvexErrorData(thrown: unknown) {\n  if (\n    typeof thrown === \"object\" &&\n    thrown !== null &&\n    Symbol.for(\"ConvexError\") in thrown\n  ) {\n    const error = thrown as ConvexError<any>;\n    error.data = JSON.stringify(\n      convexToJson(error.data === undefined ? null : error.data)\n    );\n    (error as any).ConvexErrorSymbol = Symbol.for(\"ConvexError\");\n    return error;\n  } else {\n    return thrown;\n  }\n}\n\n/**\n * Guard against Convex functions accidentally getting included in a browser bundle.\n * Convex functions may include secret logic or credentials that should not be\n * send to untrusted clients (browsers).\n */\nfunction assertNotBrowser() {\n  if (\n    typeof window === \"undefined\" ||\n    !(window as any).__convexAllowFunctionsInBrowser\n  ) {\n    return;\n  }\n  // JSDom doesn't count, developers are allowed to use JSDom in Convex functions.\n  const isRealBrowser =\n    Object.getOwnPropertyDescriptor(globalThis, \"window\")\n      ?.get?.toString()\n      .includes(\"[native code]\") ?? false;\n  if (isRealBrowser) {\n    throw new Error(\"Convex functions should not be imported in the browser.\");\n  }\n}\n\ntype FunctionDefinition =\n  | ((ctx: any, args: DefaultFunctionArgs) => any)\n  | {\n      args?: Record<string, Validator<any, boolean>>;\n      handler: (ctx: any, args: DefaultFunctionArgs) => any;\n    };\n\nfunction exportArgs(functionDefinition: FunctionDefinition) {\n  return () => {\n    let args = v.any();\n    if (\n      typeof functionDefinition === \"object\" &&\n      functionDefinition.args !== undefined\n    ) {\n      args = v.object(functionDefinition.args);\n    }\n    return JSON.stringify(args.json);\n  };\n}\n/**\n * Define a mutation in this Convex app's public API.\n *\n * This function will be allowed to modify your Convex database and will be accessible from the client.\n *\n * If you're using code generation, use the `mutation` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.\n * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const mutationGeneric: MutationBuilder<any, \"public\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredMutation<\"public\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  assertNotBrowser();\n  func.isRegistered = true;\n  func.isMutation = true;\n  func.isPublic = true;\n  func.invokeMutation = (argsStr) => invokeMutation(func, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\n/**\n * Define a mutation that is only accessible from other Convex functions (but not from the client).\n *\n * This function will be allowed to modify your Convex database. It will not be accessible from the client.\n *\n * If you're using code generation, use the `internalMutation` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.\n * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const internalMutationGeneric: MutationBuilder<any, \"internal\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredMutation<\"internal\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  assertNotBrowser();\n  func.isRegistered = true;\n  func.isMutation = true;\n  func.isInternal = true;\n  func.invokeMutation = (argsStr) => invokeMutation(func, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\nasync function invokeQuery<\n  F extends (ctx: QueryCtx<GenericDataModel>, ...args: any) => any\n>(func: F, argsStr: string, allowMapsAndSetsInReturnValue: boolean) {\n  // TODO(presley): Change the function signature and propagate the requestId from Rust.\n  // Ok, to mock it out for now, since queries are only running in V8.\n  const requestId = \"\";\n  const args = jsonToConvex(JSON.parse(argsStr), false);\n  const queryCtx = {\n    db: setupReader(),\n    auth: setupAuth(requestId),\n    storage: setupStorageReader(requestId),\n  };\n  const result = await invokeFunction(func, queryCtx, args as any);\n  validateReturnValue(result);\n  return JSON.stringify(\n    convexToJson(\n      result === undefined ? null : result,\n      allowMapsAndSetsInReturnValue\n    )\n  );\n}\n\n/**\n * Define a query in this Convex app's public API.\n *\n * This function will be allowed to read your Convex database and will be accessible from the client.\n *\n * If you're using code generation, use the `query` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The query function. It receives a {@link QueryCtx} as its first argument.\n * @returns The wrapped query. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const queryGeneric: QueryBuilder<any, \"public\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredQuery<\"public\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  assertNotBrowser();\n  func.isRegistered = true;\n  func.isQuery = true;\n  func.isPublic = true;\n  func.invokeQuery = (argsStr, allowMapsAndSetsInReturnValue) =>\n    invokeQuery(func, argsStr, allowMapsAndSetsInReturnValue);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\n/**\n * Define a query that is only accessible from other Convex functions (but not from the client).\n *\n * This function will be allowed to read from your Convex database. It will not be accessible from the client.\n *\n * If you're using code generation, use the `internalQuery` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The query function. It receives a {@link QueryCtx} as its first argument.\n * @returns The wrapped query. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const internalQueryGeneric: QueryBuilder<any, \"internal\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredQuery<\"internal\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  assertNotBrowser();\n  func.isRegistered = true;\n  func.isQuery = true;\n  func.isInternal = true;\n  func.invokeQuery = (argsStr) => invokeQuery(func as any, argsStr, false);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\nasync function invokeAction<\n  F extends (ctx: ActionCtx<GenericDataModel>, ...args: any) => any\n>(func: F, requestId: string, argsStr: string) {\n  const args = jsonToConvex(JSON.parse(argsStr), false);\n  const calls = setupActionCalls(requestId);\n  const ctx = {\n    ...calls,\n    auth: setupAuth(requestId),\n    scheduler: setupActionScheduler(requestId),\n    storage: setupStorageActionWriter(requestId),\n    vectorSearch: setupActionVectorSearch(requestId) as any,\n  };\n  const result = await invokeFunction(func, ctx, args as any);\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\n/**\n * Define an action in this Convex app's public API.\n *\n * If you're using code generation, use the `action` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The function. It receives a {@link ActionCtx} as its first argument.\n * @returns The wrapped function. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const actionGeneric: ActionBuilder<any, \"public\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredAction<\"public\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  assertNotBrowser();\n  func.isRegistered = true;\n  func.isAction = true;\n  func.isPublic = true;\n  func.invokeAction = (requestId, argsStr) =>\n    invokeAction(func, requestId, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\n/**\n * Define an action that is only accessible from other Convex functions (but not from the client).\n *\n * If you're using code generation, use the `internalAction` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The function. It receives a {@link ActionCtx} as its first argument.\n * @returns The wrapped function. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const internalActionGeneric: ActionBuilder<any, \"internal\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredAction<\"internal\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  assertNotBrowser();\n  func.isRegistered = true;\n  func.isAction = true;\n  func.isInternal = true;\n  func.invokeAction = (requestId, argsStr) =>\n    invokeAction(func, requestId, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\nasync function invokeHttpAction<\n  F extends (ctx: ActionCtx<GenericDataModel>, request: Request) => any\n>(func: F, request: Request) {\n  // TODO(presley): Change the function signature and propagate the requestId from Rust.\n  // Ok, to mock it out for now, since http endpoints are only running in V8.\n  const requestId = \"\";\n  const calls = setupActionCalls(requestId);\n  const ctx = {\n    ...calls,\n    auth: setupAuth(requestId),\n    storage: setupStorageActionWriter(requestId),\n    scheduler: setupActionScheduler(requestId),\n    vectorSearch: setupActionVectorSearch(requestId) as any,\n  };\n  return await invokeFunction(func, ctx, [request]);\n}\n\n/**\n * Define a Convex HTTP action.\n *\n * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object\n * as its second.\n * @returns The wrapped function. Route a URL path to this function in `convex/http.js`.\n *\n * @public\n */\nexport const httpActionGeneric = (\n  func: (\n    ctx: ActionCtx<GenericDataModel>,\n    request: Request\n  ) => Promise<Response>\n): PublicHttpAction => {\n  const q = func as unknown as PublicHttpAction;\n  // Helpful runtime check that functions are only be registered once\n  if (q.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  assertNotBrowser();\n  q.isRegistered = true;\n  q.isHttp = true;\n  q.invokeHttpAction = (request) => invokeHttpAction(func as any, request);\n  return q;\n};\n"],
  "mappings": "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",
  "names": ["v"]
}
