{
  "version": 3,
  "sources": ["../../../../src/cli/lib/codegen.ts"],
  "sourcesContent": ["import path from \"path\";\nimport prettier from \"prettier\";\nimport { mkdtemp, nodeFs, TempDir } from \"../../bundler/fs.js\";\nimport { entryPoints, walkDir } from \"../../bundler/index.js\";\nimport { apiCodegen } from \"../codegen_templates/api.js\";\nimport { apiCjsCodegen } from \"../codegen_templates/api_cjs.js\";\nimport { GeneratedJsWithTypes } from \"../codegen_templates/common.js\";\nimport {\n  dataModel,\n  dataModelWithoutSchema,\n} from \"../codegen_templates/dataModel.js\";\nimport { readmeCodegen } from \"../codegen_templates/readme.js\";\nimport { serverCodegen } from \"../codegen_templates/server.js\";\nimport { tsconfigCodegen } from \"../codegen_templates/tsconfig.js\";\nimport {\n  Context,\n  logError,\n  logMessage,\n  logOutput,\n} from \"../../bundler/context.js\";\nimport { typeCheckFunctionsInMode, TypeCheckMode } from \"./typecheck.js\";\nimport { readProjectConfig } from \"./config.js\";\n\n/**\n * Run prettier so we don't have to think about formatting!\n *\n * This is a little sketchy because we are using the default prettier config\n * (not our user's one) but it's better than nothing.\n */\nfunction format(source: string, filetype: string): string {\n  return prettier.format(source, { parser: filetype, pluginSearchDirs: false });\n}\n\nfunction writeFile(\n  ctx: Context,\n  filename: string,\n  source: string,\n  dir: TempDir,\n  dryRun: boolean,\n  debug: boolean,\n  quiet: boolean,\n  filetype = \"typescript\"\n) {\n  const formattedSource = format(source, filetype);\n  const dest = path.join(dir.tmpPath, filename);\n  if (debug) {\n    logOutput(ctx, `# ${filename}`);\n    logOutput(ctx, formattedSource);\n    return;\n  }\n  if (dryRun) {\n    if (ctx.fs.exists(dest)) {\n      const fileText = ctx.fs.readUtf8File(dest);\n      if (fileText !== formattedSource) {\n        logOutput(ctx, `Command would replace file: ${dest}`);\n      }\n    } else {\n      logOutput(ctx, `Command would create file: ${dest}`);\n    }\n    return;\n  }\n\n  if (!quiet) {\n    logMessage(ctx, `writing ${filename}`);\n  }\n\n  nodeFs.writeUtf8File(dest, formattedSource);\n}\n\nasync function writeJsWithTypes(\n  ctx: Context,\n  name: string,\n  content: GeneratedJsWithTypes,\n  codegenDir: TempDir,\n  dryRun: boolean,\n  debug: boolean,\n  quiet: boolean\n) {\n  const [jsName, dtsName] = name.endsWith(\".cjs\")\n    ? [name, `${name.slice(0, -4)}.d.cts`]\n    : name.endsWith(\".mjs\")\n    ? [name, `${name.slice(0, -4)}.d.mts`]\n    : name.endsWith(\".js\")\n    ? [name, `${name.slice(0, -3)}.d.ts`]\n    : [`${name}.js`, `${name}.d.ts`];\n  writeFile(ctx, dtsName, content.DTS, codegenDir, dryRun, debug, quiet);\n  if (content.JS) {\n    writeFile(ctx, jsName, content.JS, codegenDir, dryRun, debug, quiet);\n  }\n}\n\nasync function doServerCodegen(\n  ctx: Context,\n  codegenDir: TempDir,\n  dryRun: boolean,\n  hasSchemaFile: boolean,\n  debug: boolean,\n  quiet = false\n) {\n  if (hasSchemaFile) {\n    await writeJsWithTypes(\n      ctx,\n      \"dataModel\",\n      dataModel,\n      codegenDir,\n      dryRun,\n      debug,\n      quiet\n    );\n  } else {\n    await writeJsWithTypes(\n      ctx,\n      \"dataModel\",\n      dataModelWithoutSchema,\n      codegenDir,\n      dryRun,\n      debug,\n      quiet\n    );\n  }\n  await writeJsWithTypes(\n    ctx,\n    \"server\",\n    serverCodegen(),\n    codegenDir,\n    dryRun,\n    debug,\n    quiet\n  );\n}\n\nasync function doApiCodegen(\n  ctx: Context,\n  functionsDir: string,\n  codegenDir: TempDir,\n  dryRun: boolean,\n  debug: boolean,\n  quiet = false,\n  commonjs = false\n) {\n  const modulePaths = (await entryPoints(ctx, functionsDir, false)).map(\n    (entryPoint) => path.relative(functionsDir, entryPoint)\n  );\n  await writeJsWithTypes(\n    ctx,\n    \"api\",\n    apiCodegen(modulePaths),\n    codegenDir,\n    dryRun,\n    debug,\n    quiet\n  );\n  if (commonjs) {\n    // We might generate a .d.ts file too if users need it\n    // since .d.cts may not be supported in older versions of TypeScript\n    await writeJsWithTypes(\n      ctx,\n      \"api_cjs.cjs\",\n      apiCjsCodegen(modulePaths),\n      codegenDir,\n      dryRun,\n      debug,\n      quiet\n    );\n  }\n}\n\nexport async function doCodegen({\n  ctx,\n  functionsDirectoryPath,\n  typeCheckMode,\n  dryRun = false,\n  debug = false,\n  quiet = false,\n  generateCommonJSApi = false,\n}: {\n  ctx: Context;\n  functionsDirectoryPath: string;\n  typeCheckMode: TypeCheckMode;\n  dryRun?: boolean;\n  debug?: boolean;\n  quiet?: boolean;\n  generateCommonJSApi?: boolean;\n}): Promise<void> {\n  const { projectConfig } = await readProjectConfig(ctx);\n  // Delete the old _generated.ts because v0.1.2 used to put the react generated\n  // code there\n  const legacyCodegenPath = path.join(functionsDirectoryPath, \"_generated.ts\");\n  if (ctx.fs.exists(legacyCodegenPath)) {\n    if (!dryRun) {\n      logError(ctx, `Deleting legacy codegen file: ${legacyCodegenPath}}`);\n      ctx.fs.unlink(legacyCodegenPath);\n    } else {\n      logError(\n        ctx,\n        `Command would delete legacy codegen file: ${legacyCodegenPath}}`\n      );\n    }\n  }\n\n  // Create the function dir if it doesn't already exist.\n  ctx.fs.mkdir(functionsDirectoryPath, { allowExisting: true });\n\n  const schemaPath = path.join(functionsDirectoryPath, \"schema.ts\");\n  const hasSchemaFile = ctx.fs.exists(schemaPath);\n\n  // Recreate the codegen directory in a temp location\n  await mkdtemp(\"_generated\", async (tempCodegenDir) => {\n    // Do things in a careful order so that we always generate code in\n    // dependency order.\n    //\n    // Ideally we would also typecheck sources before we use them. However,\n    // we can't typecheck a single file while respecting the tsconfig, which can\n    // produce misleading errors. Instead, we'll typecheck the generated code at\n    // the end.\n    //\n    // The dependency chain is:\n    // _generated/api.js\n    // -> query and mutation functions\n    // -> _generated/server.js\n    // -> schema.ts\n    // (where -> means \"depends on\")\n\n    // 1. Use the schema.ts file to create the server codegen\n    await doServerCodegen(\n      ctx,\n      tempCodegenDir,\n      dryRun,\n      hasSchemaFile,\n      debug,\n      quiet\n    );\n\n    // 2. Generate API\n    await doApiCodegen(\n      ctx,\n      functionsDirectoryPath,\n      tempCodegenDir,\n      dryRun,\n      debug,\n      quiet,\n      generateCommonJSApi || projectConfig.generateCommonJSApi\n    );\n\n    // If any files differ replace the codegen directory with its new contents\n    if (!debug && !dryRun) {\n      const codegenDir = path.join(functionsDirectoryPath, \"_generated\");\n      if (!canSkipSync(ctx, tempCodegenDir, codegenDir)) {\n        syncFromTemp(ctx, tempCodegenDir, codegenDir, true);\n      }\n    }\n\n    // Generated code is updated, typecheck the query and mutation functions.\n    await typeCheckFunctionsInMode(ctx, typeCheckMode, functionsDirectoryPath);\n  });\n}\n\nfunction zipLongest<T>(a: T[], b: T[]): [T?, T?][] {\n  return [...Array(Math.max(a.length, b.length)).keys()].map((i) => [\n    a[i],\n    b[i],\n  ]);\n}\n\nfunction canSkipSync(ctx: Context, tempDir: TempDir, destDir: string) {\n  if (!ctx.fs.exists(destDir)) return false;\n  for (const [tmp, dest] of zipLongest(\n    [...walkDir(ctx.fs, tempDir.tmpPath)],\n    [...walkDir(ctx.fs, destDir)]\n  )) {\n    if (!tmp || !dest) return false;\n    const tmpRelPath = path.relative(tempDir.tmpPath, tmp.path);\n    const destRelPath = path.relative(destDir, dest.path);\n    if (tmpRelPath !== destRelPath) return false;\n    if (tmp.isDir !== dest.isDir) return false;\n    if (tmp.isDir) continue;\n    if (ctx.fs.readUtf8File(tmp.path) !== ctx.fs.readUtf8File(dest.path)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// TODO: this externalizes partial state to the watching dev server (eg vite)\n// Frameworks appear to be resilient to this - but if we find issues, we\n// could tighten this up per exchangedata(2) and renameat(2) - working\n// under the assumption that the temp dir is on the same filesystem\n// as the watched directory.\nfunction syncFromTemp(\n  ctx: Context,\n  tempDir: TempDir,\n  destDir: string,\n  eliminateExtras: boolean // Eliminate extra files in destDir\n) {\n  ctx.fs.mkdir(destDir, { allowExisting: true });\n  const added = new Set();\n  // Copy in the newly codegen'd files\n  // Use Array.from to prevent mutation-while-iterating\n  for (const { isDir, path: fpath } of Array.from(\n    walkDir(ctx.fs, tempDir.tmpPath)\n  )) {\n    const relPath = path.relative(tempDir.tmpPath, fpath);\n    const destPath = path.join(destDir, relPath);\n\n    // Remove anything existing at the dest path.\n    if (ctx.fs.exists(destPath)) {\n      if (ctx.fs.stat(destPath).isDirectory()) {\n        if (!isDir) {\n          // converting dir -> file. Blow away old dir.\n          ctx.fs.rm(destPath, { recursive: true });\n        }\n        // Keep directory around in this case.\n      } else {\n        // Blow away files\n        ctx.fs.unlink(destPath);\n      }\n    }\n\n    // Move in the new file\n    if (isDir) {\n      ctx.fs.mkdir(destPath, { allowExisting: true });\n    } else {\n      ctx.fs.renameFile(fpath, destPath);\n    }\n    added.add(destPath);\n  }\n  // Eliminate any extra files/dirs in the destDir. Iterate in reverse topological\n  // because we're removing files.\n  // Use Array.from to prevent mutation-while-iterating\n  if (eliminateExtras) {\n    const destEntries = Array.from(walkDir(ctx.fs, destDir)).reverse();\n    for (const { isDir, path: fpath } of destEntries) {\n      if (!added.has(fpath)) {\n        if (isDir) {\n          ctx.fs.rmdir(fpath);\n        } else {\n          ctx.fs.unlink(fpath);\n        }\n      }\n    }\n  }\n}\n\nexport async function doInitCodegen({\n  ctx,\n  functionsDirectoryPath,\n  dryRun = false,\n  debug = false,\n  quiet = false,\n  overwrite = false,\n}: {\n  ctx: Context;\n  functionsDirectoryPath: string;\n  dryRun?: boolean;\n  debug?: boolean;\n  quiet?: boolean;\n  overwrite?: boolean;\n}): Promise<void> {\n  await mkdtemp(\"convex\", async (tempFunctionsDir) => {\n    doReadmeCodegen(\n      ctx,\n      tempFunctionsDir,\n      dryRun,\n      debug,\n      quiet,\n      overwrite ? undefined : functionsDirectoryPath\n    );\n    doTsconfigCodegen(\n      ctx,\n      tempFunctionsDir,\n      dryRun,\n      debug,\n      quiet,\n      overwrite ? undefined : functionsDirectoryPath\n    );\n    syncFromTemp(ctx, tempFunctionsDir, functionsDirectoryPath, false);\n  });\n}\n\nfunction doReadmeCodegen(\n  ctx: Context,\n  tempFunctionsDir: TempDir,\n  dryRun = false,\n  debug = false,\n  quiet = false,\n  dontOverwriteFinalDestination?: string\n) {\n  if (\n    dontOverwriteFinalDestination &&\n    ctx.fs.exists(path.join(dontOverwriteFinalDestination, \"README.md\"))\n  ) {\n    logMessage(ctx, `not overwriting README.md`);\n    return;\n  }\n  writeFile(\n    ctx,\n    \"README.md\",\n    readmeCodegen(),\n    tempFunctionsDir,\n    dryRun,\n    debug,\n    quiet,\n    \"markdown\"\n  );\n}\n\nfunction doTsconfigCodegen(\n  ctx: Context,\n  tempFunctionsDir: TempDir,\n  dryRun = false,\n  debug = false,\n  quiet = false,\n  dontOverwriteFinalDestination?: string\n) {\n  if (\n    dontOverwriteFinalDestination &&\n    ctx.fs.exists(path.join(dontOverwriteFinalDestination, \"tsconfig.json\"))\n  ) {\n    logMessage(ctx, `not overwriting tsconfig.json`);\n    return;\n  }\n  writeFile(\n    ctx,\n    \"tsconfig.json\",\n    tsconfigCodegen(),\n    tempFunctionsDir,\n    dryRun,\n    debug,\n    quiet,\n    \"json\"\n  );\n}\n"],
  "mappings": "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",
  "names": []
}
