{
  "version": 3,
  "sources": ["../../../../src/cli/lib/logs.ts"],
  "sourcesContent": ["import {\n  Context,\n  logMessage,\n  logOutput,\n  logWarning,\n} from \"../../bundler/context.js\";\nimport { version } from \"../version.js\";\nimport { nextBackoff } from \"../dev.js\";\nimport chalk from \"chalk\";\nimport { deploymentClient } from \"./utils.js\";\n\nconst MAX_UDF_STREAM_FAILURE_COUNT = 5;\n\ntype LogDestination = \"stdout\" | \"stderr\";\n\nexport async function watchLogs(\n  ctx: Context,\n  url: string,\n  adminKey: string,\n  dest: LogDestination\n) {\n  const authHeader = createAuthHeader(adminKey);\n  let numFailures = 0;\n  let isFirst = true;\n  let cursorMs = 0;\n\n  for (;;) {\n    try {\n      const { entries, newCursor } = await pollUdfLog(\n        cursorMs,\n        url,\n        authHeader\n      );\n      cursorMs = newCursor;\n      numFailures = 0;\n      // The first execution, we just want to fetch the current head cursor so we don't send stale\n      // logs to the client.\n      if (isFirst) {\n        isFirst = false;\n      } else {\n        processLogs(ctx, entries, dest);\n      }\n    } catch (e) {\n      numFailures += 1;\n    }\n    // Handle backoff\n    if (numFailures > 0) {\n      const backoff = nextBackoff(numFailures);\n\n      // If we exceed a threshold number of failures, warn the user and display backoff.\n      if (numFailures > MAX_UDF_STREAM_FAILURE_COUNT) {\n        logWarning(\n          ctx,\n          `Convex [WARN] Failed to fetch logs. Waiting ${backoff}ms before next retry.`\n        );\n      }\n      await new Promise((resolve) => {\n        setTimeout(() => resolve(null), backoff);\n      });\n    }\n  }\n}\n\nfunction createAuthHeader(adminKey: string): string {\n  return `Convex ${adminKey}`;\n}\n\ntype UdfType = \"Query\" | \"Mutation\" | \"Action\" | \"HttpAction\";\n\ntype UdfExecutionResponse = {\n  identifier: string;\n  udfType: UdfType;\n  logLines: string[];\n  // Unix timestamp (in seconds)\n  timestamp: number;\n  // UDF execution duration (in seconds)\n  executionTime: number;\n  error: string | null;\n};\n\nasync function pollUdfLog(\n  cursor: number,\n  url: string,\n  authHeader: string\n): Promise<{ entries: UdfExecutionResponse[]; newCursor: number }> {\n  const client = deploymentClient(url);\n  const response = await client.get(\n    `/api/stream_udf_execution?cursor=${cursor}`,\n    {\n      headers: {\n        Authorization: authHeader,\n        \"Convex-Client\": `npm-cli-${version}`,\n      },\n    }\n  );\n  return response.data;\n}\n\nconst prefixForSource = (udfType: UdfType): string => {\n  return udfType.charAt(0);\n};\n\nfunction processLogs(\n  ctx: Context,\n  rawLogs: UdfExecutionResponse[],\n  dest: LogDestination\n) {\n  for (let i = 0; i < rawLogs.length; i++) {\n    if (rawLogs[i].logLines) {\n      const id = rawLogs[i].identifier;\n      const udfType = rawLogs[i].udfType;\n\n      for (let j = 0; j < rawLogs[i].logLines.length; j++) {\n        logToTerminal(ctx, \"info\", udfType, id, rawLogs[i].logLines[j], dest);\n      }\n      if (rawLogs[i].error) {\n        logToTerminal(ctx, \"error\", udfType, id, rawLogs[i].error!, dest);\n      }\n    }\n  }\n}\n\nfunction logToTerminal(\n  ctx: Context,\n  type: \"info\" | \"error\",\n  udfType: UdfType,\n  udfPath: string,\n  message: string,\n  dest: LogDestination\n) {\n  const prefix = prefixForSource(udfType);\n  if (type === \"info\") {\n    const match = message.match(/^\\[.*?\\] /);\n    if (match === null) {\n      logToDestination(\n        ctx,\n        dest,\n        chalk.red(`[CONVEX ${prefix}(${udfPath})] Could not parse console.log`)\n      );\n      return;\n    }\n    const level = message.slice(1, match[0].length - 2);\n    const args = message.slice(match[0].length);\n\n    logToDestination(\n      ctx,\n      dest,\n      chalk.cyan(`> [CONVEX ${prefix}(${udfPath})] [${level}]`),\n      args\n    );\n  } else {\n    logToDestination(\n      ctx,\n      dest,\n      chalk.red(`> [CONVEX ${prefix}(${udfPath})] ${message}`)\n    );\n  }\n}\n\nfunction logToDestination(ctx: Context, dest: LogDestination, ...logged: any) {\n  switch (dest) {\n    case \"stdout\":\n      logOutput(ctx, ...logged);\n      break;\n    case \"stderr\":\n      logMessage(ctx, ...logged);\n      break;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
