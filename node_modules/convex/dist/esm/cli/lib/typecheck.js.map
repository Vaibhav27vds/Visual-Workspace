{
  "version": 3,
  "sources": ["../../../../src/cli/lib/typecheck.ts"],
  "sourcesContent": ["import chalk from \"chalk\";\nimport path from \"path\";\nimport {\n  Context,\n  logError,\n  logFailure,\n  showSpinner,\n} from \"../../bundler/context.js\";\nimport * as Sentry from \"@sentry/node\";\nimport * as semver from \"semver\";\nimport { spawnAsync } from \"./utils.js\";\n\nexport type TypecheckResult = \"cantTypeCheck\" | \"success\" | \"typecheckFailed\";\n\nexport type TypeCheckMode = \"enable\" | \"try\" | \"disable\";\n\ntype TypecheckResultHandler = (\n  result: TypecheckResult,\n  logSpecificError?: () => void,\n  // If given, we run it to print out errors.\n  // We expect it to throw or resolve to \"success\"\n  // if a concurrent change invalidated the error result.\n  runOnError?: () => Promise<\"success\">\n) => Promise<void>;\n\n/**\n * Conditionally run a typecheck function and interpret the result.\n *\n * If typeCheckMode === \"disable\", never run the typecheck function.\n * If typeCheckMode === \"enable\", run the typecheck and crash if typechecking\n * fails or we can't find tsc.\n * If typeCheckMode === \"try\", try and run the typecheck. crash if typechecking\n * fails but don't worry if tsc is missing and we can't run it.\n */\nexport async function typeCheckFunctionsInMode(\n  ctx: Context,\n  typeCheckMode: TypeCheckMode,\n  functionsDir: string\n): Promise<void> {\n  if (typeCheckMode === \"disable\") {\n    return;\n  }\n  await typeCheckFunctions(\n    ctx,\n    functionsDir,\n    async (result, logSpecificError, runOnError) => {\n      if (\n        (result === \"cantTypeCheck\" && typeCheckMode === \"enable\") ||\n        result === \"typecheckFailed\"\n      ) {\n        logSpecificError?.();\n        logError(\n          ctx,\n          chalk.gray(\"To ignore failing typecheck, use `--typecheck=disable`.\")\n        );\n        try {\n          const result = await runOnError?.();\n          // Concurrent change invalidated the error, don't fail\n          if (result === \"success\") {\n            return;\n          }\n        } catch (e) {\n          // As expected, `runOnError` threw\n        }\n        await ctx.crash(1, \"invalid filesystem data\");\n      }\n    }\n  );\n}\n\n// Runs TypeScript compiler to typecheck Convex query and mutation functions.\nexport async function typeCheckFunctions(\n  ctx: Context,\n  functionsDir: string,\n  handleResult: TypecheckResultHandler\n): Promise<void> {\n  const tsconfig = path.join(functionsDir, \"tsconfig.json\");\n  if (!ctx.fs.exists(tsconfig)) {\n    return handleResult(\"cantTypeCheck\", () => {\n      logError(\n        ctx,\n        \"Found no convex/tsconfig.json to use to typecheck Convex functions, so skipping typecheck.\"\n      );\n      logError(ctx, \"Run `npx convex codegen --init` to create one.\");\n    });\n  }\n  await runTsc(ctx, [\"--project\", functionsDir], handleResult);\n}\n\nasync function runTsc(\n  ctx: Context,\n  tscArgs: string[],\n  handleResult: TypecheckResultHandler\n): Promise<void> {\n  // Check if tsc is even installed\n  const tscPath = path.join(\n    \"node_modules\",\n    \".bin\",\n    process.platform === \"win32\" ? \"tsc.CMD\" : \"tsc\"\n  );\n  if (!ctx.fs.exists(tscPath)) {\n    return handleResult(\"cantTypeCheck\", () => {\n      logError(\n        ctx,\n        chalk.gray(\"No TypeScript binary found, so skipping typecheck.\")\n      );\n    });\n  }\n\n  // Check the TypeScript version matches the recommendation from Convex\n  const versionResult = await spawnAsync(ctx, tscPath, [\"--version\"]);\n\n  const version = versionResult.stdout.match(/Version (.*)/)?.[1] ?? null;\n  const hasOlderTypeScriptVersion = version && semver.lt(version, \"4.8.4\");\n\n  await runTscInner(ctx, tscPath, tscArgs, handleResult);\n\n  // Print this warning after any logs from running `tsc`\n  if (hasOlderTypeScriptVersion) {\n    logError(\n      ctx,\n      chalk.yellow(\n        \"Convex works best with TypeScript version 4.8.4 or newer -- npm i --save-dev typescript@latest to update.\"\n      )\n    );\n  }\n}\n\nasync function runTscInner(\n  ctx: Context,\n  tscPath: string,\n  tscArgs: string[],\n  handleResult: TypecheckResultHandler\n) {\n  // Run `tsc` once and have it print out the files it touched. This output won't\n  // be very useful if there's an error, but we'll run it again to get a nice\n  // user-facing error in this exceptional case.\n  // The `--listFiles` command prints out files touched on success or error.\n  const result = await spawnAsync(ctx, tscPath, tscArgs.concat(\"--listFiles\"));\n  if (result.status === null) {\n    return handleResult(\"typecheckFailed\", () => {\n      logFailure(ctx, `TypeScript typecheck timed out.`);\n      if (result.error) {\n        logError(ctx, chalk.red(`${result.error.toString()}`));\n      }\n    });\n  }\n  // Okay, we may have failed `tsc` but at least it returned. Try to parse its\n  // output to discover which files it touched.\n  const filesTouched = result.stdout\n    .split(\"\\n\")\n    .map((s) => s.trim())\n    .filter((s) => s.length > 0);\n  let anyPathsFound = false;\n  for (const fileTouched of filesTouched) {\n    const absPath = path.resolve(fileTouched);\n    let st;\n    try {\n      st = ctx.fs.stat(absPath);\n      anyPathsFound = true;\n    } catch (err: any) {\n      // Just move on if we have a bogus path from `tsc`. We'll log below if\n      // we fail to stat *any* of the paths emitted by `tsc`.\n      // TODO: Switch to using their JS API so we can get machine readable output.\n      continue;\n    }\n    ctx.fs.registerPath(absPath, st);\n  }\n  if (filesTouched.length > 0 && !anyPathsFound) {\n    const err = new Error(\n      `Failed to stat any files emitted by tsc (received ${filesTouched.length})`\n    );\n    Sentry.captureException(err);\n  }\n\n  if (!result.error && result.status === 0) {\n    return handleResult(\"success\");\n  }\n\n  // This is the \"No inputs were found\", which is fine and we shouldn't\n  // report it to the user.\n  if (result.stdout.startsWith(\"error TS18003\")) {\n    return handleResult(\"success\");\n  }\n\n  // At this point we know that `tsc` failed. Rerun it without `--listFiles`\n  // and with stderr redirected to have it print out a nice error.\n  return handleResult(\n    \"typecheckFailed\",\n    () => {\n      logFailure(ctx, \"TypeScript typecheck via `tsc` failed.\");\n    },\n    async () => {\n      showSpinner(ctx, \"Collecting TypeScript errors\");\n      await spawnAsync(ctx, tscPath, [...tscArgs, \"--pretty\", \"true\"], {\n        stdio: \"inherit\",\n      });\n      // If this passes, we had a concurrent file change that'll overlap with\n      // our observations in the first run. Invalidate our context's filesystem\n      // but allow the rest of the system to observe the success.\n      ctx.fs.invalidate();\n      return \"success\";\n    }\n  );\n}\n"],
  "mappings": "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",
  "names": ["result"]
}
