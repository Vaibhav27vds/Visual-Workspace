{
  "version": 3,
  "sources": ["../../../src/cli/dev.ts"],
  "sourcesContent": ["import chalk from \"chalk\";\nimport { Command, Option } from \"commander\";\nimport path from \"path\";\nimport { performance } from \"perf_hooks\";\nimport {\n  Context,\n  logFinishedStep,\n  logMessage,\n  logWarning,\n  oneoffContext,\n  showSpinner,\n  showSpinnerIfSlow,\n  stopSpinner,\n} from \"../bundler/context.js\";\nimport { deploymentCredentialsOrConfigure } from \"./configure.js\";\nimport { checkAuthorization, performLogin } from \"./lib/login.js\";\nimport { PushOptions, runPush } from \"./lib/push.js\";\nimport {\n  formatDuration,\n  getCurrentTimeString,\n  waitForever,\n} from \"./lib/utils.js\";\nimport { Crash, WatchContext, Watcher } from \"./lib/watch.js\";\nimport { watchLogs } from \"./lib/logs.js\";\nimport { runFunctionAndLog, subscribe } from \"./lib/run.js\";\nimport { BaseConvexClient } from \"../browser/index.js\";\nimport { Value } from \"../values/index.js\";\nimport { usageStateWarning } from \"./lib/usage.js\";\n\nexport const dev = new Command(\"dev\")\n  .summary(\"Develop against a dev deployment, watching for changes\")\n  .description(\n    \"Develop against a dev deployment, watching for changes\\n\\n\" +\n      \"  1. Configures a new or existing project (if needed)\\n\" +\n      \"  2. Updates generated types and pushes code to the configured dev deployment\\n\" +\n      \"  3. Runs the provided function (if `--run` is used)\\n\" +\n      \"  4. Watches for file changes, and repeats step 2\\n\"\n  )\n  .option(\"-v, --verbose\", \"Show full listing of changes\")\n  .addOption(\n    new Option(\n      \"--typecheck <mode>\",\n      `Check TypeScript files with \\`tsc --noEmit\\`.`\n    )\n      .choices([\"enable\", \"try\", \"disable\"])\n      .default(\"try\")\n  )\n  .addOption(\n    new Option(\"--codegen <mode>\", \"Regenerate code in `convex/_generated/`\")\n      .choices([\"enable\", \"disable\"])\n      .default(\"enable\")\n  )\n  .addOption(\n    new Option(\n      \"--configure [choice]\",\n      \"Ignore existing configuration and configure new or existing project\"\n    ).choices([\"new\", \"existing\"])\n  )\n  .option(\"--team <team_slug>\", \"The team you'd like to use for this project\")\n  .option(\n    \"--project <project_slug>\",\n    \"The name of the project you'd like to configure\"\n  )\n  .option(\"--once\", \"Execute only the first 3 steps, stop on any failure\")\n  .option(\n    \"--until-success\",\n    \"Execute only the first 3 steps, on failure watch for local and remote changes and retry steps 2 and 3\"\n  )\n  .option(\n    \"--run <functionName>\",\n    \"The identifier of the function to run in step 3, \" +\n      \"like `init` or `dir/file:myFunction`\"\n  )\n  .addOption(\n    new Option(\n      \"--prod\",\n      \"Develop live against this project's production deployment.\"\n    ).hideHelp()\n  )\n  .addOption(\n    new Option(\n      \"--tail-logs\",\n      \"Tail this project's Convex logs in this terminal.\"\n    )\n  )\n  .addOption(new Option(\"--trace-events\").hideHelp())\n  .addOption(new Option(\"--admin-key <adminKey>\").hideHelp())\n  .addOption(new Option(\"--url <url>\").hideHelp())\n  // Options for testing\n  .addOption(new Option(\"--override-auth-url <url>\").hideHelp())\n  .addOption(new Option(\"--override-auth-client <id>\").hideHelp())\n  .addOption(new Option(\"--override-auth-username <username>\").hideHelp())\n  .addOption(new Option(\"--override-auth-password <password>\").hideHelp())\n  .showHelpAfterError()\n  .action(async (cmdOptions) => {\n    const ctx = oneoffContext;\n\n    if (!cmdOptions.url || !cmdOptions.adminKey) {\n      if (!(await checkAuthorization(ctx, false))) {\n        await performLogin(ctx, cmdOptions);\n      }\n    }\n\n    const configure =\n      cmdOptions.configure === true ? \"ask\" : cmdOptions.configure ?? null;\n    const credentials = await deploymentCredentialsOrConfigure(\n      ctx,\n      configure,\n      cmdOptions\n    );\n\n    await usageStateWarning(ctx);\n\n    const promises = [];\n    if (cmdOptions.tailLogs) {\n      promises.push(\n        watchLogs(ctx, credentials.url, credentials.adminKey, \"stderr\")\n      );\n    }\n    promises.push(\n      watchAndPush(\n        ctx,\n        {\n          ...credentials,\n          verbose: !!cmdOptions.verbose,\n          dryRun: false,\n          typecheck: cmdOptions.typecheck,\n          debug: false,\n          codegen: cmdOptions.codegen === \"enable\",\n        },\n        cmdOptions\n      )\n    );\n    await Promise.race(promises);\n  });\n\nexport async function watchAndPush(\n  outerCtx: Context,\n  options: PushOptions,\n  cmdOptions: {\n    run?: string;\n    once: boolean;\n    untilSuccess: boolean;\n    traceEvents: boolean;\n  }\n) {\n  const watch: { watcher: Watcher | undefined } = { watcher: undefined };\n  let numFailures = 0;\n  let ran = false;\n  let pushed = false;\n  let tableNameTriggeringRetry;\n  let shouldRetryOnDeploymentEnvVarChange;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const start = performance.now();\n    tableNameTriggeringRetry = null;\n    shouldRetryOnDeploymentEnvVarChange = false;\n    const ctx = new WatchContext(cmdOptions.traceEvents);\n    showSpinner(ctx, \"Preparing Convex functions...\");\n    try {\n      await runPush(ctx, options);\n      const end = performance.now();\n      numFailures = 0;\n      logFinishedStep(\n        ctx,\n        `${getCurrentTimeString()} Convex functions ready! (${formatDuration(\n          end - start\n        )})`\n      );\n      if (cmdOptions.run !== undefined && !ran) {\n        await runFunctionInDev(ctx, options, cmdOptions.run);\n        ran = true;\n      }\n      pushed = true;\n    } catch (e: any) {\n      // Crash the app on unexpected errors.\n      if (!(e instanceof Crash) || !e.errorType) {\n        // eslint-disable-next-line no-restricted-syntax\n        throw e;\n      }\n      if (e.errorType === \"fatal\") {\n        break;\n      }\n      // Retry after an exponential backoff if we hit a transient error.\n      if (e.errorType === \"transient\") {\n        const delay = nextBackoff(numFailures);\n        numFailures += 1;\n        logWarning(\n          ctx,\n          chalk.yellow(\n            `Failed due to network error, retrying in ${formatDuration(\n              delay\n            )}...`\n          )\n        );\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        continue;\n      }\n\n      // Fall through if we had a filesystem-based error.\n      console.assert(\n        e.errorType === \"invalid filesystem data\" ||\n          e.errorType === \"invalid filesystem or env vars\" ||\n          e.errorType[\"invalid filesystem or db data\"] !== undefined\n      );\n      if (e.errorType === \"invalid filesystem or env vars\") {\n        shouldRetryOnDeploymentEnvVarChange = true;\n      } else if (\n        e.errorType !== \"invalid filesystem data\" &&\n        e.errorType[\"invalid filesystem or db data\"] !== undefined\n      ) {\n        tableNameTriggeringRetry = e.errorType[\"invalid filesystem or db data\"];\n      }\n      if (cmdOptions.once) {\n        await outerCtx.crash(1, e.errorType);\n      }\n      // Make sure that we don't spin if this push failed\n      // in any edge cases that didn't call `logFailure`\n      // before throwing.\n      stopSpinner(ctx);\n    }\n    if (cmdOptions.once) {\n      return;\n    }\n    if (pushed && cmdOptions.untilSuccess) {\n      return;\n    }\n    const fileSystemWatch = getFileSystemWatch(ctx, watch, cmdOptions);\n    const tableWatch = getTableWatch(ctx, options, tableNameTriggeringRetry);\n    const envVarWatch = getDeplymentEnvVarWatch(\n      ctx,\n      options,\n      shouldRetryOnDeploymentEnvVarChange\n    );\n    await Promise.race([\n      fileSystemWatch.watch(),\n      tableWatch.watch(),\n      envVarWatch.watch(),\n    ]);\n    fileSystemWatch.stop();\n    void tableWatch.stop();\n    void envVarWatch.stop();\n  }\n}\n\nasync function runFunctionInDev(\n  ctx: WatchContext,\n  credentials: {\n    url: string;\n    adminKey: string;\n  },\n  functionName: string\n) {\n  await runFunctionAndLog(\n    ctx,\n    credentials.url,\n    credentials.adminKey,\n    functionName,\n    {},\n    {\n      onSuccess: () => {\n        logFinishedStep(ctx, `Finished running function \"${functionName}\"`);\n      },\n    }\n  );\n}\n\nfunction getTableWatch(\n  ctx: WatchContext,\n  credentials: {\n    url: string;\n    adminKey: string;\n  },\n  tableName: string | null\n) {\n  return getFunctionWatch(ctx, credentials, \"_system/cli/queryTable\", () =>\n    tableName !== null ? { tableName } : null\n  );\n}\n\nfunction getDeplymentEnvVarWatch(\n  ctx: WatchContext,\n  credentials: {\n    url: string;\n    adminKey: string;\n  },\n  shouldRetryOnDeploymentEnvVarChange: boolean\n) {\n  return getFunctionWatch(\n    ctx,\n    credentials,\n    \"_system/cli/queryEnvironmentVariables\",\n    () => (shouldRetryOnDeploymentEnvVarChange ? {} : null)\n  );\n}\n\nfunction getFunctionWatch(\n  ctx: WatchContext,\n  credentials: {\n    url: string;\n    adminKey: string;\n  },\n  functionName: string,\n  getArgs: () => Record<string, Value> | null\n) {\n  let client: BaseConvexClient;\n  return {\n    watch: async () => {\n      const args = getArgs();\n      if (args === null) {\n        return waitForever();\n      }\n      return subscribe(\n        ctx,\n        credentials.url,\n        credentials.adminKey,\n        functionName,\n        args,\n        \"first change\",\n        {\n          onStart: (convex) => {\n            client = convex;\n          },\n        }\n      );\n    },\n    stop: async () => {\n      await client?.close();\n    },\n  };\n}\n\nfunction getFileSystemWatch(\n  ctx: WatchContext,\n  watch: { watcher: Watcher | undefined },\n  cmdOptions: { traceEvents: boolean }\n) {\n  let hasStopped = false;\n  return {\n    watch: async () => {\n      const observations = ctx.fs.finalize();\n      if (observations === \"invalidated\") {\n        logMessage(ctx, \"Filesystem changed during push, retrying...\");\n        return;\n      }\n      // Initialize the watcher if we haven't done it already. Chokidar expects to have a\n      // nonempty watch set at initialization, so we can't do it before running our first\n      // push.\n      if (!watch.watcher) {\n        watch.watcher = new Watcher(observations);\n        await showSpinnerIfSlow(\n          ctx,\n          \"Preparing to watch files...\",\n          500,\n          async () => {\n            await watch.watcher!.ready();\n          }\n        );\n        stopSpinner(ctx);\n      }\n      // Watch new directories if needed.\n      watch.watcher.update(observations);\n\n      // Process events until we find one that overlaps with our previous observations.\n      let anyChanges = false;\n      do {\n        await watch.watcher.waitForEvent();\n        if (hasStopped) {\n          return;\n        }\n        for (const event of watch.watcher.drainEvents()) {\n          if (cmdOptions.traceEvents) {\n            logMessage(\n              ctx,\n              \"Processing\",\n              event.name,\n              path.relative(\"\", event.absPath)\n            );\n          }\n          const result = observations.overlaps(event);\n          if (result.overlaps) {\n            const relPath = path.relative(\"\", event.absPath);\n            if (cmdOptions.traceEvents) {\n              logMessage(ctx, `${relPath} ${result.reason}, rebuilding...`);\n            }\n            anyChanges = true;\n            break;\n          }\n        }\n      } while (!anyChanges);\n\n      // Wait for the filesystem to quiesce before starting a new push. It's okay to\n      // drop filesystem events at this stage since we're already committed to doing\n      // a push and resubscribing based on that push's observations.\n      let deadline = performance.now() + quiescenceDelay;\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const now = performance.now();\n        if (now >= deadline) {\n          break;\n        }\n        const remaining = deadline - now;\n        if (cmdOptions.traceEvents) {\n          logMessage(\n            ctx,\n            `Waiting for ${formatDuration(remaining)} to quiesce...`\n          );\n        }\n        const remainingWait = new Promise<\"timeout\">((resolve) =>\n          setTimeout(() => resolve(\"timeout\"), deadline - now)\n        );\n        const result = await Promise.race([\n          remainingWait,\n          watch.watcher.waitForEvent().then<\"newEvents\">(() => \"newEvents\"),\n        ]);\n        if (result === \"newEvents\") {\n          for (const event of watch.watcher.drainEvents()) {\n            const result = observations.overlaps(event);\n            // Delay another `quiescenceDelay` since we had an overlapping event.\n            if (result.overlaps) {\n              if (cmdOptions.traceEvents) {\n                logMessage(\n                  ctx,\n                  `Received an overlapping event at ${event.absPath}, delaying push.`\n                );\n              }\n              deadline = performance.now() + quiescenceDelay;\n            }\n          }\n        } else {\n          console.assert(result === \"timeout\");\n          // Let the check above `break` from the loop if we're past our deadlne.\n        }\n      }\n    },\n    stop: () => {\n      hasStopped = true;\n    },\n  };\n}\n\nconst initialBackoff = 500;\nconst maxBackoff = 16000;\nconst quiescenceDelay = 500;\n\nexport function nextBackoff(prevFailures: number): number {\n  const baseBackoff = initialBackoff * Math.pow(2, prevFailures);\n  const actualBackoff = Math.min(baseBackoff, maxBackoff);\n  const jitter = actualBackoff * (Math.random() - 0.5);\n  return actualBackoff + jitter;\n}\n"],
  "mappings": "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",
  "names": ["result"]
}
