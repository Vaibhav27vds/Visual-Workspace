"use strict";
const INFO_COLOR = "color:rgb(0, 145, 255)";
function prefix_for_source(source) {
  switch (source) {
    case "query":
      return "Q";
    case "mutation":
      return "M";
    case "action":
      return "A";
    case "any":
      return "?";
  }
}
export function logToConsole(type, source, udfPath, message) {
  const prefix = prefix_for_source(source);
  if (typeof message === "object") {
    message = `ConvexError ${JSON.stringify(message.errorData, null, 2)}`;
  }
  if (type === "info") {
    const match = message.match(/^\[.*?\] /);
    if (match === null) {
      console.error(
        `[CONVEX ${prefix}(${udfPath})] Could not parse console.log`
      );
      return;
    }
    const level = message.slice(1, match[0].length - 2);
    const args = message.slice(match[0].length);
    console.log(
      `%c[CONVEX ${prefix}(${udfPath})] [${level}]`,
      INFO_COLOR,
      args
    );
  } else {
    console.error(`[CONVEX ${prefix}(${udfPath})] ${message}`);
  }
}
export function logFatalError(message) {
  const errorMessage = `[CONVEX FATAL ERROR] ${message}`;
  console.error(errorMessage);
  return new Error(errorMessage);
}
export function createHybridErrorStacktrace(source, udfPath, result) {
  const prefix = prefix_for_source(source);
  return `[CONVEX ${prefix}(${udfPath})] ${result.errorMessage}
  Called by client`;
}
export function forwardData(result, error) {
  error.data = result.errorData;
  return error;
}
//# sourceMappingURL=logging.js.map
