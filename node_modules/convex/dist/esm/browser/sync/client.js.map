{
  "version": 3,
  "sources": ["../../../../src/browser/sync/client.ts"],
  "sourcesContent": ["import { version } from \"../../index.js\";\nimport { convexToJson, Value } from \"../../values/index.js\";\nimport {\n  createHybridErrorStacktrace,\n  forwardData,\n  logFatalError,\n} from \"../logging.js\";\nimport { LocalSyncState } from \"./local_state.js\";\nimport { RequestManager } from \"./request_manager.js\";\nimport {\n  OptimisticLocalStore,\n  OptimisticUpdate,\n} from \"./optimistic_updates.js\";\nimport {\n  OptimisticQueryResults,\n  QueryResultsMap,\n} from \"./optimistic_updates_impl.js\";\nimport {\n  ActionRequest,\n  MutationRequest,\n  QueryId,\n  QueryJournal,\n  RequestId,\n  ServerMessage,\n  TS,\n  UserIdentityAttributes,\n} from \"./protocol.js\";\nimport { RemoteQuerySet } from \"./remote_query_set.js\";\nimport { QueryToken, serializePathAndArgs } from \"./udf_path_utils.js\";\nimport { ReconnectMetadata, WebSocketManager } from \"./web_socket_manager.js\";\nimport { newSessionId } from \"./session.js\";\nimport { FunctionResult } from \"./function_result.js\";\nimport {\n  AuthenticationManager,\n  AuthTokenFetcher,\n} from \"./authentication_manager.js\";\nexport { type AuthTokenFetcher } from \"./authentication_manager.js\";\nimport { getMarksReport, mark, MarkName } from \"./metrics.js\";\nimport { parseArgs, validateDeploymentUrl } from \"../../common/index.js\";\nimport { ConvexError } from \"../../values/errors.js\";\n\n/**\n * Options for {@link BaseConvexClient}.\n *\n * @deprecated Use ConvexReactClientOptions, ConvexClientOptions, or BaseConvexClientOptions.\n *\n * @public\n */\nexport interface ClientOptions extends BaseConvexClientOptions {}\n\n/**\n * Options for {@link BaseConvexClient}.\n *\n * @public\n */\nexport interface BaseConvexClientOptions {\n  /**\n   * Whether to prompt the user if they have unsaved changes pending\n   * when navigating away or closing a web page.\n   *\n   * This is only possible when the `window` object exists, i.e. in a browser.\n   *\n   * The default value is `true` in browsers.\n   */\n  unsavedChangesWarning?: boolean;\n  /**\n   * Specifies an alternate\n   * [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\n   * constructor to use for client communication with the Convex cloud.\n   * The default behavior is to use `WebSocket` from the global environment.\n   */\n  webSocketConstructor?: typeof WebSocket;\n  /**\n   * Adds additional logging for debugging purposes.\n   *\n   * The default value is `false`.\n   */\n  verbose?: boolean;\n  /**\n   * Sends additional metrics to Convex for debugging purposes.\n   *\n   * The default value is `false`.\n   */\n  reportDebugInfoToConvex?: boolean;\n}\n\n/**\n * State describing the client's connection with the Convex backend.\n *\n * @public\n */\nexport type ConnectionState = {\n  hasInflightRequests: boolean;\n  isWebSocketConnected: boolean;\n  timeOfOldestInflightRequest: Date | null;\n};\n\n/**\n * Options for {@link BaseConvexClient.subscribe}.\n *\n * @public\n */\nexport interface SubscribeOptions {\n  /**\n   * An (optional) journal produced from a previous execution of this query\n   * function.\n   *\n   * If there is an existing subscription to a query function with the same\n   * name and arguments, this journal will have no effect.\n   */\n  journal?: QueryJournal;\n}\n\n/**\n * Options for {@link BaseConvexClient.mutation}.\n *\n * @public\n */\nexport interface MutationOptions {\n  /**\n   * An optimistic update to apply along with this mutation.\n   *\n   * An optimistic update locally updates queries while a mutation is pending.\n   * Once the mutation completes, the update will be rolled back.\n   */\n  optimisticUpdate?: OptimisticUpdate<any>;\n}\n\n/**\n * Low-level client for directly integrating state management libraries\n * with Convex.\n *\n * Most developers should use higher level clients, like\n * the {@link ConvexHttpClient} or the React hook based {@link react.ConvexReactClient}.\n *\n * @public\n */\nexport class BaseConvexClient {\n  private readonly address: string;\n  private readonly state: LocalSyncState;\n  private readonly requestManager: RequestManager;\n  private readonly webSocketManager: WebSocketManager;\n  private readonly authenticationManager: AuthenticationManager;\n  private remoteQuerySet: RemoteQuerySet;\n  private readonly optimisticQueryResults: OptimisticQueryResults;\n  private readonly onTransition: (updatedQueries: QueryToken[]) => void;\n  private nextRequestId: RequestId;\n  private readonly sessionId: string;\n  private firstMessageReceived = false;\n  private readonly verbose: boolean;\n  private readonly debug: boolean;\n  private maxObservedTimestamp: TS | undefined;\n\n  /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param onTransition - A callback receiving an array of query tokens\n   * corresponding to query results that have changed.\n   * @param options - See {@link BaseConvexClientOptions} for a full description.\n   */\n  constructor(\n    address: string,\n    onTransition: (updatedQueries: QueryToken[]) => void,\n    options?: BaseConvexClientOptions\n  ) {\n    if (typeof address === \"object\") {\n      throw new Error(\n        \"Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly.\"\n      );\n    }\n    validateDeploymentUrl(address);\n    options = { ...options };\n    let webSocketConstructor = options.webSocketConstructor;\n    if (!webSocketConstructor && typeof WebSocket === \"undefined\") {\n      throw new Error(\n        \"No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient\"\n      );\n    }\n    webSocketConstructor = webSocketConstructor || WebSocket;\n    this.verbose = options.verbose ?? false;\n    this.debug = options.reportDebugInfoToConvex ?? false;\n    this.address = address;\n\n    // Substitute http(s) with ws(s)\n    const i = address.search(\"://\");\n    if (i === -1) {\n      throw new Error(\"Provided address was not an absolute URL.\");\n    }\n    const origin = address.substring(i + 3); // move past the double slash\n    const protocol = address.substring(0, i);\n    let wsProtocol;\n    if (protocol === \"http\") {\n      wsProtocol = \"ws\";\n    } else if (protocol === \"https\") {\n      wsProtocol = \"wss\";\n    } else {\n      throw new Error(`Unknown parent protocol ${protocol}`);\n    }\n    const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;\n\n    this.state = new LocalSyncState();\n    this.remoteQuerySet = new RemoteQuerySet((queryId) =>\n      this.state.queryPath(queryId)\n    );\n    this.requestManager = new RequestManager();\n    this.authenticationManager = new AuthenticationManager(this.state, {\n      authenticate: (token) => {\n        const message = this.state.setAuth(token);\n        this.webSocketManager.sendMessage(message);\n      },\n      pauseSocket: () => this.webSocketManager.pause(),\n      resumeSocket: () => this.webSocketManager.resume(),\n      clearAuth: () => {\n        this.clearAuth();\n      },\n      verbose: this.verbose,\n    });\n    this.optimisticQueryResults = new OptimisticQueryResults();\n    this.onTransition = onTransition;\n    this.nextRequestId = 0;\n    this.sessionId = newSessionId();\n\n    const { unsavedChangesWarning } = options;\n    if (\n      typeof window === \"undefined\" ||\n      typeof window.addEventListener === \"undefined\"\n    ) {\n      if (unsavedChangesWarning === true) {\n        throw new Error(\n          \"unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options.\"\n        );\n      }\n    } else if (unsavedChangesWarning !== false) {\n      // Listen for tab close events and notify the user on unsaved changes.\n      window.addEventListener(\"beforeunload\", (e) => {\n        if (this.requestManager.hasIncompleteRequests()) {\n          // There are 3 different ways to trigger this pop up so just try all of\n          // them.\n\n          e.preventDefault();\n          // This confirmation message doesn't actually appear in most modern\n          // browsers but we tried.\n          const confirmationMessage =\n            \"Are you sure you want to leave? Your changes may not be saved.\";\n          (e || window.event).returnValue = confirmationMessage;\n          return confirmationMessage;\n        }\n      });\n    }\n\n    this.webSocketManager = new WebSocketManager(\n      wsUri,\n      (reconnectMetadata: ReconnectMetadata) => {\n        // We have a new WebSocket!\n        this.mark(\"convexWebSocketOpen\");\n        this.webSocketManager.sendMessage({\n          ...reconnectMetadata,\n          type: \"Connect\",\n          sessionId: this.sessionId,\n          maxObservedTimestamp: this.maxObservedTimestamp,\n        });\n\n        // Throw out our remote query, reissue queries\n        // and outstanding mutations, and reauthenticate.\n        const oldRemoteQueryResults = new Set(\n          this.remoteQuerySet.remoteQueryResults().keys()\n        );\n        this.remoteQuerySet = new RemoteQuerySet((queryId) =>\n          this.state.queryPath(queryId)\n        );\n        const [querySetModification, authModification] = this.state.restart(\n          oldRemoteQueryResults\n        );\n        if (authModification) {\n          this.webSocketManager.sendMessage(authModification);\n        }\n        this.webSocketManager.sendMessage(querySetModification);\n        for (const message of this.requestManager.restart()) {\n          this.webSocketManager.sendMessage(message);\n        }\n      },\n      (serverMessage: ServerMessage) => {\n        // Metrics events grow linearly with reconnection attempts so this\n        // conditional prevents n^2 metrics reporting.\n        if (!this.firstMessageReceived) {\n          this.firstMessageReceived = true;\n          this.mark(\"convexFirstMessageReceived\");\n          this.reportMarks();\n        }\n        switch (serverMessage.type) {\n          case \"Transition\": {\n            this.observedTimestamp(serverMessage.endVersion.ts);\n            this.authenticationManager.onTransition(serverMessage);\n            this.remoteQuerySet.transition(serverMessage);\n            this.state.transition(serverMessage);\n            const completedRequests = this.requestManager.removeCompleted(\n              this.remoteQuerySet.timestamp()\n            );\n            this.notifyOnQueryResultChanges(completedRequests);\n            break;\n          }\n          case \"MutationResponse\": {\n            if (serverMessage.success) {\n              this.observedTimestamp(serverMessage.ts);\n            }\n            const completedMutationId =\n              this.requestManager.onResponse(serverMessage);\n            if (completedMutationId) {\n              this.notifyOnQueryResultChanges(new Set([completedMutationId]));\n            }\n            break;\n          }\n          case \"ActionResponse\": {\n            this.requestManager.onResponse(serverMessage);\n            break;\n          }\n          case \"AuthError\": {\n            this.authenticationManager.onAuthError(serverMessage);\n            break;\n          }\n          case \"FatalError\": {\n            const error = logFatalError(serverMessage.error);\n            void this.webSocketManager.stop();\n            throw error;\n          }\n          case \"Ping\":\n            break; // do nothing\n          default: {\n            const _typeCheck: never = serverMessage;\n          }\n        }\n\n        return {\n          hasSyncedPastLastReconnect: this.hasSyncedPastLastReconnect(),\n        };\n      },\n      webSocketConstructor,\n      this.verbose\n    );\n    this.mark(\"convexClientConstructed\");\n  }\n\n  /**\n   * Return true if there is outstanding work from prior to the time of the most recent restart.\n   * This indicates that the client has not proven itself to have gotten past the issue that\n   * potentially led to the restart. Use this to influence when to reset backoff after a failure.\n   */\n  private hasSyncedPastLastReconnect() {\n    const hasSyncedPastLastReconnect =\n      this.requestManager.hasSyncedPastLastReconnect() ||\n      this.state.hasSyncedPastLastReconnect();\n    return hasSyncedPastLastReconnect;\n  }\n\n  private observedTimestamp(observedTs: TS) {\n    if (\n      this.maxObservedTimestamp === undefined ||\n      this.maxObservedTimestamp.lessThanOrEqual(observedTs)\n    ) {\n      this.maxObservedTimestamp = observedTs;\n    }\n  }\n\n  getMaxObservedTimestamp() {\n    return this.maxObservedTimestamp;\n  }\n\n  /**\n   * Compute the current query results based on the remoteQuerySet and the\n   * current optimistic updates and call `onTransition` for all the changed\n   * queries.\n   *\n   * @param completedMutations - A set of mutation IDs whose optimistic updates\n   * are no longer needed.\n   */\n  private notifyOnQueryResultChanges(completedRequest: Set<RequestId>) {\n    const remoteQueryResults: Map<QueryId, FunctionResult> =\n      this.remoteQuerySet.remoteQueryResults();\n    const queryTokenToValue: QueryResultsMap = new Map();\n    for (const [queryId, result] of remoteQueryResults) {\n      const queryToken = this.state.queryToken(queryId);\n      // It's possible that we've already unsubscribed to this query but\n      // the server hasn't learned about that yet. If so, ignore this one.\n\n      if (queryToken !== null) {\n        const query = {\n          result,\n          udfPath: this.state.queryPath(queryId)!,\n          args: this.state.queryArgs(queryId)!,\n        };\n        queryTokenToValue.set(queryToken, query);\n      }\n    }\n\n    this.onTransition(\n      this.optimisticQueryResults.ingestQueryResultsFromServer(\n        queryTokenToValue,\n        completedRequest\n      )\n    );\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   * @param onChange - a callback that will be called when the authentication status changes\n   */\n  setAuth(\n    fetchToken: AuthTokenFetcher,\n    onChange: (isAuthenticated: boolean) => void\n  ) {\n    void this.authenticationManager.setConfig(fetchToken, onChange);\n  }\n\n  hasAuth() {\n    return this.state.hasAuth();\n  }\n\n  /** @internal */\n  setAdminAuth(value: string, fakeUserIdentity?: UserIdentityAttributes) {\n    const message = this.state.setAdminAuth(value, fakeUserIdentity);\n    this.webSocketManager.sendMessage(message);\n  }\n\n  clearAuth() {\n    const message = this.state.clearAuth();\n    this.webSocketManager.sendMessage(message);\n  }\n\n  /**\n   * Subscribe to a query function.\n   *\n   * Whenever this query's result changes, the `onTransition` callback\n   * passed into the constructor will be called.\n   *\n   * @param name - The name of the query.\n   * @param args - An arguments object for the query. If this is omitted, the\n   * arguments will be `{}`.\n   * @param options - A {@link SubscribeOptions} options object for this query.\n\n   * @returns An object containing a {@link QueryToken} corresponding to this\n   * query and an `unsubscribe` callback.\n   */\n  subscribe(\n    name: string,\n    args?: Record<string, Value>,\n    options?: SubscribeOptions\n  ): { queryToken: QueryToken; unsubscribe: () => void } {\n    const argsObject = parseArgs(args);\n\n    const { modification, queryToken, unsubscribe } = this.state.subscribe(\n      name,\n      argsObject,\n      options?.journal\n    );\n    if (modification !== null) {\n      this.webSocketManager.sendMessage(modification);\n    }\n    return {\n      queryToken,\n      unsubscribe: () => {\n        const modification = unsubscribe();\n        if (modification) {\n          this.webSocketManager.sendMessage(modification);\n        }\n      },\n    };\n  }\n\n  /**\n   * A query result based only on the current, local state.\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   */\n  localQueryResult(\n    udfPath: string,\n    args?: Record<string, Value>\n  ): Value | undefined {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(udfPath, argsObject);\n    return this.optimisticQueryResults.queryResult(queryToken);\n  }\n\n  /**\n   * Get query result by query token based on current, local state\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   *\n   * @internal\n   */\n  localQueryResultByToken(queryToken: QueryToken): Value | undefined {\n    return this.optimisticQueryResults.queryResult(queryToken);\n  }\n\n  /**\n   * Whether local query result is available for a toke.\n   *\n   * This method does not throw if the result is an error.\n   *\n   * @internal\n   */\n  hasLocalQueryResultByToken(queryToken: QueryToken): boolean {\n    return this.optimisticQueryResults.hasQueryResult(queryToken);\n  }\n\n  /**\n   * @internal\n   */\n  localQueryLogs(\n    udfPath: string,\n    args?: Record<string, Value>\n  ): string[] | undefined {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(udfPath, argsObject);\n    return this.optimisticQueryResults.queryLogs(queryToken);\n  }\n\n  /**\n   * Retrieve the current {@link QueryJournal} for this query function.\n   *\n   * If we have not yet received a result for this query, this will be `undefined`.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for this query.\n   * @returns The query's {@link QueryJournal} or `undefined`.\n   */\n  queryJournal(\n    name: string,\n    args?: Record<string, Value>\n  ): QueryJournal | undefined {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(name, argsObject);\n    return this.state.queryJournal(queryToken);\n  }\n\n  /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */\n  connectionState(): ConnectionState {\n    return {\n      hasInflightRequests: this.requestManager.hasInflightRequests(),\n      isWebSocketConnected: this.webSocketManager.socketState() === \"ready\",\n      timeOfOldestInflightRequest:\n        this.requestManager.timeOfOldestInflightRequest(),\n    };\n  }\n\n  /**\n   * Execute a mutation function.\n   *\n   * @param name - The name of the mutation.\n   * @param args - An arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - A {@link MutationOptions} options object for this mutation.\n\n   * @returns - A promise of the mutation's result.\n   */\n  async mutation(\n    name: string,\n    args?: Record<string, Value>,\n    options?: MutationOptions\n  ): Promise<any> {\n    const result = await this.mutationInternal(name, args, options);\n    if (!result.success) {\n      if (result.errorData !== undefined) {\n        throw forwardData(\n          result,\n          new ConvexError(createHybridErrorStacktrace(\"mutation\", name, result))\n        );\n      }\n      throw new Error(createHybridErrorStacktrace(\"mutation\", name, result));\n    }\n    return result.value;\n  }\n\n  /**\n   * @internal\n   */\n  async mutationInternal(\n    udfPath: string,\n    args?: Record<string, Value>,\n    options?: MutationOptions\n  ): Promise<FunctionResult> {\n    const mutationArgs = parseArgs(args);\n    this.tryReportLongDisconnect();\n    const requestId = this.nextRequestId;\n    this.nextRequestId++;\n\n    if (options !== undefined) {\n      const optimisticUpdate = options.optimisticUpdate;\n      if (optimisticUpdate !== undefined) {\n        const wrappedUpdate = (localQueryStore: OptimisticLocalStore) => {\n          optimisticUpdate(localQueryStore, mutationArgs);\n        };\n\n        const changedQueries =\n          this.optimisticQueryResults.applyOptimisticUpdate(\n            wrappedUpdate,\n            requestId\n          );\n        this.onTransition(changedQueries);\n      }\n    }\n\n    const message: MutationRequest = {\n      type: \"Mutation\",\n      requestId,\n      udfPath,\n      args: [convexToJson(mutationArgs)],\n    };\n    const mightBeSent = this.webSocketManager.sendMessage(message);\n    return this.requestManager.request(message, mightBeSent);\n  }\n\n  /**\n   * Execute an action function.\n   *\n   * @param name - The name of the action.\n   * @param args - An arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  async action(name: string, args?: Record<string, Value>): Promise<any> {\n    const result = await this.actionInternal(name, args);\n    if (!result.success) {\n      if (result.errorData !== undefined) {\n        throw forwardData(\n          result,\n          new ConvexError(createHybridErrorStacktrace(\"action\", name, result))\n        );\n      }\n      throw new Error(createHybridErrorStacktrace(\"action\", name, result));\n    }\n    return result.value;\n  }\n\n  /**\n   * @internal\n   */\n  async actionInternal(\n    udfPath: string,\n    args?: Record<string, Value>\n  ): Promise<FunctionResult> {\n    const actionArgs = parseArgs(args);\n    const requestId = this.nextRequestId;\n    this.nextRequestId++;\n    this.tryReportLongDisconnect();\n\n    const message: ActionRequest = {\n      type: \"Action\",\n      requestId,\n      udfPath,\n      args: [convexToJson(actionArgs)],\n    };\n\n    const mightBeSent = this.webSocketManager.sendMessage(message);\n    return this.requestManager.request(message, mightBeSent);\n  }\n\n  /**\n   * Close any network handles associated with this client and stop all subscriptions.\n   *\n   * Call this method when you're done with an {@link BaseConvexClient} to\n   * dispose of its sockets and resources.\n   *\n   * @returns A `Promise` fulfilled when the connection has been completely closed.\n   */\n  async close(): Promise<void> {\n    this.authenticationManager.stop();\n    return this.webSocketManager.stop();\n  }\n\n  private _logVerbose(message: string) {\n    if (this.verbose) {\n      console.debug(`${new Date().toISOString()} ${message}`);\n    }\n  }\n\n  // Instance property so that `mark()` doesn't need to be called as a method.\n  private mark = (name: MarkName) => {\n    if (this.debug) {\n      mark(name, this.sessionId);\n    }\n  };\n\n  /**\n   * Reports performance marks to the server. This should only be called when\n   * we have a functional websocket.\n   */\n  private reportMarks() {\n    if (this.debug) {\n      const report = getMarksReport(this.sessionId);\n      this.webSocketManager.sendMessage({\n        type: \"Event\",\n        eventType: \"ClientConnect\",\n        event: report,\n      });\n    }\n  }\n\n  private tryReportLongDisconnect() {\n    if (!this.debug) {\n      return;\n    }\n    const timeOfOldestRequest =\n      this.connectionState().timeOfOldestInflightRequest;\n    if (\n      timeOfOldestRequest === null ||\n      Date.now() - timeOfOldestRequest.getTime() <= 60 * 1000\n    ) {\n      return;\n    }\n    const endpoint = `${this.address}/api/debug_event`;\n    fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      },\n      body: JSON.stringify({ event: \"LongWebsocketDisconnect\" }),\n    })\n      .then((response) => {\n        if (!response.ok) {\n          console.warn(\n            \"Analytics request failed with response:\",\n            response.body\n          );\n        }\n      })\n      .catch((error) => {\n        console.warn(\"Analytics response failed with error:\", error);\n      });\n  }\n}\n"],
  "mappings": "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",
  "names": ["modification"]
}
