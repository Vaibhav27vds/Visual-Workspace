{
  "version": 3,
  "sources": ["../../../../src/browser/sync/web_socket_manager.ts"],
  "sourcesContent": ["import {\n  ClientMessage,\n  encodeClientMessage,\n  parseServerMessage,\n  ServerMessage,\n} from \"./protocol.js\";\n\nconst CLOSE_NORMAL = 1000;\nconst CLOSE_GOING_AWAY = 1001;\nconst CLOSE_NO_STATUS = 1005;\n/** Convex-specific close code representing a \"404 Not Found\".\n * The edge Onramp accepts websocket upgrades before confirming that the\n * intended destination exists, so this code is sent once we've discovered that\n * the destination does not exist.\n */\nconst CLOSE_NOT_FOUND = 4040;\n\n/**\n * The various states our WebSocket can be in:\n *\n * - \"disconnected\": We don't have a WebSocket, but plan to create one.\n * - \"connecting\": We have created the WebSocket and are waiting for the\n *   `onOpen` callback.\n * - \"ready\": We have an open WebSocket.\n * - \"paused\": The WebSocket was stopped and a new one can be created via `.resume()`.\n * - \"stopped\": We have stopped the WebSocket and will never create a new one.\n *\n *\n * WebSocket State Machine\n * -----------------------\n * initialState: disconnected\n * validTransitions:\n *   disconnected:\n *     new WebSocket() -> connecting\n *     stop() -> stopped\n *   connecting:\n *     onopen -> ready\n *     close() -> disconnected\n *     stop() -> stopped\n *   ready:\n *     close() -> disconnected\n *     pause() -> paused\n *     stop() -> stopped\n *   paused:\n *     resume() -> connecting\n *     stop() -> stopped\n *   stopping:\n *     onclose -> stopped\n * terminalStates:\n *   stopped\n *\n *\n *\n *                                        \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *                \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500stop()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502  disconnected  \u2502\u25C0\u2500\u2510\n *                \u2502                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n *                \u25BC                            \u2502       \u25B2      \u2502\n *       \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           new WebSocket()  \u2502      \u2502\n *    \u250C\u2500\u25B6\u2502    stopped     \u2502\u25C0\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502       \u2502      \u2502\n *    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502            \u2502       \u2502      \u2502\n *    \u2502           \u25B2            stop()          \u2502    close() close()\n *    \u2502         stop()            \u2502            \u2502       \u2502      \u2502\n *    \u2502           \u2502               \u2502            \u25BC       \u2502      \u2502\n *    \u2502  \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n *    \u2502  \u2502     paused     \u2502\u2500\u2500\u2500resume()\u2500\u2500\u2500\u25B6\u2502   connecting   \u2502  \u2502\n *    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n *    \u2502           \u25B2                                \u2502          \u2502\n *    \u2502           \u2502                               onopen      \u2502\n *    \u2502           \u2502                                \u2502          \u2502\n *    \u2502           \u2502                                \u25BC          \u2502\n * stop()         \u2502                       \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n *    \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500pause()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502     ready      \u2502\u2500\u2500\u2518\n *    \u2502                                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *    \u2502                                            \u2502\n *    \u2502                                            \u2502\n *    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n */\n\ntype Socket =\n  | { state: \"disconnected\" }\n  | { state: \"connecting\"; ws: WebSocket }\n  | { state: \"ready\"; ws: WebSocket }\n  | { state: \"paused\" }\n  | { state: \"stopped\" };\n\nexport type ReconnectMetadata = {\n  connectionCount: number;\n  lastCloseReason: string | null;\n};\n\nexport type OnMessageResponse = {\n  hasSyncedPastLastReconnect: boolean;\n};\n\n/**\n * A wrapper around a websocket that handles errors, reconnection, and message\n * parsing.\n */\nexport class WebSocketManager {\n  private socket: Socket;\n\n  private connectionCount: number;\n  private lastCloseReason: string | null;\n\n  /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */\n  private readonly initialBackoff: number;\n\n  /** We backoff exponentially, but we need to cap that--this is the jittered max. */\n  private readonly maxBackoff: number;\n\n  /** How many times have we failed consecutively? */\n  private retries: number;\n\n  /** How long before lack of server response causes us to initiate a reconnect,\n   * in ms */\n  private readonly serverInactivityThreshold: number;\n\n  private reconnectDueToServerInactivityTimeout: ReturnType<\n    typeof setTimeout\n  > | null;\n\n  private readonly uri: string;\n  private readonly onOpen: (reconnectMetadata: ReconnectMetadata) => void;\n  private readonly onMessage: (message: ServerMessage) => OnMessageResponse;\n  private readonly webSocketConstructor: typeof WebSocket;\n  private readonly verbose: boolean;\n\n  constructor(\n    uri: string,\n    onOpen: (reconnectMetadata: ReconnectMetadata) => void,\n    onMessage: (message: ServerMessage) => OnMessageResponse,\n    webSocketConstructor: typeof WebSocket,\n    verbose: boolean\n  ) {\n    this.webSocketConstructor = webSocketConstructor;\n    this.socket = { state: \"disconnected\" };\n    this.connectionCount = 0;\n    this.lastCloseReason = \"InitialConnect\";\n\n    this.initialBackoff = 100;\n    this.maxBackoff = 16000;\n    this.retries = 0;\n\n    this.serverInactivityThreshold = 30000;\n    this.reconnectDueToServerInactivityTimeout = null;\n\n    this.uri = uri;\n    this.onOpen = onOpen;\n    this.onMessage = onMessage;\n    this.verbose = verbose;\n\n    // Kick off connection but don't wait for it.\n    void this.connect();\n  }\n\n  private connect() {\n    if (this.socket.state === \"stopped\") {\n      return;\n    }\n    if (\n      this.socket.state !== \"disconnected\" &&\n      this.socket.state !== \"paused\"\n    ) {\n      throw new Error(\n        \"Didn't start connection from disconnected state: \" + this.socket.state\n      );\n    }\n\n    const ws = new this.webSocketConstructor(this.uri);\n    this._logVerbose(\"constructed WebSocket\");\n    this.socket = {\n      state: \"connecting\",\n      ws,\n    };\n\n    // Kick off server inactivity timer before WebSocket connection is established\n    // so we can detect cases where handshake fails.\n    // The `onopen` event only fires after the connection is established:\n    // Source: https://datatracker.ietf.org/doc/html/rfc6455#page-19:~:text=_The%20WebSocket%20Connection%20is%20Established_,-and\n    this.resetServerInactivityTimeout();\n\n    ws.onopen = () => {\n      this._logVerbose(\"begin ws.onopen\");\n      if (this.socket.state !== \"connecting\") {\n        throw new Error(\"onopen called with socket not in connecting state\");\n      }\n      this.socket = { state: \"ready\", ws };\n      this.resetServerInactivityTimeout();\n      this.onOpen({\n        connectionCount: this.connectionCount,\n        lastCloseReason: this.lastCloseReason,\n      });\n\n      if (this.lastCloseReason !== \"InitialConnect\") {\n        console.log(\"WebSocket reconnected\");\n      }\n\n      this.connectionCount += 1;\n      this.lastCloseReason = null;\n    };\n    // NB: The WebSocket API calls `onclose` even if connection fails, so we can route all error paths through `onclose`.\n    ws.onerror = (error) => {\n      const message = (error as ErrorEvent).message;\n      console.log(`WebSocket error: ${message}`);\n    };\n    ws.onmessage = (message) => {\n      this.resetServerInactivityTimeout();\n      const serverMessage = parseServerMessage(JSON.parse(message.data));\n      this._logVerbose(`received ws message with type ${serverMessage.type}`);\n      const response = this.onMessage(serverMessage);\n      if (response.hasSyncedPastLastReconnect) {\n        // Reset backoff to 0 once all outstanding requests are complete.\n        this.retries = 0;\n      }\n    };\n    ws.onclose = (event) => {\n      this._logVerbose(\"begin ws.onclose\");\n      if (this.lastCloseReason === null) {\n        this.lastCloseReason = event.reason ?? \"OnCloseInvoked\";\n      }\n      if (\n        event.code !== CLOSE_NORMAL &&\n        event.code !== CLOSE_GOING_AWAY && // This commonly gets fired on mobile apps when the app is backgrounded\n        event.code !== CLOSE_NO_STATUS &&\n        event.code !== CLOSE_NOT_FOUND // Note that we want to retry on a 404, as it can be transient during a push.\n      ) {\n        let msg = `WebSocket closed with code ${event.code}`;\n        if (event.reason) {\n          msg += `: ${event.reason}`;\n        }\n        console.log(msg);\n      }\n      this.scheduleReconnect();\n      return;\n    };\n  }\n\n  /**\n   * @returns The state of the {@link Socket}.\n   */\n  socketState(): string {\n    return this.socket.state;\n  }\n\n  /**\n   * @param message - A ClientMessage to send.\n   * @returns Whether the message (might have been) sent.\n   */\n  sendMessage(message: ClientMessage) {\n    this._logVerbose(`sending message with type ${message.type}`);\n\n    if (this.socket.state === \"ready\") {\n      const encodedMessage = encodeClientMessage(message);\n      const request = JSON.stringify(encodedMessage);\n      try {\n        this.socket.ws.send(request);\n      } catch (error: any) {\n        console.log(\n          `Failed to send message on WebSocket, reconnecting: ${error}`\n        );\n        this.closeAndReconnect(\"FailedToSendMessage\");\n      }\n      // We are not sure if this was sent or not.\n      return true;\n    }\n    return false;\n  }\n\n  private resetServerInactivityTimeout() {\n    if (this.socket.state !== \"stopped\") {\n      // Don't reset any timers if we were trying to stop.\n      return;\n    }\n    if (this.reconnectDueToServerInactivityTimeout !== null) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n      this.reconnectDueToServerInactivityTimeout = null;\n    }\n    this.reconnectDueToServerInactivityTimeout = setTimeout(() => {\n      this.closeAndReconnect(\"InactiveServer\");\n    }, this.serverInactivityThreshold);\n  }\n\n  private scheduleReconnect() {\n    this.socket = { state: \"disconnected\" };\n    const backoff = this.nextBackoff();\n    console.log(`Attempting reconnect in ${backoff}ms`);\n    setTimeout(() => this.connect(), backoff);\n  }\n\n  /**\n   * Close the WebSocket and schedule a reconnect.\n   *\n   * This should be used when we hit an error and would like to restart the session.\n   */\n  private closeAndReconnect(closeReason: string) {\n    this._logVerbose(`begin closeAndReconnect with reason ${closeReason}`);\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"stopped\":\n      case \"paused\":\n        // Nothing to do if we don't have a WebSocket.\n        return;\n      case \"connecting\":\n      case \"ready\": {\n        this.lastCloseReason = closeReason;\n        this.close();\n        this.scheduleReconnect();\n        return;\n      }\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        // eslint-disable-next-line  @typescript-eslint/no-unused-vars\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  /**\n   * Close the WebSocket, being careful to clear the onclose handler to avoid re-entrant\n   * calls. Use this instead of directly calling `ws.close()`\n   */\n  private close() {\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"stopped\":\n      case \"paused\":\n        // Nothing to do if we don't have a WebSocket.\n        return;\n      case \"connecting\":\n      case \"ready\": {\n        this.socket.ws.onclose = () => {\n          // Set onclose to no-op so we don't re-entrantly call the onclose handler\n        };\n        this._logVerbose(\"ws.close called\");\n        this.socket.ws.close();\n        return;\n      }\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        // eslint-disable-next-line  @typescript-eslint/no-unused-vars\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  /**\n   * Close the WebSocket and do not reconnect.\n   * @returns A Promise that resolves when the WebSocket `onClose` callback is called.\n   */\n  stop(): Promise<void> {\n    if (this.reconnectDueToServerInactivityTimeout) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n    }\n    switch (this.socket.state) {\n      case \"stopped\":\n      case \"paused\":\n      case \"disconnected\":\n      case \"connecting\":\n      case \"ready\":\n        this.close();\n        if (\n          this.socket.state === \"ready\" ||\n          this.socket.state === \"connecting\"\n        ) {\n          const ws = this.socket.ws;\n          this.socket = { state: \"stopped\" };\n          return new Promise((r) => {\n            ws.onclose = (_event: CloseEvent) => r();\n          });\n        }\n        this.socket = { state: \"stopped\" };\n        return Promise.resolve();\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n        throw new Error(\n          `Invalid websocket state: ${(this.socket as any).state}`\n        );\n      }\n    }\n  }\n\n  pause(): void {\n    switch (this.socket.state) {\n      case \"stopped\":\n        // If we're stopping we ignore pause\n        return;\n      case \"paused\":\n      case \"disconnected\":\n      case \"connecting\":\n      case \"ready\":\n        this.close();\n        this.socket = {\n          state: \"paused\",\n        };\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  /**\n   * Create a new WebSocket after a previous `pause()`, unless `stop()` was\n   * called before.\n   */\n  resume(): void {\n    switch (this.socket.state) {\n      case \"paused\":\n        break;\n      case \"stopped\":\n        // If we're stopping we ignore resume\n        return;\n      case \"connecting\":\n      case \"ready\":\n      case \"disconnected\":\n        throw new Error(\"`resume()` is only valid after `pause()`\");\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n    this.connect();\n  }\n\n  private _logVerbose(message: string) {\n    if (this.verbose) {\n      console.debug(`${new Date().toISOString()} ${message}`);\n    }\n  }\n\n  private nextBackoff(): number {\n    const baseBackoff = this.initialBackoff * Math.pow(2, this.retries);\n    this.retries += 1;\n    const actualBackoff = Math.min(baseBackoff, this.maxBackoff);\n    const jitter = actualBackoff * (Math.random() - 0.5);\n    return actualBackoff + jitter;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
