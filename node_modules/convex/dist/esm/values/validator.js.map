{
  "version": 3,
  "sources": ["../../../src/values/validator.ts"],
  "sourcesContent": ["import { JSONValue, convexToJson, Id as GenericId } from \"./value.js\";\nimport { Expand } from \"../type_utils.js\";\n\n/**\n * A validator for a Convex value.\n *\n * This should be constructed using the validator builder, {@link v}.\n *\n * This class encapsulates:\n * - The TypeScript type of this value.\n * - Whether this field should be optional if it's included in an object.\n * - The TypeScript type for the set of index field paths that can be used to\n * build indexes on this value.\n * - A JSON representation of the validator.\n * @public\n */\nexport class Validator<\n  TypeScriptType,\n  IsOptional extends boolean = false,\n  FieldPaths extends string = never\n> {\n  readonly type!: TypeScriptType;\n  readonly isOptional!: IsOptional;\n  readonly fieldPaths!: FieldPaths;\n\n  // Property for a bit of nominal type safety.\n  readonly _isValidator: undefined;\n\n  readonly optional: boolean;\n  /**\n   * @internal\n   */\n  readonly json: ValidatorJSON;\n  /**\n   * @internal\n   */\n  constructor(json: ValidatorJSON, optional: boolean) {\n    this.json = json;\n    this.optional = optional;\n  }\n}\n\n/**\n * @internal\n */\nexport type ObjectFieldType = { fieldType: ValidatorJSON; optional: boolean };\n\n/**\n * @internal\n */\nexport type ValidatorJSON =\n  | {\n      type: \"null\";\n    }\n  | { type: \"number\" }\n  | { type: \"bigint\" }\n  | { type: \"boolean\" }\n  | { type: \"string\" }\n  | { type: \"bytes\" }\n  | { type: \"any\" }\n  | {\n      type: \"literal\";\n      value: JSONValue;\n    }\n  | { type: \"id\"; tableName: string }\n  | { type: \"array\"; value: ValidatorJSON }\n  | { type: \"record\"; keys: ValidatorJSON; values: ObjectFieldType }\n  | { type: \"object\"; value: Record<string, ObjectFieldType> }\n  | { type: \"union\"; value: ValidatorJSON[] };\n\n/**\n * The validator builder.\n *\n * This builder allows you to build validators for Convex values.\n *\n * Validators can be used in [schema definitions](https://docs.convex.dev/database/schemas)\n * and as input validators for Convex functions.\n *\n * @public\n */\nexport const v = {\n  id<TableName extends string>(\n    tableName: TableName\n  ): Validator<GenericId<TableName>> {\n    return new Validator({ type: \"id\", tableName }, false);\n  },\n  null(): Validator<null> {\n    return new Validator({ type: \"null\" }, false);\n  },\n  /**\n   * Alias for `v.float64()`\n   */\n  number(): Validator<number> {\n    return new Validator({ type: \"number\" }, false);\n  },\n  float64(): Validator<number> {\n    return new Validator({ type: \"number\" }, false);\n  },\n  /**\n   * @deprecated Use `v.int64()` instead\n   */\n  bigint(): Validator<bigint> {\n    return new Validator({ type: \"bigint\" }, false);\n  },\n  int64(): Validator<bigint> {\n    return new Validator({ type: \"bigint\" }, false);\n  },\n  boolean(): Validator<boolean> {\n    return new Validator({ type: \"boolean\" }, false);\n  },\n  string(): Validator<string> {\n    return new Validator({ type: \"string\" }, false);\n  },\n  bytes(): Validator<ArrayBuffer> {\n    return new Validator({ type: \"bytes\" }, false);\n  },\n  literal<T extends string | number | bigint | boolean>(\n    literal: T\n  ): Validator<T> {\n    const value = convexToJson(literal);\n    return new Validator({ type: \"literal\", value }, false);\n  },\n  array<T>(values: Validator<T, false, any>): Validator<T[]> {\n    return new Validator({ type: \"array\", value: values.json }, false);\n  },\n  object<T extends PropertyValidators>(schema: T): ObjectValidator<T> {\n    return new Validator(\n      {\n        type: \"object\",\n        value: Object.fromEntries(\n          Object.entries(schema).map(([k, v]) => [\n            k,\n            { fieldType: v.json, optional: v.optional },\n          ])\n        ),\n      },\n      false\n    );\n  },\n\n  /** @internal */\n  record<K extends string, ValueValidator extends Validator<any, any, any>>(\n    keys: Validator<K, false, any>,\n    values: ValueValidator\n  ): RecordValidator<K, ValueValidator> {\n    return new Validator(\n      {\n        type: \"record\",\n        keys: keys.json,\n        values: { fieldType: values.json, optional: values.optional },\n      },\n      false\n    );\n  },\n\n  union<\n    T extends [\n      Validator<any, false, any>,\n      Validator<any, false, any>,\n      ...Validator<any, false, any>[]\n    ]\n  >(\n    ...schemaTypes: T\n  ): Validator<T[number][\"type\"], false, T[number][\"fieldPaths\"]> {\n    return new Validator(\n      {\n        type: \"union\",\n        value: schemaTypes.map((t) => t.json),\n      },\n      false\n    );\n  },\n  any(): Validator<any, false, string> {\n    return new Validator({ type: \"any\" }, false);\n  },\n  optional<T extends Validator<any, false, any>>(\n    inner: T\n  ): Validator<T[\"type\"] | undefined, true, T[\"fieldPaths\"]> {\n    return new Validator(inner.json, true) as Validator<\n      T[\"type\"],\n      true,\n      T[\"fieldPaths\"]\n    >;\n  },\n};\n\n/**\n * Validators for each property of an object.\n *\n * This is represented as an object mapping the property name to its\n * {@link Validator}.\n *\n * @public\n */\nexport type PropertyValidators = Record<string, Validator<any, any, any>>;\n\n/**\n * Compute the type of an object from {@link PropertyValidators}.\n *\n * @public\n */\nexport type ObjectType<Validators extends PropertyValidators> = Expand<\n  // Map each key to the corresponding property validator's type making\n  // the optional ones optional.\n  {\n    [Property in OptionalKeys<Validators>]?: Validators[Property][\"type\"];\n  } & {\n    [Property in RequiredKeys<Validators>]: Validators[Property][\"type\"];\n  }\n>;\n\n/**\n * Calculate the type of a {@link Validator} for an object.\n *\n * This is used within the validator builder, {@link v}.\n */\nexport type ObjectValidator<Validators extends PropertyValidators> = Validator<\n  // Compute the TypeScript type this validator refers to.\n  ObjectType<Validators>,\n  false,\n  // Compute the field paths for this validator. For every property in the object,\n  // add on a field path for that property and extend all the field paths in the\n  // validator.\n  {\n    [Property in keyof Validators]:\n      | JoinFieldPaths<Property & string, Validators[Property][\"fieldPaths\"]>\n      | Property;\n  }[keyof Validators] &\n    string\n>;\n\ntype OptionalKeys<\n  PropertyValidators extends Record<string, Validator<any, any, any>>\n> = {\n  [Property in keyof PropertyValidators]: PropertyValidators[Property][\"isOptional\"] extends true\n    ? Property\n    : never;\n}[keyof PropertyValidators];\n\ntype RequiredKeys<\n  PropertyValidators extends Record<string, Validator<any, any, any>>\n> = Exclude<keyof PropertyValidators, OptionalKeys<PropertyValidators>>;\n\n/**\n * Calculate the type of a {@link Validator} for an object that produces indexed types.\n *\n * If the value validator is not optional, it produces a `Record` type, which is an alias\n * for `{[key: K]: V}`.\n *\n * If the value validator is optional, it produces a mapped object type,\n * with optional keys: `{[key in K]?: V}`.\n *\n * This is used within the validator builder, {@link v}.\n */\nexport type RecordValidator<\n  K extends string,\n  ValueValidator extends Validator<any, any, any>\n> = Validator<\n  ValueValidator[\"isOptional\"] extends true\n    ? { [key in K]?: ValueValidator[\"type\"] }\n    : Record<K, ValueValidator[\"type\"]>\n>;\n\n/**\n * Join together two index field paths.\n *\n * This is used within the validator builder, {@link v}.\n * @public\n */\ntype JoinFieldPaths<\n  Start extends string,\n  End extends string\n> = `${Start}.${End}`;\n\n/**\n * Extract a TypeScript type from a validator.\n *\n * Example usage:\n * ```ts\n * const objectSchema = v.object({\n *   property: v.string(),\n * });\n * type MyObject = Infer<typeof objectSchema>; // { property: string }\n * ```\n * @typeParam V - The type of a {@link Validator} constructed with {@link v}.\n *\n * @public\n */\nexport type Infer<V extends Validator<any, any, any>> = V[\"type\"];\n"],
  "mappings": ";AAAA,SAAoB,oBAAqC;AAgBlD,aAAM,UAIX;AAAA;AAAA;AAAA;AAAA,EAgBA,YAAY,MAAqB,UAAmB;AAClD,SAAK,OAAO;AACZ,SAAK,WAAW;AAAA,EAClB;AACF;AAwCO,aAAM,IAAI;AAAA,EACf,GACE,WACiC;AACjC,WAAO,IAAI,UAAU,EAAE,MAAM,MAAM,UAAU,GAAG,KAAK;AAAA,EACvD;AAAA,EACA,OAAwB;AACtB,WAAO,IAAI,UAAU,EAAE,MAAM,OAAO,GAAG,KAAK;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAIA,SAA4B;AAC1B,WAAO,IAAI,UAAU,EAAE,MAAM,SAAS,GAAG,KAAK;AAAA,EAChD;AAAA,EACA,UAA6B;AAC3B,WAAO,IAAI,UAAU,EAAE,MAAM,SAAS,GAAG,KAAK;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAIA,SAA4B;AAC1B,WAAO,IAAI,UAAU,EAAE,MAAM,SAAS,GAAG,KAAK;AAAA,EAChD;AAAA,EACA,QAA2B;AACzB,WAAO,IAAI,UAAU,EAAE,MAAM,SAAS,GAAG,KAAK;AAAA,EAChD;AAAA,EACA,UAA8B;AAC5B,WAAO,IAAI,UAAU,EAAE,MAAM,UAAU,GAAG,KAAK;AAAA,EACjD;AAAA,EACA,SAA4B;AAC1B,WAAO,IAAI,UAAU,EAAE,MAAM,SAAS,GAAG,KAAK;AAAA,EAChD;AAAA,EACA,QAAgC;AAC9B,WAAO,IAAI,UAAU,EAAE,MAAM,QAAQ,GAAG,KAAK;AAAA,EAC/C;AAAA,EACA,QACE,SACc;AACd,UAAM,QAAQ,aAAa,OAAO;AAClC,WAAO,IAAI,UAAU,EAAE,MAAM,WAAW,MAAM,GAAG,KAAK;AAAA,EACxD;AAAA,EACA,MAAS,QAAkD;AACzD,WAAO,IAAI,UAAU,EAAE,MAAM,SAAS,OAAO,OAAO,KAAK,GAAG,KAAK;AAAA,EACnE;AAAA,EACA,OAAqC,QAA+B;AAClE,WAAO,IAAI;AAAA,MACT;AAAA,QACE,MAAM;AAAA,QACN,OAAO,OAAO;AAAA,UACZ,OAAO,QAAQ,MAAM,EAAE,IAAI,CAAC,CAAC,GAAGA,EAAC,MAAM;AAAA,YACrC;AAAA,YACA,EAAE,WAAWA,GAAE,MAAM,UAAUA,GAAE,SAAS;AAAA,UAC5C,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,OACE,MACA,QACoC;AACpC,WAAO,IAAI;AAAA,MACT;AAAA,QACE,MAAM;AAAA,QACN,MAAM,KAAK;AAAA,QACX,QAAQ,EAAE,WAAW,OAAO,MAAM,UAAU,OAAO,SAAS;AAAA,MAC9D;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,SAOK,aAC2D;AAC9D,WAAO,IAAI;AAAA,MACT;AAAA,QACE,MAAM;AAAA,QACN,OAAO,YAAY,IAAI,CAAC,MAAM,EAAE,IAAI;AAAA,MACtC;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EACA,MAAqC;AACnC,WAAO,IAAI,UAAU,EAAE,MAAM,MAAM,GAAG,KAAK;AAAA,EAC7C;AAAA,EACA,SACE,OACyD;AACzD,WAAO,IAAI,UAAU,MAAM,MAAM,IAAI;AAAA,EAKvC;AACF;",
  "names": ["v"]
}
