"use strict";
var convex = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // browser-bundle.js
  var browser_bundle_exports = {};
  __export(browser_bundle_exports, {
    BaseConvexClient: () => BaseConvexClient,
    ConvexClient: () => ConvexClient,
    ConvexHttpClient: () => ConvexHttpClient,
    anyApi: () => anyApi
  });

  // src/index.ts
  var version = "1.8.0";

  // src/values/base64.ts
  var base64_exports = {};
  __export(base64_exports, {
    byteLength: () => byteLength,
    fromByteArray: () => fromByteArray,
    toByteArray: () => toByteArray
  });
  var lookup = [];
  var revLookup = [];
  var Arr = Uint8Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  var i;
  var len;
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(_b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(
        encodeChunk(
          uint8,
          i,
          i + maxChunkLength > len2 ? len2 : i + maxChunkLength
        )
      );
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }

  // src/common/index.ts
  function parseArgs(args) {
    if (args === void 0) {
      return {};
    }
    if (!isSimpleObject(args)) {
      throw new Error(
        `The arguments to a Convex function must be an object. Received: ${args}`
      );
    }
    return args;
  }
  function validateDeploymentUrl(deploymentUrl) {
    if (typeof deploymentUrl === "undefined") {
      throw new Error(
        `Client created with undefined deployment address. If you used an environment variable, check that it's set.`
      );
    }
    if (typeof deploymentUrl !== "string") {
      throw new Error(
        `Invalid deployment address: found ${deploymentUrl}".`
      );
    }
    if (!(deploymentUrl.startsWith("http:") || deploymentUrl.startsWith("https:"))) {
      throw new Error(
        `Invalid deployment address: Must start with "https://" or "http://". Found "${deploymentUrl}".`
      );
    }
    if (deploymentUrl.indexOf("127.0.0.1") !== -1 || deploymentUrl.indexOf("localhost") !== -1) {
      return;
    }
    if (!deploymentUrl.endsWith(".convex.cloud")) {
      throw new Error(
        `Invalid deployment address: Must end with ".convex.cloud". Found "${deploymentUrl}".`
      );
    }
  }
  function isSimpleObject(value) {
    const isObject = typeof value === "object";
    const prototype = Object.getPrototypeOf(value);
    const isSimple = prototype === null || prototype === Object.prototype || // Objects generated from other contexts (e.g. across Node.js `vm` modules) will not satisfy the previous
    // conditions but are still simple objects.
    prototype?.constructor?.name === "Object";
    return isObject && isSimple;
  }

  // src/values/value.ts
  var LITTLE_ENDIAN = true;
  var MIN_INT64 = BigInt("-9223372036854775808");
  var MAX_INT64 = BigInt("9223372036854775807");
  var ZERO = BigInt("0");
  var EIGHT = BigInt("8");
  var TWOFIFTYSIX = BigInt("256");
  function isSpecial(n2) {
    return Number.isNaN(n2) || !Number.isFinite(n2) || Object.is(n2, -0);
  }
  function slowBigIntToBase64(value) {
    if (value < ZERO) {
      value -= MIN_INT64 + MIN_INT64;
    }
    let hex = value.toString(16);
    if (hex.length % 2 === 1)
      hex = "0" + hex;
    const bytes = new Uint8Array(new ArrayBuffer(8));
    let i = 0;
    for (const hexByte of hex.match(/.{2}/g).reverse()) {
      bytes.set([parseInt(hexByte, 16)], i++);
      value >>= EIGHT;
    }
    return fromByteArray(bytes);
  }
  function slowBase64ToBigInt(encoded) {
    const integerBytes = toByteArray(encoded);
    if (integerBytes.byteLength !== 8) {
      throw new Error(
        `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`
      );
    }
    let value = ZERO;
    let power = ZERO;
    for (const byte of integerBytes) {
      value += BigInt(byte) * TWOFIFTYSIX ** power;
      power++;
    }
    if (value > MAX_INT64) {
      value += MIN_INT64 + MIN_INT64;
    }
    return value;
  }
  function modernBigIntToBase64(value) {
    if (value < MIN_INT64 || MAX_INT64 < value) {
      throw new Error(
        `BigInt ${value} does not fit into a 64-bit signed integer.`
      );
    }
    const buffer = new ArrayBuffer(8);
    new DataView(buffer).setBigInt64(0, value, true);
    return fromByteArray(new Uint8Array(buffer));
  }
  function modernBase64ToBigInt(encoded) {
    const integerBytes = toByteArray(encoded);
    if (integerBytes.byteLength !== 8) {
      throw new Error(
        `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`
      );
    }
    const intBytesView = new DataView(integerBytes.buffer);
    return intBytesView.getBigInt64(0, true);
  }
  var bigIntToBase64 = DataView.prototype.setBigInt64 ? modernBigIntToBase64 : slowBigIntToBase64;
  var base64ToBigInt = DataView.prototype.getBigInt64 ? modernBase64ToBigInt : slowBase64ToBigInt;
  var MAX_IDENTIFIER_LEN = 1024;
  function validateObjectField(k) {
    if (k.length === 0) {
      throw new Error("Empty field names are disallowed.");
    }
    if (k.length > MAX_IDENTIFIER_LEN) {
      throw new Error(
        `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`
      );
    }
    if (k.startsWith("$")) {
      throw new Error(`Field name ${k} starts with a '$', which is reserved.`);
    }
    for (let i = 0; i < k.length; i += 1) {
      const charCode = k.charCodeAt(i);
      if (charCode < 32 || charCode >= 127) {
        throw new Error(
          `Field name ${k} has invalid character '${k[i]}': Field names can only contain non-control ASCII characters`
        );
      }
    }
  }
  function jsonToConvexInternal(value, allowMapsAndSets) {
    if (value === null) {
      return value;
    }
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "string") {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map((value2) => jsonToConvexInternal(value2, allowMapsAndSets));
    }
    if (typeof value !== "object") {
      throw new Error(`Unexpected type of ${value}`);
    }
    const entries = Object.entries(value);
    if (entries.length === 1) {
      const key = entries[0][0];
      if (key === "$bytes") {
        if (typeof value.$bytes !== "string") {
          throw new Error(`Malformed $bytes field on ${value}`);
        }
        return toByteArray(value.$bytes).buffer;
      }
      if (key === "$integer") {
        if (typeof value.$integer !== "string") {
          throw new Error(`Malformed $integer field on ${value}`);
        }
        return base64ToBigInt(value.$integer);
      }
      if (key === "$float") {
        if (typeof value.$float !== "string") {
          throw new Error(`Malformed $float field on ${value}`);
        }
        const floatBytes = toByteArray(value.$float);
        if (floatBytes.byteLength !== 8) {
          throw new Error(
            `Received ${floatBytes.byteLength} bytes, expected 8 for $float`
          );
        }
        const floatBytesView = new DataView(floatBytes.buffer);
        const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);
        if (!isSpecial(float)) {
          throw new Error(`Float ${float} should be encoded as a number`);
        }
        return float;
      }
      if (key === "$set") {
        if (!Array.isArray(value.$set)) {
          throw new Error(`Malformed $set field on ${value}`);
        }
        if (!allowMapsAndSets) {
          throw new Error(
            `Received a Set which is no longer supported as a Convex type, with values: ${value.$set.join(
              ", "
            )}.`
          );
        }
        return new Set(
          value.$set.map((value2) => jsonToConvexInternal(value2, allowMapsAndSets))
        );
      }
      if (key === "$map") {
        if (!Array.isArray(value.$map)) {
          throw new Error(`Malformed $map field on ${value}`);
        }
        if (!allowMapsAndSets) {
          throw new Error(
            `Received a Map which is no longer supported as a Convex type, with entries: ${value.$map.join(
              ", "
            )}.`
          );
        }
        const map = /* @__PURE__ */ new Map();
        for (const pair of value.$map) {
          if (!Array.isArray(pair) || pair.length !== 2) {
            throw new Error(`Malformed pair in $map ${value}`);
          }
          const k = jsonToConvexInternal(pair[0], allowMapsAndSets);
          const v = jsonToConvexInternal(pair[1], allowMapsAndSets);
          map.set(k, v);
        }
        return map;
      }
    }
    const out = {};
    for (const [k, v] of Object.entries(value)) {
      validateObjectField(k);
      out[k] = jsonToConvexInternal(v, allowMapsAndSets);
    }
    return out;
  }
  function jsonToConvex(value, allowMapsAndSets = false) {
    return jsonToConvexInternal(value, allowMapsAndSets);
  }
  function stringifyValueForError(value) {
    return JSON.stringify(value, (_key, value2) => {
      if (value2 === void 0) {
        return "undefined";
      }
      if (typeof value2 === "bigint") {
        return `${value2.toString()}n`;
      }
      return value2;
    });
  }
  function convexToJsonInternal(value, originalValue, context, includeTopLevelUndefined, allowMapsAndSets) {
    if (value === void 0) {
      const contextText = context && ` (present at path ${context} in original object ${stringifyValueForError(
        originalValue
      )})`;
      throw new Error(
        `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`
      );
    }
    if (value === null) {
      return value;
    }
    if (typeof value === "bigint") {
      if (value < MIN_INT64 || MAX_INT64 < value) {
        throw new Error(
          `BigInt ${value} does not fit into a 64-bit signed integer.`
        );
      }
      return { $integer: bigIntToBase64(value) };
    }
    if (typeof value === "number") {
      if (isSpecial(value)) {
        const buffer = new ArrayBuffer(8);
        new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);
        return { $float: fromByteArray(new Uint8Array(buffer)) };
      } else {
        return value;
      }
    }
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      return value;
    }
    if (value instanceof ArrayBuffer) {
      return { $bytes: fromByteArray(new Uint8Array(value)) };
    }
    if (Array.isArray(value)) {
      return value.map(
        (value2, i) => convexToJsonInternal(
          value2,
          originalValue,
          context + `[${i}]`,
          false,
          allowMapsAndSets
        )
      );
    }
    if (value instanceof Set) {
      if (!allowMapsAndSets) {
        throw new Error(
          errorMessageForUnsupportedType(
            context,
            "Set",
            [...value],
            originalValue
          )
        );
      }
      return {
        $set: [...value].map(
          (value2, i) => convexToJsonInternal(
            value2,
            originalValue,
            context + `.keys()[${i}]`,
            false,
            allowMapsAndSets
          )
        )
      };
    }
    if (value instanceof Map) {
      if (!allowMapsAndSets) {
        throw new Error(
          errorMessageForUnsupportedType(
            context,
            "Map",
            [...value],
            originalValue
          )
        );
      }
      return {
        $map: [...value].map(([k, v], i) => {
          const jsonKey = convexToJsonInternal(
            k,
            originalValue,
            context + `.keys()[${i}]`,
            false,
            allowMapsAndSets
          );
          const jsonValue = convexToJsonInternal(
            v,
            originalValue,
            context + `.values()[${i}]`,
            false,
            allowMapsAndSets
          );
          return [jsonKey, jsonValue];
        })
      };
    }
    if (!isSimpleObject(value)) {
      const theType = value?.constructor?.name;
      const typeName = theType ? `${theType} ` : "";
      throw new Error(
        errorMessageForUnsupportedType(context, typeName, value, originalValue)
      );
    }
    const out = {};
    const entries = Object.entries(value);
    entries.sort(([k1, _v1], [k2, _v2]) => k1 === k2 ? 0 : k1 < k2 ? -1 : 1);
    for (const [k, v] of entries) {
      if (v !== void 0) {
        validateObjectField(k);
        out[k] = convexToJsonInternal(
          v,
          originalValue,
          context + `.${k}`,
          false,
          allowMapsAndSets
        );
      } else if (includeTopLevelUndefined) {
        validateObjectField(k);
        out[k] = convexOrUndefinedToJsonInternal(
          v,
          originalValue,
          context + `.${k}`
        );
      }
    }
    return out;
  }
  function errorMessageForUnsupportedType(context, typeName, value, originalValue) {
    if (context) {
      return `${typeName}${stringifyValueForError(
        value
      )} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(
        originalValue
      )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`;
    } else {
      return `${typeName}${stringifyValueForError(
        value
      )} is not a supported Convex type.`;
    }
  }
  function convexOrUndefinedToJsonInternal(value, originalValue, context) {
    if (value === void 0) {
      return { $undefined: null };
    } else {
      if (originalValue === void 0) {
        throw new Error(
          `Programming error. Current value is ${stringifyValueForError(
            value
          )} but original value is undefined`
        );
      }
      return convexToJsonInternal(value, originalValue, context, false, false);
    }
  }
  function convexToJson(value, allowMapsAndSets = false) {
    return convexToJsonInternal(value, value, "", false, allowMapsAndSets);
  }

  // src/values/errors.ts
  var IDENTIFYING_FIELD = Symbol.for("ConvexError");
  var _a;
  var ConvexError = class extends Error {
    constructor(data) {
      super(typeof data === "string" ? data : stringifyValueForError(data));
      this.name = "ConvexError";
      this[_a] = true;
      this.data = data;
    }
  };
  _a = IDENTIFYING_FIELD;

  // src/browser/logging.ts
  var INFO_COLOR = "color:rgb(0, 145, 255)";
  function prefix_for_source(source) {
    switch (source) {
      case "query":
        return "Q";
      case "mutation":
        return "M";
      case "action":
        return "A";
      case "any":
        return "?";
    }
  }
  function logToConsole(type, source, udfPath, message) {
    const prefix = prefix_for_source(source);
    if (typeof message === "object") {
      message = `ConvexError ${JSON.stringify(message.errorData, null, 2)}`;
    }
    if (type === "info") {
      const match = message.match(/^\[.*?\] /);
      if (match === null) {
        console.error(
          `[CONVEX ${prefix}(${udfPath})] Could not parse console.log`
        );
        return;
      }
      const level = message.slice(1, match[0].length - 2);
      const args = message.slice(match[0].length);
      console.log(
        `%c[CONVEX ${prefix}(${udfPath})] [${level}]`,
        INFO_COLOR,
        args
      );
    } else {
      console.error(`[CONVEX ${prefix}(${udfPath})] ${message}`);
    }
  }
  function logFatalError(message) {
    const errorMessage = `[CONVEX FATAL ERROR] ${message}`;
    console.error(errorMessage);
    return new Error(errorMessage);
  }
  function createHybridErrorStacktrace(source, udfPath, result) {
    const prefix = prefix_for_source(source);
    return `[CONVEX ${prefix}(${udfPath})] ${result.errorMessage}
  Called by client`;
  }
  function forwardData(result, error) {
    error.data = result.errorData;
    return error;
  }

  // src/browser/sync/udf_path_utils.ts
  function canonicalizeUdfPath(udfPath) {
    const pieces = udfPath.split(":");
    let moduleName;
    let functionName2;
    if (pieces.length === 1) {
      moduleName = pieces[0];
      functionName2 = "default";
    } else {
      moduleName = pieces.slice(0, pieces.length - 1).join(":");
      functionName2 = pieces[pieces.length - 1];
    }
    if (moduleName.endsWith(".js")) {
      moduleName = moduleName.slice(0, -3);
    }
    return `${moduleName}:${functionName2}`;
  }
  function serializePathAndArgs(udfPath, args) {
    return JSON.stringify({
      udfPath: canonicalizeUdfPath(udfPath),
      args: convexToJson(args)
    });
  }

  // src/browser/sync/local_state.ts
  var LocalSyncState = class {
    constructor() {
      this.nextQueryId = 0;
      this.querySetVersion = 0;
      this.identityVersion = 0;
      this.querySet = /* @__PURE__ */ new Map();
      this.queryIdToToken = /* @__PURE__ */ new Map();
      this.outstandingQueriesOlderThanRestart = /* @__PURE__ */ new Set();
      this.outstandingAuthOlderThanRestart = false;
    }
    hasSyncedPastLastReconnect() {
      return this.outstandingQueriesOlderThanRestart.size === 0 && !this.outstandingAuthOlderThanRestart;
    }
    markAuthCompletion() {
      this.outstandingAuthOlderThanRestart = false;
    }
    subscribe(udfPath, args, journal) {
      const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);
      const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);
      const existingEntry = this.querySet.get(queryToken);
      if (existingEntry !== void 0) {
        existingEntry.numSubscribers += 1;
        return {
          queryToken,
          modification: null,
          unsubscribe: () => this.removeSubscriber(queryToken)
        };
      } else {
        const queryId = this.nextQueryId++;
        const query = {
          id: queryId,
          canonicalizedUdfPath,
          args,
          numSubscribers: 1,
          journal
        };
        this.querySet.set(queryToken, query);
        this.queryIdToToken.set(queryId, queryToken);
        const baseVersion = this.querySetVersion;
        const newVersion = ++this.querySetVersion;
        const add = {
          type: "Add",
          queryId,
          udfPath: canonicalizedUdfPath,
          args: [convexToJson(args)],
          journal
        };
        const modification = {
          type: "ModifyQuerySet",
          baseVersion,
          newVersion,
          modifications: [add]
        };
        return {
          queryToken,
          modification,
          unsubscribe: () => this.removeSubscriber(queryToken)
        };
      }
    }
    transition(transition) {
      for (const modification of transition.modifications) {
        switch (modification.type) {
          case "QueryUpdated":
          case "QueryFailed": {
            this.outstandingQueriesOlderThanRestart.delete(modification.queryId);
            const journal = modification.journal;
            if (journal !== void 0) {
              const queryToken = this.queryIdToToken.get(modification.queryId);
              if (queryToken !== void 0) {
                this.querySet.get(queryToken).journal = journal;
              }
            }
            break;
          }
          case "QueryRemoved": {
            this.outstandingQueriesOlderThanRestart.delete(modification.queryId);
            break;
          }
          default: {
            const _ = modification;
            throw new Error(`Invalid modification ${modification.type}`);
          }
        }
      }
    }
    queryId(udfPath, args) {
      const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);
      const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);
      const existingEntry = this.querySet.get(queryToken);
      if (existingEntry !== void 0) {
        return existingEntry.id;
      }
      return null;
    }
    isCurrentOrNewerAuthVersion(version2) {
      return version2 >= this.identityVersion;
    }
    setAuth(value) {
      this.auth = {
        tokenType: "User",
        value
      };
      const baseVersion = this.identityVersion++;
      return {
        type: "Authenticate",
        baseVersion,
        ...this.auth
      };
    }
    setAdminAuth(value, actingAs) {
      const auth = {
        tokenType: "Admin",
        value,
        impersonating: actingAs
      };
      this.auth = auth;
      const baseVersion = this.identityVersion++;
      return {
        type: "Authenticate",
        baseVersion,
        ...auth
      };
    }
    clearAuth() {
      this.auth = void 0;
      this.markAuthCompletion();
      const baseVersion = this.identityVersion++;
      return {
        type: "Authenticate",
        tokenType: "None",
        baseVersion
      };
    }
    hasAuth() {
      return !!this.auth;
    }
    isNewAuth(value) {
      return this.auth?.value !== value;
    }
    queryPath(queryId) {
      const pathAndArgs = this.queryIdToToken.get(queryId);
      if (pathAndArgs) {
        return this.querySet.get(pathAndArgs).canonicalizedUdfPath;
      }
      return null;
    }
    queryArgs(queryId) {
      const pathAndArgs = this.queryIdToToken.get(queryId);
      if (pathAndArgs) {
        return this.querySet.get(pathAndArgs).args;
      }
      return null;
    }
    queryToken(queryId) {
      return this.queryIdToToken.get(queryId) ?? null;
    }
    queryJournal(queryToken) {
      return this.querySet.get(queryToken)?.journal;
    }
    restart(oldRemoteQueryResults) {
      this.outstandingQueriesOlderThanRestart.clear();
      const modifications = [];
      for (const localQuery of this.querySet.values()) {
        const add = {
          type: "Add",
          queryId: localQuery.id,
          udfPath: localQuery.canonicalizedUdfPath,
          args: [convexToJson(localQuery.args)],
          journal: localQuery.journal
        };
        modifications.push(add);
        if (!oldRemoteQueryResults.has(localQuery.id)) {
          this.outstandingQueriesOlderThanRestart.add(localQuery.id);
        }
      }
      this.querySetVersion = 1;
      const querySet = {
        type: "ModifyQuerySet",
        baseVersion: 0,
        newVersion: 1,
        modifications
      };
      if (!this.auth) {
        this.identityVersion = 0;
        return [querySet, void 0];
      }
      this.outstandingAuthOlderThanRestart = true;
      const authenticate = {
        type: "Authenticate",
        baseVersion: 0,
        ...this.auth
      };
      this.identityVersion = 1;
      return [querySet, authenticate];
    }
    removeSubscriber(queryToken) {
      const localQuery = this.querySet.get(queryToken);
      if (localQuery.numSubscribers > 1) {
        localQuery.numSubscribers -= 1;
        return null;
      } else {
        this.querySet.delete(queryToken);
        this.queryIdToToken.delete(localQuery.id);
        this.outstandingQueriesOlderThanRestart.delete(localQuery.id);
        const baseVersion = this.querySetVersion;
        const newVersion = ++this.querySetVersion;
        const remove = {
          type: "Remove",
          queryId: localQuery.id
        };
        return {
          type: "ModifyQuerySet",
          baseVersion,
          newVersion,
          modifications: [remove]
        };
      }
    }
  };

  // src/browser/sync/request_manager.ts
  var RequestManager = class {
    constructor() {
      this.inflightRequests = /* @__PURE__ */ new Map();
      this.requestsOlderThanRestart = /* @__PURE__ */ new Set();
    }
    request(message, sent) {
      const result = new Promise((resolve) => {
        const status = sent ? "Requested" : "NotSent";
        this.inflightRequests.set(message.requestId, {
          message,
          status: { status, requestedAt: /* @__PURE__ */ new Date(), onResult: resolve }
        });
      });
      return result;
    }
    /**
     * Update the state after receiving a response.
     *
     * @returns A RequestId if the request is complete and its optimistic update
     * can be dropped, null otherwise.
     */
    onResponse(response) {
      const requestInfo = this.inflightRequests.get(response.requestId);
      if (requestInfo === void 0) {
        return null;
      }
      if (requestInfo.status.status === "Completed") {
        return null;
      }
      const udfType = requestInfo.message.type === "Mutation" ? "mutation" : "action";
      const udfPath = requestInfo.message.udfPath;
      for (const line of response.logLines) {
        logToConsole("info", udfType, udfPath, line);
      }
      const status = requestInfo.status;
      let onResolve;
      if (response.success) {
        onResolve = () => status.onResult({
          success: true,
          logLines: response.logLines,
          value: jsonToConvex(response.result, true)
        });
      } else {
        const errorMessage = response.result;
        const { errorData } = response;
        logToConsole("error", udfType, udfPath, errorMessage);
        onResolve = () => status.onResult({
          success: false,
          errorMessage,
          errorData: errorData !== void 0 ? jsonToConvex(errorData) : void 0,
          logLines: response.logLines
        });
      }
      if (response.type === "ActionResponse" || !response.success) {
        onResolve();
        this.inflightRequests.delete(response.requestId);
        this.requestsOlderThanRestart.delete(response.requestId);
        return response.requestId;
      }
      requestInfo.status = {
        status: "Completed",
        ts: response.ts,
        onResolve
      };
      return null;
    }
    // Remove and returns completed requests.
    removeCompleted(ts) {
      const completeRequests = /* @__PURE__ */ new Set();
      for (const [requestId, requestInfo] of this.inflightRequests.entries()) {
        const status = requestInfo.status;
        if (status.status === "Completed" && status.ts.lessThanOrEqual(ts)) {
          status.onResolve();
          completeRequests.add(requestId);
          this.inflightRequests.delete(requestId);
          this.requestsOlderThanRestart.delete(requestId);
        }
      }
      return completeRequests;
    }
    restart() {
      this.requestsOlderThanRestart = new Set(this.inflightRequests.keys());
      const allMessages = [];
      for (const [requestId, value] of this.inflightRequests) {
        if (value.status.status === "NotSent") {
          value.status.status = "Requested";
          allMessages.push(value.message);
          continue;
        }
        if (value.message.type === "Mutation") {
          allMessages.push(value.message);
        } else {
          this.inflightRequests.delete(requestId);
          this.requestsOlderThanRestart.delete(requestId);
          if (value.status.status === "Completed") {
            throw new Error("Action should never be in 'Completed' state");
          }
          value.status.onResult({
            success: false,
            errorMessage: "Connection lost while action was in flight",
            logLines: []
          });
        }
      }
      return allMessages;
    }
    /**
     * @returns true if there are any requests that have been requested but have
     * not be completed yet.
     */
    hasIncompleteRequests() {
      for (const requestInfo of this.inflightRequests.values()) {
        if (requestInfo.status.status === "Requested") {
          return true;
        }
      }
      return false;
    }
    /**
     * @returns true if there are any inflight requests, including ones that have
     * completed on the server, but have not been applied.
     */
    hasInflightRequests() {
      return this.inflightRequests.size > 0;
    }
    /**
     * @returns true if there are any inflight requests, that have been hanging around
     * since prior to the most recent restart.
     */
    hasSyncedPastLastReconnect() {
      return this.requestsOlderThanRestart.size === 0;
    }
    timeOfOldestInflightRequest() {
      if (this.inflightRequests.size === 0) {
        return null;
      }
      let oldestInflightRequest = Date.now();
      for (const request of this.inflightRequests.values()) {
        if (request.status.status !== "Completed") {
          if (request.status.requestedAt.getTime() < oldestInflightRequest) {
            oldestInflightRequest = request.status.requestedAt.getTime();
          }
        }
      }
      return new Date(oldestInflightRequest);
    }
  };

  // src/server/api.ts
  var functionName = Symbol.for("functionName");
  function getFunctionName(functionReference) {
    if (typeof functionReference === "string")
      return functionReference;
    const name = functionReference[functionName];
    if (!name) {
      throw new Error(`${functionReference} is not a functionReference`);
    }
    return name;
  }
  function createApi(pathParts = []) {
    const handler = {
      get(_, prop) {
        if (typeof prop === "string") {
          const newParts = [...pathParts, prop];
          return createApi(newParts);
        } else if (prop === functionName) {
          if (pathParts.length < 2) {
            const found = ["api", ...pathParts].join(".");
            throw new Error(
              `API path is expected to be of the form \`api.moduleName.functionName\`. Found: \`${found}\``
            );
          }
          const path = pathParts.slice(0, -1).join("/");
          const exportName = pathParts[pathParts.length - 1];
          if (exportName === "default") {
            return path;
          } else {
            return path + ":" + exportName;
          }
        } else if (prop === Symbol.toStringTag) {
          return "FunctionReference";
        } else {
          return void 0;
        }
      }
    };
    return new Proxy({}, handler);
  }
  var anyApi = createApi();

  // src/browser/sync/optimistic_updates_impl.ts
  var OptimisticLocalStoreImpl = class {
    constructor(queryResults) {
      this.queryResults = queryResults;
      this.modifiedQueries = [];
    }
    getQuery(query, ...args) {
      const queryArgs = parseArgs(args[0]);
      const name = getFunctionName(query);
      const queryResult = this.queryResults.get(
        serializePathAndArgs(name, queryArgs)
      );
      if (queryResult === void 0) {
        return void 0;
      }
      return OptimisticLocalStoreImpl.queryValue(queryResult.result);
    }
    getAllQueries(query) {
      const queriesWithName = [];
      const name = getFunctionName(query);
      for (const queryResult of this.queryResults.values()) {
        if (queryResult.udfPath === canonicalizeUdfPath(name)) {
          queriesWithName.push({
            args: queryResult.args,
            value: OptimisticLocalStoreImpl.queryValue(queryResult.result)
          });
        }
      }
      return queriesWithName;
    }
    setQuery(queryReference, args, value) {
      const queryArgs = parseArgs(args);
      const name = getFunctionName(queryReference);
      const queryToken = serializePathAndArgs(name, queryArgs);
      let result;
      if (value === void 0) {
        result = void 0;
      } else {
        result = {
          success: true,
          value,
          // It's an optimistic update, so there are no function logs to show.
          logLines: []
        };
      }
      const query = {
        udfPath: name,
        args: queryArgs,
        result
      };
      this.queryResults.set(queryToken, query);
      this.modifiedQueries.push(queryToken);
    }
    static queryValue(result) {
      if (result === void 0) {
        return void 0;
      } else if (result.success) {
        return result.value;
      } else {
        return void 0;
      }
    }
  };
  var OptimisticQueryResults = class {
    constructor() {
      this.queryResults = /* @__PURE__ */ new Map();
      this.optimisticUpdates = [];
    }
    ingestQueryResultsFromServer(serverQueryResults, optimisticUpdatesToDrop) {
      this.optimisticUpdates = this.optimisticUpdates.filter((updateAndId) => {
        return !optimisticUpdatesToDrop.has(updateAndId.mutationId);
      });
      const oldQueryResults = this.queryResults;
      this.queryResults = new Map(serverQueryResults);
      const localStore = new OptimisticLocalStoreImpl(this.queryResults);
      for (const updateAndId of this.optimisticUpdates) {
        updateAndId.update(localStore);
      }
      const changedQueries = [];
      for (const [queryToken, query] of this.queryResults) {
        const oldQuery = oldQueryResults.get(queryToken);
        if (oldQuery === void 0 || oldQuery.result !== query.result) {
          changedQueries.push(queryToken);
        }
      }
      return changedQueries;
    }
    applyOptimisticUpdate(update, mutationId) {
      this.optimisticUpdates.push({
        update,
        mutationId
      });
      const localStore = new OptimisticLocalStoreImpl(this.queryResults);
      update(localStore);
      return localStore.modifiedQueries;
    }
    queryResult(queryToken) {
      const query = this.queryResults.get(queryToken);
      if (query === void 0) {
        return void 0;
      }
      const result = query.result;
      if (result === void 0) {
        return void 0;
      } else if (result.success) {
        return result.value;
      } else {
        if (result.errorData !== void 0) {
          throw forwardData(
            result,
            new ConvexError(
              createHybridErrorStacktrace("query", query.udfPath, result)
            )
          );
        }
        throw new Error(
          createHybridErrorStacktrace("query", query.udfPath, result)
        );
      }
    }
    hasQueryResult(queryToken) {
      return this.queryResults.get(queryToken) !== void 0;
    }
    /**
     * @internal
     */
    queryLogs(queryToken) {
      const query = this.queryResults.get(queryToken);
      return query?.result?.logLines;
    }
  };

  // src/browser/long.ts
  var Long = class {
    static isLong(obj) {
      return (obj && obj.__isUnsignedLong__) === true;
    }
    constructor(low, high) {
      this.low = low | 0;
      this.high = high | 0;
      this.__isUnsignedLong__ = true;
    }
    // prettier-ignore
    static fromBytesLE(bytes) {
      return new Long(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24
      );
    }
    // prettier-ignore
    toBytesLE() {
      const hi = this.high;
      const lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    }
    static fromNumber(value) {
      if (isNaN(value))
        return UZERO;
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
      return new Long(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);
    }
    toString() {
      return (BigInt(this.high) * BigInt(TWO_PWR_32_DBL) + BigInt(this.low)).toString();
    }
    equals(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    }
    notEquals(other) {
      return !this.equals(other);
    }
    comp(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.equals(other))
        return 0;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
    lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    }
    static fromValue(val) {
      if (typeof val === "number")
        return Long.fromNumber(val);
      return new Long(val.low, val.high);
    }
  };
  var UZERO = new Long(0, 0);
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var MAX_UNSIGNED_VALUE = new Long(4294967295 | 0, 4294967295 | 0);

  // src/browser/sync/remote_query_set.ts
  var RemoteQuerySet = class {
    constructor(queryPath) {
      this.version = { querySet: 0, ts: Long.fromNumber(0), identity: 0 };
      this.remoteQuerySet = /* @__PURE__ */ new Map();
      this.queryPath = queryPath;
    }
    transition(transition) {
      const start = transition.startVersion;
      if (this.version.querySet !== start.querySet || this.version.ts.notEquals(start.ts) || this.version.identity !== start.identity) {
        throw new Error(
          `Invalid start version: ${start.ts.toString()}:${start.querySet}`
        );
      }
      for (const modification of transition.modifications) {
        switch (modification.type) {
          case "QueryUpdated": {
            const queryPath = this.queryPath(modification.queryId);
            if (queryPath) {
              for (const line of modification.logLines) {
                logToConsole("info", "query", queryPath, line);
              }
            }
            const value = jsonToConvex(modification.value ?? null, true);
            this.remoteQuerySet.set(modification.queryId, {
              success: true,
              value,
              logLines: modification.logLines
            });
            break;
          }
          case "QueryFailed": {
            const queryPath = this.queryPath(modification.queryId);
            if (queryPath) {
              for (const line of modification.logLines) {
                logToConsole("info", "query", queryPath, line);
              }
            }
            const { errorData } = modification;
            this.remoteQuerySet.set(modification.queryId, {
              success: false,
              errorMessage: modification.errorMessage,
              errorData: errorData !== void 0 ? jsonToConvex(errorData) : void 0,
              logLines: modification.logLines
            });
            break;
          }
          case "QueryRemoved": {
            this.remoteQuerySet.delete(modification.queryId);
            break;
          }
          default: {
            const _ = modification;
            throw new Error(`Invalid modification ${modification.type}`);
          }
        }
      }
      this.version = transition.endVersion;
    }
    remoteQueryResults() {
      return this.remoteQuerySet;
    }
    timestamp() {
      return this.version.ts;
    }
  };

  // src/browser/sync/protocol.ts
  function u64ToLong(encoded) {
    const integerBytes = base64_exports.toByteArray(encoded);
    return Long.fromBytesLE(Array.from(integerBytes));
  }
  function longToU64(raw) {
    const integerBytes = new Uint8Array(raw.toBytesLE());
    return base64_exports.fromByteArray(integerBytes);
  }
  function parseServerMessage(encoded) {
    switch (encoded.type) {
      case "FatalError":
      case "AuthError":
      case "ActionResponse":
      case "Ping": {
        return { ...encoded };
      }
      case "MutationResponse": {
        if (encoded.success) {
          return { ...encoded, ts: u64ToLong(encoded.ts) };
        } else {
          return { ...encoded };
        }
      }
      case "Transition": {
        return {
          ...encoded,
          startVersion: {
            ...encoded.startVersion,
            ts: u64ToLong(encoded.startVersion.ts)
          },
          endVersion: {
            ...encoded.endVersion,
            ts: u64ToLong(encoded.endVersion.ts)
          }
        };
      }
      default: {
        const _exhaustivenessCheck = encoded;
      }
    }
    return void 0;
  }
  function encodeClientMessage(message) {
    switch (message.type) {
      case "Authenticate":
      case "ModifyQuerySet":
      case "Mutation":
      case "Action":
      case "Event": {
        return { ...message };
      }
      case "Connect": {
        if (message.maxObservedTimestamp !== void 0) {
          return {
            ...message,
            maxObservedTimestamp: longToU64(message.maxObservedTimestamp)
          };
        } else {
          return { ...message, maxObservedTimestamp: void 0 };
        }
      }
      default: {
        const _exhaustivenessCheck = message;
      }
    }
    return void 0;
  }

  // src/browser/sync/web_socket_manager.ts
  var CLOSE_NORMAL = 1e3;
  var CLOSE_GOING_AWAY = 1001;
  var CLOSE_NO_STATUS = 1005;
  var CLOSE_NOT_FOUND = 4040;
  var WebSocketManager = class {
    constructor(uri, onOpen, onMessage, webSocketConstructor, verbose) {
      this.webSocketConstructor = webSocketConstructor;
      this.socket = { state: "disconnected" };
      this.connectionCount = 0;
      this.lastCloseReason = "InitialConnect";
      this.initialBackoff = 100;
      this.maxBackoff = 16e3;
      this.retries = 0;
      this.serverInactivityThreshold = 3e4;
      this.reconnectDueToServerInactivityTimeout = null;
      this.uri = uri;
      this.onOpen = onOpen;
      this.onMessage = onMessage;
      this.verbose = verbose;
      void this.connect();
    }
    connect() {
      if (this.socket.state === "stopped") {
        return;
      }
      if (this.socket.state !== "disconnected" && this.socket.state !== "paused") {
        throw new Error(
          "Didn't start connection from disconnected state: " + this.socket.state
        );
      }
      const ws = new this.webSocketConstructor(this.uri);
      this._logVerbose("constructed WebSocket");
      this.socket = {
        state: "connecting",
        ws
      };
      this.resetServerInactivityTimeout();
      ws.onopen = () => {
        this._logVerbose("begin ws.onopen");
        if (this.socket.state !== "connecting") {
          throw new Error("onopen called with socket not in connecting state");
        }
        this.socket = { state: "ready", ws };
        this.resetServerInactivityTimeout();
        this.onOpen({
          connectionCount: this.connectionCount,
          lastCloseReason: this.lastCloseReason
        });
        if (this.lastCloseReason !== "InitialConnect") {
          console.log("WebSocket reconnected");
        }
        this.connectionCount += 1;
        this.lastCloseReason = null;
      };
      ws.onerror = (error) => {
        const message = error.message;
        console.log(`WebSocket error: ${message}`);
      };
      ws.onmessage = (message) => {
        this.resetServerInactivityTimeout();
        const serverMessage = parseServerMessage(JSON.parse(message.data));
        this._logVerbose(`received ws message with type ${serverMessage.type}`);
        const response = this.onMessage(serverMessage);
        if (response.hasSyncedPastLastReconnect) {
          this.retries = 0;
        }
      };
      ws.onclose = (event) => {
        this._logVerbose("begin ws.onclose");
        if (this.lastCloseReason === null) {
          this.lastCloseReason = event.reason ?? "OnCloseInvoked";
        }
        if (event.code !== CLOSE_NORMAL && event.code !== CLOSE_GOING_AWAY && // This commonly gets fired on mobile apps when the app is backgrounded
        event.code !== CLOSE_NO_STATUS && event.code !== CLOSE_NOT_FOUND) {
          let msg = `WebSocket closed with code ${event.code}`;
          if (event.reason) {
            msg += `: ${event.reason}`;
          }
          console.log(msg);
        }
        this.scheduleReconnect();
        return;
      };
    }
    /**
     * @returns The state of the {@link Socket}.
     */
    socketState() {
      return this.socket.state;
    }
    /**
     * @param message - A ClientMessage to send.
     * @returns Whether the message (might have been) sent.
     */
    sendMessage(message) {
      this._logVerbose(`sending message with type ${message.type}`);
      if (this.socket.state === "ready") {
        const encodedMessage = encodeClientMessage(message);
        const request = JSON.stringify(encodedMessage);
        try {
          this.socket.ws.send(request);
        } catch (error) {
          console.log(
            `Failed to send message on WebSocket, reconnecting: ${error}`
          );
          this.closeAndReconnect("FailedToSendMessage");
        }
        return true;
      }
      return false;
    }
    resetServerInactivityTimeout() {
      if (this.socket.state !== "stopped") {
        return;
      }
      if (this.reconnectDueToServerInactivityTimeout !== null) {
        clearTimeout(this.reconnectDueToServerInactivityTimeout);
        this.reconnectDueToServerInactivityTimeout = null;
      }
      this.reconnectDueToServerInactivityTimeout = setTimeout(() => {
        this.closeAndReconnect("InactiveServer");
      }, this.serverInactivityThreshold);
    }
    scheduleReconnect() {
      this.socket = { state: "disconnected" };
      const backoff = this.nextBackoff();
      console.log(`Attempting reconnect in ${backoff}ms`);
      setTimeout(() => this.connect(), backoff);
    }
    /**
     * Close the WebSocket and schedule a reconnect.
     *
     * This should be used when we hit an error and would like to restart the session.
     */
    closeAndReconnect(closeReason) {
      this._logVerbose(`begin closeAndReconnect with reason ${closeReason}`);
      switch (this.socket.state) {
        case "disconnected":
        case "stopped":
        case "paused":
          return;
        case "connecting":
        case "ready": {
          this.lastCloseReason = closeReason;
          this.close();
          this.scheduleReconnect();
          return;
        }
        default: {
          const _ = this.socket;
        }
      }
    }
    /**
     * Close the WebSocket, being careful to clear the onclose handler to avoid re-entrant
     * calls. Use this instead of directly calling `ws.close()`
     */
    close() {
      switch (this.socket.state) {
        case "disconnected":
        case "stopped":
        case "paused":
          return;
        case "connecting":
        case "ready": {
          this.socket.ws.onclose = () => {
          };
          this._logVerbose("ws.close called");
          this.socket.ws.close();
          return;
        }
        default: {
          const _ = this.socket;
        }
      }
    }
    /**
     * Close the WebSocket and do not reconnect.
     * @returns A Promise that resolves when the WebSocket `onClose` callback is called.
     */
    stop() {
      if (this.reconnectDueToServerInactivityTimeout) {
        clearTimeout(this.reconnectDueToServerInactivityTimeout);
      }
      switch (this.socket.state) {
        case "stopped":
        case "paused":
        case "disconnected":
        case "connecting":
        case "ready":
          this.close();
          if (this.socket.state === "ready" || this.socket.state === "connecting") {
            const ws = this.socket.ws;
            this.socket = { state: "stopped" };
            return new Promise((r2) => {
              ws.onclose = (_event) => r2();
            });
          }
          this.socket = { state: "stopped" };
          return Promise.resolve();
        default: {
          const _ = this.socket;
          throw new Error(
            `Invalid websocket state: ${this.socket.state}`
          );
        }
      }
    }
    pause() {
      switch (this.socket.state) {
        case "stopped":
          return;
        case "paused":
        case "disconnected":
        case "connecting":
        case "ready":
          this.close();
          this.socket = {
            state: "paused"
          };
          return;
        default: {
          const _ = this.socket;
        }
      }
    }
    /**
     * Create a new WebSocket after a previous `pause()`, unless `stop()` was
     * called before.
     */
    resume() {
      switch (this.socket.state) {
        case "paused":
          break;
        case "stopped":
          return;
        case "connecting":
        case "ready":
        case "disconnected":
          throw new Error("`resume()` is only valid after `pause()`");
        default: {
          const _ = this.socket;
        }
      }
      this.connect();
    }
    _logVerbose(message) {
      if (this.verbose) {
        console.debug(`${(/* @__PURE__ */ new Date()).toISOString()} ${message}`);
      }
    }
    nextBackoff() {
      const baseBackoff = this.initialBackoff * Math.pow(2, this.retries);
      this.retries += 1;
      const actualBackoff = Math.min(baseBackoff, this.maxBackoff);
      const jitter = actualBackoff * (Math.random() - 0.5);
      return actualBackoff + jitter;
    }
  };

  // src/browser/sync/session.ts
  function newSessionId() {
    return uuidv4();
  }
  function uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r2 = Math.random() * 16 | 0, v = c === "x" ? r2 : r2 & 3 | 8;
      return v.toString(16);
    });
  }

  // ../common/temp/node_modules/.pnpm/jwt-decode@3.1.2/node_modules/jwt-decode/build/jwt-decode.esm.js
  function e(e2) {
    this.message = e2;
  }
  e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
  var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
    var t2 = String(r2).replace(/=+$/, "");
    if (t2.length % 4 == 1)
      throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
    for (var n2, o2, a = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
      o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
    return c;
  };
  function t(e2) {
    var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
    switch (t2.length % 4) {
      case 0:
        break;
      case 2:
        t2 += "==";
        break;
      case 3:
        t2 += "=";
        break;
      default:
        throw "Illegal base64url string!";
    }
    try {
      return function(e3) {
        return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
          var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
          return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
        }));
      }(t2);
    } catch (e3) {
      return r(t2);
    }
  }
  function n(e2) {
    this.message = e2;
  }
  function o(e2, r2) {
    if ("string" != typeof e2)
      throw new n("Invalid token specified");
    var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
    try {
      return JSON.parse(t(e2.split(".")[o2]));
    } catch (e3) {
      throw new n("Invalid token specified: " + e3.message);
    }
  }
  n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
  var jwt_decode_esm_default = o;

  // src/browser/sync/authentication_manager.ts
  var AuthenticationManager = class {
    constructor(syncState, {
      authenticate,
      pauseSocket: pause,
      resumeSocket: resume,
      clearAuth,
      verbose
    }) {
      this.authState = { state: "noAuth" };
      // Used to detect races involving `setConfig` calls
      // while a token is being fetched.
      this.configVersion = 0;
      this.syncState = syncState;
      this.authenticate = authenticate;
      this.pauseSocket = pause;
      this.resumeSocket = resume;
      this.clearAuth = clearAuth;
      this.verbose = verbose;
    }
    async setConfig(fetchToken, onChange) {
      this.resetAuthState();
      const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {
        forceRefreshToken: false
      });
      if (token.isFromOutdatedConfig) {
        return;
      }
      if (token.value) {
        this.setAuthState({
          state: "waitingForServerConfirmationOfCachedToken",
          config: { fetchToken, onAuthChange: onChange },
          hasRetried: false
        });
        this.authenticate(token.value);
      } else {
        this.setAuthState({
          state: "initialRefetch",
          config: { fetchToken, onAuthChange: onChange }
        });
        await this.refetchToken();
      }
    }
    onTransition(serverMessage) {
      if (!this.syncState.isCurrentOrNewerAuthVersion(
        serverMessage.endVersion.identity
      )) {
        return;
      }
      if (serverMessage.endVersion.identity <= serverMessage.startVersion.identity) {
        return;
      }
      if (this.authState.state === "waitingForServerConfirmationOfCachedToken") {
        this._logVerbose("server confirmed auth token is valid");
        void this.refetchToken();
        this.authState.config.onAuthChange(true);
        return;
      }
      if (this.authState.state === "waitingForServerConfirmationOfFreshToken") {
        this._logVerbose("server confirmed new auth token is valid");
        this.scheduleTokenRefetch(this.authState.token);
        if (!this.authState.hadAuth) {
          this.authState.config.onAuthChange(true);
        }
      }
    }
    onAuthError(serverMessage) {
      const { baseVersion } = serverMessage;
      if (baseVersion !== null && baseVersion !== void 0) {
        if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {
          this._logVerbose("ignoring auth error for previous auth attempt");
          return;
        }
        void this.tryToReauthenticate(serverMessage);
        return;
      }
      void this.tryToReauthenticate(serverMessage);
    }
    // This is similar to `refetchToken` defined below, in fact we
    // don't represent them as different states, but it is different
    // in that we pause the WebSocket so that mutations
    // don't retry with bad auth.
    async tryToReauthenticate(serverMessage) {
      if (
        // No way to fetch another token, kaboom
        this.authState.state === "noAuth" || // We failed on a fresh token, trying another one won't help
        this.authState.state === "waitingForServerConfirmationOfFreshToken"
      ) {
        console.error(
          `Failed to authenticate: "${serverMessage.error}", check your server auth config`
        );
        if (this.syncState.hasAuth()) {
          this.syncState.clearAuth();
        }
        if (this.authState.state !== "noAuth") {
          this.setAndReportAuthFailed(this.authState.config.onAuthChange);
        }
        return;
      }
      this._logVerbose("attempting to reauthenticate");
      await this.pauseSocket();
      const token = await this.fetchTokenAndGuardAgainstRace(
        this.authState.config.fetchToken,
        {
          forceRefreshToken: true
        }
      );
      if (token.isFromOutdatedConfig) {
        await this.resumeSocket();
        return;
      }
      if (token.value && this.syncState.isNewAuth(token.value)) {
        this.syncState.setAuth(token.value);
        this.setAuthState({
          state: "waitingForServerConfirmationOfFreshToken",
          config: this.authState.config,
          token: token.value,
          hadAuth: this.authState.state === "notRefetching" || this.authState.state === "waitingForScheduledRefetch"
        });
      } else {
        this._logVerbose("reauthentication failed, could not fetch a new token");
        if (this.syncState.hasAuth()) {
          this.syncState.clearAuth();
        }
        this.setAndReportAuthFailed(this.authState.config.onAuthChange);
      }
      await this.resumeSocket();
    }
    // Force refetch the token and schedule another refetch
    // before the token expires - an active client should never
    // need to reauthenticate.
    async refetchToken() {
      if (this.authState.state === "noAuth") {
        return;
      }
      this._logVerbose("refetching auth token");
      const token = await this.fetchTokenAndGuardAgainstRace(
        this.authState.config.fetchToken,
        {
          forceRefreshToken: true
        }
      );
      if (token.isFromOutdatedConfig) {
        return;
      }
      if (token.value) {
        if (this.syncState.isNewAuth(token.value)) {
          this.setAuthState({
            state: "waitingForServerConfirmationOfFreshToken",
            hadAuth: this.syncState.hasAuth(),
            token: token.value,
            config: this.authState.config
          });
          this.authenticate(token.value);
        } else {
          this.setAuthState({
            state: "notRefetching",
            config: this.authState.config
          });
        }
      } else {
        this._logVerbose("refetching token failed");
        if (this.syncState.hasAuth()) {
          this.clearAuth();
        }
        this.setAndReportAuthFailed(this.authState.config.onAuthChange);
      }
    }
    scheduleTokenRefetch(token) {
      if (this.authState.state === "noAuth") {
        return;
      }
      const decodedToken = this.decodeToken(token);
      if (!decodedToken) {
        console.error("Auth token is not a valid JWT, cannot refetch the token");
        return;
      }
      const { iat, exp } = decodedToken;
      if (!iat || !exp) {
        console.error(
          "Auth token does not have required fields, cannot refetch the token"
        );
        return;
      }
      const leewaySeconds = 2;
      const delay = (exp - iat - leewaySeconds) * 1e3;
      if (delay <= 0) {
        console.error(
          "Auth token does not live long enough, cannot refetch the token"
        );
        return;
      }
      const refetchTokenTimeoutId = setTimeout(() => {
        void this.refetchToken();
      }, delay);
      this.setAuthState({
        state: "waitingForScheduledRefetch",
        refetchTokenTimeoutId,
        config: this.authState.config
      });
      this._logVerbose(
        `scheduled preemptive auth token refetching in ${delay}ms`
      );
    }
    // Protects against simultaneous calls to `setConfig`
    // while we're fetching a token
    async fetchTokenAndGuardAgainstRace(fetchToken, fetchArgs) {
      const originalConfigVersion = ++this.configVersion;
      const token = await fetchToken(fetchArgs);
      if (this.configVersion !== originalConfigVersion) {
        return { isFromOutdatedConfig: true };
      }
      return { isFromOutdatedConfig: false, value: token };
    }
    stop() {
      this.resetAuthState();
      this.configVersion++;
    }
    setAndReportAuthFailed(onAuthChange) {
      onAuthChange(false);
      this.resetAuthState();
    }
    resetAuthState() {
      this.setAuthState({ state: "noAuth" });
    }
    setAuthState(newAuth) {
      if (this.authState.state === "waitingForScheduledRefetch") {
        clearTimeout(this.authState.refetchTokenTimeoutId);
        this.syncState.markAuthCompletion();
      }
      this.authState = newAuth;
    }
    decodeToken(token) {
      try {
        return jwt_decode_esm_default(token);
      } catch (e2) {
        return null;
      }
    }
    _logVerbose(message) {
      if (this.verbose) {
        console.debug(
          `${(/* @__PURE__ */ new Date()).toISOString()} ${message} [v${this.configVersion}]`
        );
      }
    }
  };

  // src/browser/sync/metrics.ts
  var markNames = [
    "convexClientConstructed",
    "convexWebSocketOpen",
    "convexFirstMessageReceived"
  ];
  function mark(name, sessionId) {
    const detail = { sessionId };
    if (typeof performance === "undefined" || !performance.mark)
      return;
    performance.mark(name, { detail });
  }
  function performanceMarkToJson(mark2) {
    let name = mark2.name.slice("convex".length);
    name = name.charAt(0).toLowerCase() + name.slice(1);
    return {
      name,
      startTime: mark2.startTime
    };
  }
  function getMarksReport(sessionId) {
    if (typeof performance === "undefined" || !performance.getEntriesByName) {
      return [];
    }
    const allMarks = [];
    for (const name of markNames) {
      const marks = performance.getEntriesByName(name).filter((entry) => entry.entryType === "mark").filter((mark2) => mark2.detail.sessionId === sessionId);
      allMarks.push(...marks);
    }
    return allMarks.map(performanceMarkToJson);
  }

  // src/browser/sync/client.ts
  var BaseConvexClient = class {
    /**
     * @param address - The url of your Convex deployment, often provided
     * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.
     * @param onTransition - A callback receiving an array of query tokens
     * corresponding to query results that have changed.
     * @param options - See {@link BaseConvexClientOptions} for a full description.
     */
    constructor(address, onTransition, options) {
      this.firstMessageReceived = false;
      // Instance property so that `mark()` doesn't need to be called as a method.
      this.mark = (name) => {
        if (this.debug) {
          mark(name, this.sessionId);
        }
      };
      if (typeof address === "object") {
        throw new Error(
          "Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly."
        );
      }
      validateDeploymentUrl(address);
      options = { ...options };
      let webSocketConstructor = options.webSocketConstructor;
      if (!webSocketConstructor && typeof WebSocket === "undefined") {
        throw new Error(
          "No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient"
        );
      }
      webSocketConstructor = webSocketConstructor || WebSocket;
      this.verbose = options.verbose ?? false;
      this.debug = options.reportDebugInfoToConvex ?? false;
      this.address = address;
      const i = address.search("://");
      if (i === -1) {
        throw new Error("Provided address was not an absolute URL.");
      }
      const origin = address.substring(i + 3);
      const protocol = address.substring(0, i);
      let wsProtocol;
      if (protocol === "http") {
        wsProtocol = "ws";
      } else if (protocol === "https") {
        wsProtocol = "wss";
      } else {
        throw new Error(`Unknown parent protocol ${protocol}`);
      }
      const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;
      this.state = new LocalSyncState();
      this.remoteQuerySet = new RemoteQuerySet(
        (queryId) => this.state.queryPath(queryId)
      );
      this.requestManager = new RequestManager();
      this.authenticationManager = new AuthenticationManager(this.state, {
        authenticate: (token) => {
          const message = this.state.setAuth(token);
          this.webSocketManager.sendMessage(message);
        },
        pauseSocket: () => this.webSocketManager.pause(),
        resumeSocket: () => this.webSocketManager.resume(),
        clearAuth: () => {
          this.clearAuth();
        },
        verbose: this.verbose
      });
      this.optimisticQueryResults = new OptimisticQueryResults();
      this.onTransition = onTransition;
      this.nextRequestId = 0;
      this.sessionId = newSessionId();
      const { unsavedChangesWarning } = options;
      if (typeof window === "undefined" || typeof window.addEventListener === "undefined") {
        if (unsavedChangesWarning === true) {
          throw new Error(
            "unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options."
          );
        }
      } else if (unsavedChangesWarning !== false) {
        window.addEventListener("beforeunload", (e2) => {
          if (this.requestManager.hasIncompleteRequests()) {
            e2.preventDefault();
            const confirmationMessage = "Are you sure you want to leave? Your changes may not be saved.";
            (e2 || window.event).returnValue = confirmationMessage;
            return confirmationMessage;
          }
        });
      }
      this.webSocketManager = new WebSocketManager(
        wsUri,
        (reconnectMetadata) => {
          this.mark("convexWebSocketOpen");
          this.webSocketManager.sendMessage({
            ...reconnectMetadata,
            type: "Connect",
            sessionId: this.sessionId,
            maxObservedTimestamp: this.maxObservedTimestamp
          });
          const oldRemoteQueryResults = new Set(
            this.remoteQuerySet.remoteQueryResults().keys()
          );
          this.remoteQuerySet = new RemoteQuerySet(
            (queryId) => this.state.queryPath(queryId)
          );
          const [querySetModification, authModification] = this.state.restart(
            oldRemoteQueryResults
          );
          if (authModification) {
            this.webSocketManager.sendMessage(authModification);
          }
          this.webSocketManager.sendMessage(querySetModification);
          for (const message of this.requestManager.restart()) {
            this.webSocketManager.sendMessage(message);
          }
        },
        (serverMessage) => {
          if (!this.firstMessageReceived) {
            this.firstMessageReceived = true;
            this.mark("convexFirstMessageReceived");
            this.reportMarks();
          }
          switch (serverMessage.type) {
            case "Transition": {
              this.observedTimestamp(serverMessage.endVersion.ts);
              this.authenticationManager.onTransition(serverMessage);
              this.remoteQuerySet.transition(serverMessage);
              this.state.transition(serverMessage);
              const completedRequests = this.requestManager.removeCompleted(
                this.remoteQuerySet.timestamp()
              );
              this.notifyOnQueryResultChanges(completedRequests);
              break;
            }
            case "MutationResponse": {
              if (serverMessage.success) {
                this.observedTimestamp(serverMessage.ts);
              }
              const completedMutationId = this.requestManager.onResponse(serverMessage);
              if (completedMutationId) {
                this.notifyOnQueryResultChanges(/* @__PURE__ */ new Set([completedMutationId]));
              }
              break;
            }
            case "ActionResponse": {
              this.requestManager.onResponse(serverMessage);
              break;
            }
            case "AuthError": {
              this.authenticationManager.onAuthError(serverMessage);
              break;
            }
            case "FatalError": {
              const error = logFatalError(serverMessage.error);
              void this.webSocketManager.stop();
              throw error;
            }
            case "Ping":
              break;
            default: {
              const _typeCheck = serverMessage;
            }
          }
          return {
            hasSyncedPastLastReconnect: this.hasSyncedPastLastReconnect()
          };
        },
        webSocketConstructor,
        this.verbose
      );
      this.mark("convexClientConstructed");
    }
    /**
     * Return true if there is outstanding work from prior to the time of the most recent restart.
     * This indicates that the client has not proven itself to have gotten past the issue that
     * potentially led to the restart. Use this to influence when to reset backoff after a failure.
     */
    hasSyncedPastLastReconnect() {
      const hasSyncedPastLastReconnect = this.requestManager.hasSyncedPastLastReconnect() || this.state.hasSyncedPastLastReconnect();
      return hasSyncedPastLastReconnect;
    }
    observedTimestamp(observedTs) {
      if (this.maxObservedTimestamp === void 0 || this.maxObservedTimestamp.lessThanOrEqual(observedTs)) {
        this.maxObservedTimestamp = observedTs;
      }
    }
    getMaxObservedTimestamp() {
      return this.maxObservedTimestamp;
    }
    /**
     * Compute the current query results based on the remoteQuerySet and the
     * current optimistic updates and call `onTransition` for all the changed
     * queries.
     *
     * @param completedMutations - A set of mutation IDs whose optimistic updates
     * are no longer needed.
     */
    notifyOnQueryResultChanges(completedRequest) {
      const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();
      const queryTokenToValue = /* @__PURE__ */ new Map();
      for (const [queryId, result] of remoteQueryResults) {
        const queryToken = this.state.queryToken(queryId);
        if (queryToken !== null) {
          const query = {
            result,
            udfPath: this.state.queryPath(queryId),
            args: this.state.queryArgs(queryId)
          };
          queryTokenToValue.set(queryToken, query);
        }
      }
      this.onTransition(
        this.optimisticQueryResults.ingestQueryResultsFromServer(
          queryTokenToValue,
          completedRequest
        )
      );
    }
    /**
     * Set the authentication token to be used for subsequent queries and mutations.
     * `fetchToken` will be called automatically again if a token expires.
     * `fetchToken` should return `null` if the token cannot be retrieved, for example
     * when the user's rights were permanently revoked.
     * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token
     * @param onChange - a callback that will be called when the authentication status changes
     */
    setAuth(fetchToken, onChange) {
      void this.authenticationManager.setConfig(fetchToken, onChange);
    }
    hasAuth() {
      return this.state.hasAuth();
    }
    /** @internal */
    setAdminAuth(value, fakeUserIdentity) {
      const message = this.state.setAdminAuth(value, fakeUserIdentity);
      this.webSocketManager.sendMessage(message);
    }
    clearAuth() {
      const message = this.state.clearAuth();
      this.webSocketManager.sendMessage(message);
    }
    /**
       * Subscribe to a query function.
       *
       * Whenever this query's result changes, the `onTransition` callback
       * passed into the constructor will be called.
       *
       * @param name - The name of the query.
       * @param args - An arguments object for the query. If this is omitted, the
       * arguments will be `{}`.
       * @param options - A {@link SubscribeOptions} options object for this query.
    
       * @returns An object containing a {@link QueryToken} corresponding to this
       * query and an `unsubscribe` callback.
       */
    subscribe(name, args, options) {
      const argsObject = parseArgs(args);
      const { modification, queryToken, unsubscribe } = this.state.subscribe(
        name,
        argsObject,
        options?.journal
      );
      if (modification !== null) {
        this.webSocketManager.sendMessage(modification);
      }
      return {
        queryToken,
        unsubscribe: () => {
          const modification2 = unsubscribe();
          if (modification2) {
            this.webSocketManager.sendMessage(modification2);
          }
        }
      };
    }
    /**
     * A query result based only on the current, local state.
     *
     * The only way this will return a value is if we're already subscribed to the
     * query or its value has been set optimistically.
     */
    localQueryResult(udfPath, args) {
      const argsObject = parseArgs(args);
      const queryToken = serializePathAndArgs(udfPath, argsObject);
      return this.optimisticQueryResults.queryResult(queryToken);
    }
    /**
     * Get query result by query token based on current, local state
     *
     * The only way this will return a value is if we're already subscribed to the
     * query or its value has been set optimistically.
     *
     * @internal
     */
    localQueryResultByToken(queryToken) {
      return this.optimisticQueryResults.queryResult(queryToken);
    }
    /**
     * Whether local query result is available for a toke.
     *
     * This method does not throw if the result is an error.
     *
     * @internal
     */
    hasLocalQueryResultByToken(queryToken) {
      return this.optimisticQueryResults.hasQueryResult(queryToken);
    }
    /**
     * @internal
     */
    localQueryLogs(udfPath, args) {
      const argsObject = parseArgs(args);
      const queryToken = serializePathAndArgs(udfPath, argsObject);
      return this.optimisticQueryResults.queryLogs(queryToken);
    }
    /**
     * Retrieve the current {@link QueryJournal} for this query function.
     *
     * If we have not yet received a result for this query, this will be `undefined`.
     *
     * @param name - The name of the query.
     * @param args - The arguments object for this query.
     * @returns The query's {@link QueryJournal} or `undefined`.
     */
    queryJournal(name, args) {
      const argsObject = parseArgs(args);
      const queryToken = serializePathAndArgs(name, argsObject);
      return this.state.queryJournal(queryToken);
    }
    /**
     * Get the current {@link ConnectionState} between the client and the Convex
     * backend.
     *
     * @returns The {@link ConnectionState} with the Convex backend.
     */
    connectionState() {
      return {
        hasInflightRequests: this.requestManager.hasInflightRequests(),
        isWebSocketConnected: this.webSocketManager.socketState() === "ready",
        timeOfOldestInflightRequest: this.requestManager.timeOfOldestInflightRequest()
      };
    }
    /**
       * Execute a mutation function.
       *
       * @param name - The name of the mutation.
       * @param args - An arguments object for the mutation. If this is omitted,
       * the arguments will be `{}`.
       * @param options - A {@link MutationOptions} options object for this mutation.
    
       * @returns - A promise of the mutation's result.
       */
    async mutation(name, args, options) {
      const result = await this.mutationInternal(name, args, options);
      if (!result.success) {
        if (result.errorData !== void 0) {
          throw forwardData(
            result,
            new ConvexError(createHybridErrorStacktrace("mutation", name, result))
          );
        }
        throw new Error(createHybridErrorStacktrace("mutation", name, result));
      }
      return result.value;
    }
    /**
     * @internal
     */
    async mutationInternal(udfPath, args, options) {
      const mutationArgs = parseArgs(args);
      this.tryReportLongDisconnect();
      const requestId = this.nextRequestId;
      this.nextRequestId++;
      if (options !== void 0) {
        const optimisticUpdate = options.optimisticUpdate;
        if (optimisticUpdate !== void 0) {
          const wrappedUpdate = (localQueryStore) => {
            optimisticUpdate(localQueryStore, mutationArgs);
          };
          const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(
            wrappedUpdate,
            requestId
          );
          this.onTransition(changedQueries);
        }
      }
      const message = {
        type: "Mutation",
        requestId,
        udfPath,
        args: [convexToJson(mutationArgs)]
      };
      const mightBeSent = this.webSocketManager.sendMessage(message);
      return this.requestManager.request(message, mightBeSent);
    }
    /**
     * Execute an action function.
     *
     * @param name - The name of the action.
     * @param args - An arguments object for the action. If this is omitted,
     * the arguments will be `{}`.
     * @returns A promise of the action's result.
     */
    async action(name, args) {
      const result = await this.actionInternal(name, args);
      if (!result.success) {
        if (result.errorData !== void 0) {
          throw forwardData(
            result,
            new ConvexError(createHybridErrorStacktrace("action", name, result))
          );
        }
        throw new Error(createHybridErrorStacktrace("action", name, result));
      }
      return result.value;
    }
    /**
     * @internal
     */
    async actionInternal(udfPath, args) {
      const actionArgs = parseArgs(args);
      const requestId = this.nextRequestId;
      this.nextRequestId++;
      this.tryReportLongDisconnect();
      const message = {
        type: "Action",
        requestId,
        udfPath,
        args: [convexToJson(actionArgs)]
      };
      const mightBeSent = this.webSocketManager.sendMessage(message);
      return this.requestManager.request(message, mightBeSent);
    }
    /**
     * Close any network handles associated with this client and stop all subscriptions.
     *
     * Call this method when you're done with an {@link BaseConvexClient} to
     * dispose of its sockets and resources.
     *
     * @returns A `Promise` fulfilled when the connection has been completely closed.
     */
    async close() {
      this.authenticationManager.stop();
      return this.webSocketManager.stop();
    }
    _logVerbose(message) {
      if (this.verbose) {
        console.debug(`${(/* @__PURE__ */ new Date()).toISOString()} ${message}`);
      }
    }
    /**
     * Reports performance marks to the server. This should only be called when
     * we have a functional websocket.
     */
    reportMarks() {
      if (this.debug) {
        const report = getMarksReport(this.sessionId);
        this.webSocketManager.sendMessage({
          type: "Event",
          eventType: "ClientConnect",
          event: report
        });
      }
    }
    tryReportLongDisconnect() {
      if (!this.debug) {
        return;
      }
      const timeOfOldestRequest = this.connectionState().timeOfOldestInflightRequest;
      if (timeOfOldestRequest === null || Date.now() - timeOfOldestRequest.getTime() <= 60 * 1e3) {
        return;
      }
      const endpoint = `${this.address}/api/debug_event`;
      fetch(endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Convex-Client": `npm-${version}`
        },
        body: JSON.stringify({ event: "LongWebsocketDisconnect" })
      }).then((response) => {
        if (!response.ok) {
          console.warn(
            "Analytics request failed with response:",
            response.body
          );
        }
      }).catch((error) => {
        console.warn("Analytics response failed with error:", error);
      });
    }
  };

  // src/browser/simple_client.ts
  var defaultWebSocketConstructor;
  var ConvexClient = class {
    /**
     * Once closed no registered callbacks will fire again.
     */
    get closed() {
      return this._closed;
    }
    get client() {
      if (this._client)
        return this._client;
      throw new Error("ConvexClient is disabled");
    }
    /**
     * Construct a client and immediately initiate a WebSocket connection to the passed address.
     *
     * @public
     */
    constructor(address, options = {}) {
      validateDeploymentUrl(address);
      const { disabled, ...baseOptions } = options;
      this._closed = false;
      this.disabled = !!disabled;
      if (defaultWebSocketConstructor && !("webSocketConstructor" in baseOptions) && typeof WebSocket === "undefined") {
        baseOptions.webSocketConstructor = defaultWebSocketConstructor;
      }
      if (typeof window === "undefined" && !("unsavedChangesWarning" in baseOptions)) {
        baseOptions.unsavedChangesWarning = false;
      }
      if (!this.disabled) {
        this._client = new BaseConvexClient(
          address,
          (updatedQueries) => this._transition(updatedQueries),
          baseOptions
        );
      }
      this.listeners = /* @__PURE__ */ new Set();
    }
    /**
     * Call a callback whenever a new result for a query is received. The callback
     * will run soon after being registered if a result for the query is already
     * in memory.
     *
     * The return value is an {@link Unsubscribe} object which is both a function
     * an an object with properties. Both of the patterns below work with this object:
     *
     *```ts
     * // call the return value as a function
     * const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) => {
     *   console.log(messages);
     * });
     * unsubscribe();
     *
     * // unpack the return value into its properties
     * const {
     *   getCurrentValue,
     *   unsubscribe,
     * } = client.onUpdate(api.messages.list, {}, (messages) => {
     *   console.log(messages);
     * });
     *```
     *
     * @param query - A {@link server.FunctionReference} for the public query to run.
     * @param args - The arguments to run the query with.
     * @param callback - Function to call when the query result updates.
     * @param onError - Function to call when the query result updates with an error.
     * If not provided, errors will be thrown instead of calling the callback.
     *
     * @return an {@link Unsubscribe} function to stop calling the onUpdate function.
     */
    onUpdate(query, args, callback, onError) {
      if (this.disabled) {
        const disabledUnsubscribe = () => {
        };
        const unsubscribeProps2 = {
          unsubscribe: disabledUnsubscribe,
          getCurrentValue: () => void 0,
          getQueryLogs: () => void 0
        };
        Object.assign(disabledUnsubscribe, unsubscribeProps2);
        return disabledUnsubscribe;
      }
      const { queryToken, unsubscribe } = this.client.subscribe(
        getFunctionName(query),
        args
      );
      const queryInfo = {
        queryToken,
        callback,
        onError,
        unsubscribe,
        hasEverRun: false,
        query,
        args
      };
      this.listeners.add(queryInfo);
      if (this.queryResultReady(queryToken) && this.callNewListenersWithCurrentValuesTimer === void 0) {
        this.callNewListenersWithCurrentValuesTimer = setTimeout(
          () => this.callNewListenersWithCurrentValues(),
          0
        );
      }
      const unsubscribeProps = {
        unsubscribe: () => {
          if (this.closed) {
            return;
          }
          this.listeners.delete(queryInfo);
          unsubscribe();
        },
        getCurrentValue: () => this.client.localQueryResultByToken(queryToken),
        getQueryLogs: () => this.client.localQueryLogs(queryToken)
      };
      const ret = unsubscribeProps.unsubscribe;
      Object.assign(ret, unsubscribeProps);
      return ret;
    }
    // Run all callbacks that have never been run before if they have a query
    // result available now.
    callNewListenersWithCurrentValues() {
      this.callNewListenersWithCurrentValuesTimer = void 0;
      this._transition([], true);
    }
    queryResultReady(queryToken) {
      return this.client.hasLocalQueryResultByToken(queryToken);
    }
    async close() {
      if (this.disabled)
        return;
      this.listeners.clear();
      this._closed = true;
      return this.client.close();
    }
    /**
     * Set the authentication token to be used for subsequent queries and mutations.
     * `fetchToken` will be called automatically again if a token expires.
     * `fetchToken` should return `null` if the token cannot be retrieved, for example
     * when the user's rights were permanently revoked.
     * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token
     * @param onChange - a callback that will be called when the authentication status changes
     */
    setAuth(fetchToken, onChange) {
      this.client.setAuth(
        fetchToken,
        onChange ?? (() => {
        })
      );
    }
    /**
     * @internal
     */
    setAdminAuth(token, identity) {
      if (this.closed) {
        throw new Error("ConvexClient has already been closed.");
      }
      if (this.disabled)
        return;
      this.client.setAdminAuth(token, identity);
    }
    /**
     * @internal
     */
    _transition(updatedQueries, callNewListeners = false) {
      for (const queryInfo of this.listeners) {
        const { callback, queryToken, onError, hasEverRun } = queryInfo;
        if (updatedQueries.includes(queryToken) || callNewListeners && !hasEverRun && this.client.hasLocalQueryResultByToken(queryToken)) {
          queryInfo.hasEverRun = true;
          let newValue;
          try {
            newValue = this.client.localQueryResultByToken(queryToken);
          } catch (error) {
            if (!(error instanceof Error))
              throw error;
            if (onError) {
              onError(
                error,
                "Second argument to onUpdate onError is reserved for later use"
              );
            } else {
              void Promise.reject(error);
            }
            continue;
          }
          callback(
            newValue,
            "Second argument to onUpdate callback is reserved for later use"
          );
        }
      }
    }
    /**
     * Execute a mutation function.
     *
     * @param mutation - A {@link server.FunctionReference} for the public mutation
     * to run.
     * @param args - An arguments object for the mutation.
     * @param options - A {@link MutationOptions} options object for the mutation.
     * @returns A promise of the mutation's result.
     */
    async mutation(mutation, args) {
      if (this.disabled)
        throw new Error("ConvexClient is disabled");
      return await this.client.mutation(getFunctionName(mutation), args);
    }
    /**
     * Execute an action function.
     *
     * @param action - A {@link server.FunctionReference} for the public action
     * to run.
     * @param args - An arguments object for the action.
     * @returns A promise of the action's result.
     */
    async action(action, args) {
      if (this.disabled)
        throw new Error("ConvexClient is disabled");
      return await this.client.action(getFunctionName(action), args);
    }
    /**
     * Fetch a query result once.
     *
     * @param query - A {@link server.FunctionReference} for the public query
     * to run.
     * @param args - An arguments object for the query.
     * @returns A promise of the query's result.
     */
    async query(query, args) {
      if (this.disabled)
        throw new Error("ConvexClient is disabled");
      const value = this.client.localQueryResult(getFunctionName(query), args);
      if (value !== void 0)
        return value;
      return new Promise((resolve, reject) => {
        const { unsubscribe } = this.onUpdate(
          query,
          args,
          (value2) => {
            unsubscribe();
            resolve(value2);
          },
          (e2) => {
            unsubscribe();
            reject(e2);
          }
        );
      });
    }
  };

  // src/browser/http_client.ts
  var STATUS_CODE_UDF_FAILED = 560;
  var specifiedFetch = void 0;
  var ConvexHttpClient = class {
    /**
     * Create a new {@link ConvexHttpClient}.
     *
     * @param address - The url of your Convex deployment, often provided
     * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.
     */
    constructor(address) {
      validateDeploymentUrl(address);
      this.address = `${address}/api`;
      this.debug = true;
    }
    /**
     * Obtain the {@link ConvexHttpClient}'s URL to its backend.
     *
     * @returns The URL to the Convex backend, including the client's API version.
     */
    backendUrl() {
      return this.address;
    }
    /**
     * Set the authentication token to be used for subsequent queries and mutations.
     *
     * Should be called whenever the token changes (i.e. due to expiration and refresh).
     *
     * @param value - JWT-encoded OpenID Connect identity token.
     */
    setAuth(value) {
      this.clearAuth();
      this.auth = value;
    }
    /**
     * @internal
     */
    setAdminAuth(token) {
      this.clearAuth();
      this.adminAuth = token;
    }
    /**
     * Clear the current authentication token if set.
     */
    clearAuth() {
      this.auth = void 0;
      this.adminAuth = void 0;
    }
    /**
     * Sets whether the result log lines should be printed on the console or not.
     *
     * @internal
     */
    setDebug(debug) {
      this.debug = debug;
    }
    /**
     * Used to customize the fetch behavior in some runtimes.
     *
     * @internal
     */
    setFetchOptions(fetchOptions) {
      this.fetchOptions = fetchOptions;
    }
    /**
     * Execute a Convex query function.
     *
     * @param name - The name of the query.
     * @param args - The arguments object for the query. If this is omitted,
     * the arguments will be `{}`.
     * @returns A promise of the query's result.
     */
    async query(query, ...args) {
      const queryArgs = parseArgs(args[0]);
      const name = getFunctionName(query);
      const body = JSON.stringify({
        path: name,
        format: "convex_encoded_json",
        args: [convexToJson(queryArgs)]
      });
      const headers = {
        "Content-Type": "application/json",
        "Convex-Client": `npm-${version}`
      };
      if (this.adminAuth) {
        headers["Authorization"] = `Convex ${this.adminAuth}`;
      } else if (this.auth) {
        headers["Authorization"] = `Bearer ${this.auth}`;
      }
      const localFetch = specifiedFetch || fetch;
      const response = await localFetch(`${this.address}/query`, {
        ...this.fetchOptions,
        body,
        method: "POST",
        headers,
        credentials: "include"
      });
      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
        throw new Error(await response.text());
      }
      const respJSON = await response.json();
      if (this.debug) {
        for (const line of respJSON.logLines ?? []) {
          logToConsole("info", "query", name, line);
        }
      }
      switch (respJSON.status) {
        case "success":
          return jsonToConvex(respJSON.value, true);
        case "error":
          if (respJSON.errorData !== void 0) {
            throw forwardErrorData(
              respJSON.errorData,
              new ConvexError(respJSON.errorMessage)
            );
          }
          throw new Error(respJSON.errorMessage);
        default:
          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
      }
    }
    /**
     * Execute a Convex mutation function.
     *
     * @param name - The name of the mutation.
     * @param args - The arguments object for the mutation. If this is omitted,
     * the arguments will be `{}`.
     * @returns A promise of the mutation's result.
     */
    async mutation(mutation, ...args) {
      const mutationArgs = parseArgs(args[0]);
      const name = getFunctionName(mutation);
      const body = JSON.stringify({
        path: name,
        format: "convex_encoded_json",
        args: [convexToJson(mutationArgs)]
      });
      const headers = {
        "Content-Type": "application/json",
        "Convex-Client": `npm-${version}`
      };
      if (this.adminAuth) {
        headers["Authorization"] = `Convex ${this.adminAuth}`;
      } else if (this.auth) {
        headers["Authorization"] = `Bearer ${this.auth}`;
      }
      const localFetch = specifiedFetch || fetch;
      const response = await localFetch(`${this.address}/mutation`, {
        ...this.fetchOptions,
        body,
        method: "POST",
        headers,
        credentials: "include"
      });
      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
        throw new Error(await response.text());
      }
      const respJSON = await response.json();
      if (this.debug) {
        for (const line of respJSON.logLines ?? []) {
          logToConsole("info", "mutation", name, line);
        }
      }
      switch (respJSON.status) {
        case "success":
          return jsonToConvex(respJSON.value, true);
        case "error":
          if (respJSON.errorData !== void 0) {
            throw forwardErrorData(
              respJSON.errorData,
              new ConvexError(respJSON.errorMessage)
            );
          }
          throw new Error(respJSON.errorMessage);
        default:
          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
      }
    }
    /**
     * Execute a Convex action function.
     *
     * @param name - The name of the action.
     * @param args - The arguments object for the action. If this is omitted,
     * the arguments will be `{}`.
     * @returns A promise of the action's result.
     */
    async action(action, ...args) {
      const actionArgs = parseArgs(args[0]);
      const name = getFunctionName(action);
      const body = JSON.stringify({
        path: name,
        format: "convex_encoded_json",
        args: [convexToJson(actionArgs)]
      });
      const headers = {
        "Content-Type": "application/json",
        "Convex-Client": `npm-${version}`
      };
      if (this.adminAuth) {
        headers["Authorization"] = `Convex ${this.adminAuth}`;
      } else if (this.auth) {
        headers["Authorization"] = `Bearer ${this.auth}`;
      }
      const localFetch = specifiedFetch || fetch;
      const response = await localFetch(`${this.address}/action`, {
        ...this.fetchOptions,
        body,
        method: "POST",
        headers,
        credentials: "include"
      });
      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
        throw new Error(await response.text());
      }
      const respJSON = await response.json();
      if (this.debug) {
        for (const line of respJSON.logLines ?? []) {
          logToConsole("info", "action", name, line);
        }
      }
      switch (respJSON.status) {
        case "success":
          return jsonToConvex(respJSON.value, true);
        case "error":
          if (respJSON.errorData !== void 0) {
            throw forwardErrorData(
              respJSON.errorData,
              new ConvexError(respJSON.errorMessage)
            );
          }
          throw new Error(respJSON.errorMessage);
        default:
          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
      }
    }
    /**
     * Execute a Convex function of an unknown type.
     *
     * @param name - The name of the function.
     * @param args - The arguments object for the function. If this is omitted,
     * the arguments will be `{}`.
     * @returns A promise of the function's result.
     *
     * @internal
     */
    async function(anyFunction, ...args) {
      const functionArgs = parseArgs(args[0]);
      const name = typeof anyFunction === "string" ? anyFunction : getFunctionName(anyFunction);
      const body = JSON.stringify({
        path: name,
        format: "convex_encoded_json",
        args: convexToJson(functionArgs)
      });
      const headers = {
        "Content-Type": "application/json",
        "Convex-Client": `npm-${version}`
      };
      if (this.adminAuth) {
        headers["Authorization"] = `Convex ${this.adminAuth}`;
      } else if (this.auth) {
        headers["Authorization"] = `Bearer ${this.auth}`;
      }
      const localFetch = specifiedFetch || fetch;
      const response = await localFetch(`${this.address}/function`, {
        ...this.fetchOptions,
        body,
        method: "POST",
        headers,
        credentials: "include"
      });
      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
        throw new Error(await response.text());
      }
      const respJSON = await response.json();
      if (this.debug) {
        for (const line of respJSON.logLines ?? []) {
          logToConsole("info", "any", name, line);
        }
      }
      switch (respJSON.status) {
        case "success":
          return jsonToConvex(respJSON.value, true);
        case "error":
          if (respJSON.errorData !== void 0) {
            throw forwardErrorData(
              respJSON.errorData,
              new ConvexError(respJSON.errorMessage)
            );
          }
          throw new Error(respJSON.errorMessage);
        default:
          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
      }
    }
  };
  function forwardErrorData(errorData, error) {
    error.data = jsonToConvex(errorData);
    return error;
  }
  return __toCommonJS(browser_bundle_exports);
})();
//# sourceMappingURL=browser.bundle.js.map
