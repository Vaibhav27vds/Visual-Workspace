/// <reference types="node" />
import { Dirent, Mode, ReadStream, Stats } from "fs";
export interface Filesystem {
    listDir(dirPath: string): Dirent[];
    exists(path: string): boolean;
    stat(path: string): Stats;
    readUtf8File(path: string): string;
    createReadStream(path: string): ReadStream;
    access(path: string): void;
    writeUtf8File(path: string, contents: string, mode?: Mode): void;
    mkdir(dirPath: string, options?: {
        allowExisting?: boolean;
    }): void;
    rm(path: string, options?: {
        force?: boolean;
        recursive?: boolean;
    }): void;
    rmdir(path: string): void;
    unlink(path: string): void;
    renameFile(fromPath: string, toPath: string): void;
    registerPath(path: string, st: Stats | null): void;
    invalidate(): void;
}
export interface TempDir {
    tmpPath: string;
}
export declare function mkdtemp(prefix: string, callback: (tmpDir: TempDir) => Promise<void>): Promise<void>;
export declare const nodeFs: Filesystem;
export declare class RecordingFs implements Filesystem {
    private observedDirectories;
    private observedFiles;
    private invalidated;
    private traceEvents;
    constructor(traceEvents: boolean);
    listDir(dirPath: string): Dirent[];
    exists(path: string): boolean;
    stat(path: string): Stats;
    readUtf8File(path: string): string;
    createReadStream(path: string): ReadStream;
    access(path: string): void;
    writeUtf8File(filePath: string, contents: string, mode?: Mode): void;
    mkdir(dirPath: string, options?: {
        allowExisting?: boolean;
    }): void;
    rm(entityPath: string, options?: {
        force?: boolean;
        recursive?: boolean;
    }): void;
    rmdir(dirPath: string): void;
    unlink(filePath: string): void;
    renameFile(fromPath: string, toPath: string): void;
    private updateOnWrite;
    private updateOnDelete;
    registerPath(p: string, st: Stats | null): void;
    invalidate(): void;
    registerNormalized(absPath: string, observed: Stats | null): void;
    finalize(): Observations | "invalidated";
}
export type WatchEvent = {
    name: "add" | "addDir" | "change" | "unlink" | "unlinkDir";
    absPath: string;
};
export declare class Observations {
    directories: Map<string, Set<string>>;
    files: Map<string, Stats | null>;
    constructor(directories: Map<string, Set<string>>, files: Map<string, Stats | null>);
    paths(): string[];
    overlaps({ absPath, }: WatchEvent): {
        overlaps: false;
    } | {
        overlaps: true;
        reason: string;
    };
}
export declare function stMatches(a: Stats | null, b: Stats | null): {
    matches: true;
} | {
    matches: false;
    reason: string;
};
//# sourceMappingURL=fs.d.ts.map