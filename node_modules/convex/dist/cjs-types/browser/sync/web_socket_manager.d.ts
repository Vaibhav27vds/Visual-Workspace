import { ClientMessage, ServerMessage } from "./protocol.js";
export type ReconnectMetadata = {
    connectionCount: number;
    lastCloseReason: string | null;
};
export type OnMessageResponse = {
    hasSyncedPastLastReconnect: boolean;
};
/**
 * A wrapper around a websocket that handles errors, reconnection, and message
 * parsing.
 */
export declare class WebSocketManager {
    private socket;
    private connectionCount;
    private lastCloseReason;
    /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */
    private readonly initialBackoff;
    /** We backoff exponentially, but we need to cap that--this is the jittered max. */
    private readonly maxBackoff;
    /** How many times have we failed consecutively? */
    private retries;
    /** How long before lack of server response causes us to initiate a reconnect,
     * in ms */
    private readonly serverInactivityThreshold;
    private reconnectDueToServerInactivityTimeout;
    private readonly uri;
    private readonly onOpen;
    private readonly onMessage;
    private readonly webSocketConstructor;
    private readonly verbose;
    constructor(uri: string, onOpen: (reconnectMetadata: ReconnectMetadata) => void, onMessage: (message: ServerMessage) => OnMessageResponse, webSocketConstructor: typeof WebSocket, verbose: boolean);
    private connect;
    /**
     * @returns The state of the {@link Socket}.
     */
    socketState(): string;
    /**
     * @param message - A ClientMessage to send.
     * @returns Whether the message (might have been) sent.
     */
    sendMessage(message: ClientMessage): boolean;
    private resetServerInactivityTimeout;
    private scheduleReconnect;
    /**
     * Close the WebSocket and schedule a reconnect.
     *
     * This should be used when we hit an error and would like to restart the session.
     */
    private closeAndReconnect;
    /**
     * Close the WebSocket, being careful to clear the onclose handler to avoid re-entrant
     * calls. Use this instead of directly calling `ws.close()`
     */
    private close;
    /**
     * Close the WebSocket and do not reconnect.
     * @returns A Promise that resolves when the WebSocket `onClose` callback is called.
     */
    stop(): Promise<void>;
    pause(): void;
    /**
     * Create a new WebSocket after a previous `pause()`, unless `stop()` was
     * called before.
     */
    resume(): void;
    private _logVerbose;
    private nextBackoff;
}
//# sourceMappingURL=web_socket_manager.d.ts.map