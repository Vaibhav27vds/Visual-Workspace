import { Id as GenericId } from "./value.js";
import { Expand } from "../type_utils.js";
/**
 * A validator for a Convex value.
 *
 * This should be constructed using the validator builder, {@link v}.
 *
 * This class encapsulates:
 * - The TypeScript type of this value.
 * - Whether this field should be optional if it's included in an object.
 * - The TypeScript type for the set of index field paths that can be used to
 * build indexes on this value.
 * - A JSON representation of the validator.
 * @public
 */
export declare class Validator<TypeScriptType, IsOptional extends boolean = false, FieldPaths extends string = never> {
    readonly type: TypeScriptType;
    readonly isOptional: IsOptional;
    readonly fieldPaths: FieldPaths;
    readonly _isValidator: undefined;
    readonly optional: boolean;
}
/**
 * The validator builder.
 *
 * This builder allows you to build validators for Convex values.
 *
 * Validators can be used in [schema definitions](https://docs.convex.dev/database/schemas)
 * and as input validators for Convex functions.
 *
 * @public
 */
export declare const v: {
    id<TableName extends string>(tableName: TableName): Validator<GenericId<TableName>, false, never>;
    null(): Validator<null>;
    /**
     * Alias for `v.float64()`
     */
    number(): Validator<number>;
    float64(): Validator<number>;
    /**
     * @deprecated Use `v.int64()` instead
     */
    bigint(): Validator<bigint>;
    int64(): Validator<bigint>;
    boolean(): Validator<boolean>;
    string(): Validator<string>;
    bytes(): Validator<ArrayBuffer>;
    literal<T extends string | number | bigint | boolean>(literal: T): Validator<T, false, never>;
    array<T_1>(values: Validator<T_1, false, any>): Validator<T_1[], false, never>;
    object<T_2 extends PropertyValidators>(schema: T_2): ObjectValidator<T_2>;
    /* internal record
    record<K extends string, ValueValidator extends Validator<any, any, any>>(keys: Validator<K, false, any>, values: ValueValidator): RecordValidator<K, ValueValidator>; */
    union<T_3 extends [Validator<any, false, any>, Validator<any, false, any>, ...Validator<any, false, any>[]]>(...schemaTypes: T_3): Validator<T_3[number]["type"], false, T_3[number]["fieldPaths"]>;
    any(): Validator<any, false, string>;
    optional<T_4 extends Validator<any, false, any>>(inner: T_4): Validator<T_4["type"] | undefined, true, T_4["fieldPaths"]>;
};
/**
 * Validators for each property of an object.
 *
 * This is represented as an object mapping the property name to its
 * {@link Validator}.
 *
 * @public
 */
export type PropertyValidators = Record<string, Validator<any, any, any>>;
/**
 * Compute the type of an object from {@link PropertyValidators}.
 *
 * @public
 */
export type ObjectType<Validators extends PropertyValidators> = Expand<{
    [Property in OptionalKeys<Validators>]?: Validators[Property]["type"];
} & {
    [Property in RequiredKeys<Validators>]: Validators[Property]["type"];
}>;
/**
 * Calculate the type of a {@link Validator} for an object.
 *
 * This is used within the validator builder, {@link v}.
 */
export type ObjectValidator<Validators extends PropertyValidators> = Validator<ObjectType<Validators>, false, {
    [Property in keyof Validators]: JoinFieldPaths<Property & string, Validators[Property]["fieldPaths"]> | Property;
}[keyof Validators] & string>;
type OptionalKeys<PropertyValidators extends Record<string, Validator<any, any, any>>> = {
    [Property in keyof PropertyValidators]: PropertyValidators[Property]["isOptional"] extends true ? Property : never;
}[keyof PropertyValidators];
type RequiredKeys<PropertyValidators extends Record<string, Validator<any, any, any>>> = Exclude<keyof PropertyValidators, OptionalKeys<PropertyValidators>>;
/**
 * Calculate the type of a {@link Validator} for an object that produces indexed types.
 *
 * If the value validator is not optional, it produces a `Record` type, which is an alias
 * for `{[key: K]: V}`.
 *
 * If the value validator is optional, it produces a mapped object type,
 * with optional keys: `{[key in K]?: V}`.
 *
 * This is used within the validator builder, {@link v}.
 */
export type RecordValidator<K extends string, ValueValidator extends Validator<any, any, any>> = Validator<ValueValidator["isOptional"] extends true ? {
    [key in K]?: ValueValidator["type"];
} : Record<K, ValueValidator["type"]>>;
/**
 * Join together two index field paths.
 *
 * This is used within the validator builder, {@link v}.
 * @public
 */
type JoinFieldPaths<Start extends string, End extends string> = `${Start}.${End}`;
/**
 * Extract a TypeScript type from a validator.
 *
 * Example usage:
 * ```ts
 * const objectSchema = v.object({
 *   property: v.string(),
 * });
 * type MyObject = Infer<typeof objectSchema>; // { property: string }
 * ```
 * @typeParam V - The type of a {@link Validator} constructed with {@link v}.
 *
 * @public
 */
export type Infer<V extends Validator<any, any, any>> = V["type"];
export {};
//# sourceMappingURL=validator.d.ts.map