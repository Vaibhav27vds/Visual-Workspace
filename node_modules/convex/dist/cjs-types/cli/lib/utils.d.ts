import { AxiosInstance, AxiosResponse, Method } from "axios";
import { ProjectConfig } from "./config.js";
import { Context } from "../../bundler/context.js";
export declare const productionProvisionHost = "https://provision.convex.dev";
export declare const provisionHost: string;
/** Prompt for keyboard input with the given `query` string and return a promise
 * that resolves to the input. */
export declare function prompt(query: string): Promise<unknown>;
export type ErrorData = {
    code: string;
    message: string;
};
/**
 * Handle an error from an axios request.
 *
 * TODO: Ideally this only takes in err: AxiosError, but currently
 * it's called more broadly.
 */
export declare function logAndHandleAxiosError(ctx: Context, err: any): Promise<never>;
export declare function deprecationCheckWarning(ctx: Context, resp: AxiosResponse<any, any>): void;
export declare function hasTeam(ctx: Context, teamSlug: string): Promise<boolean>;
export declare function validateOrSelectTeam(ctx: Context, teamSlug: string | null, promptMessage: string): Promise<{
    teamSlug: string;
    chosen: boolean;
}>;
export declare function hasProject(ctx: Context, teamSlug: string, projectSlug: string): Promise<boolean>;
export declare function hasProjects(ctx: Context): Promise<boolean>;
export declare function validateOrSelectProject(ctx: Context, projectSlug: string | null, teamSlug: string, singleProjectPrompt: string, multiProjectPrompt: string): Promise<string | null>;
/**
 * @param ctx
 * @returns a Record of dependency name to dependency version for dependencies
 * and devDependencies
 */
export declare function loadPackageJson(ctx: Context): Promise<Record<string, string>>;
export declare function ensureHasConvexDependency(ctx: Context, cmd: string): Promise<undefined>;
/** Return a new array with elements of the passed in array sorted by a key lambda */
export declare const sorted: <T>(arr: T[], key: (el: T) => any) => T[];
export declare function functionsDir(configPath: string, projectConfig: ProjectConfig): string;
export declare function rootDirectory(): string;
export declare function globalConfigPath(): string;
export declare function getAuthHeaderFromGlobalConfig(ctx: Context): Promise<string | null>;
export declare function bigBrainClient(ctx: Context, getAuthHeader: (ctx: Context) => Promise<string | null>): Promise<AxiosInstance>;
export declare function bigBrainAPI({ ctx, method, url, getAuthHeader, data, }: {
    ctx: Context;
    method: Method;
    url: string;
    getAuthHeader?: (ctx: Context) => Promise<string | null>;
    data?: any;
}): Promise<any>;
export declare function bigBrainAPIMaybeThrows({ ctx, method, url, getAuthHeader, data, }: {
    ctx: Context;
    method: Method;
    url: string;
    getAuthHeader?: (ctx: Context) => Promise<string | null>;
    data?: any;
}): Promise<any>;
export type GlobalConfig = {
    accessToken: string;
};
/**
 * Polls an arbitrary function until a condition is met.
 *
 * @param fetch Function performing a fetch, returning resulting data.
 * @param condition This function will terminate polling when it returns `true`.
 * @param waitMs How long to wait in between fetches.
 * @returns The resulting data from `fetch`.
 */
export declare const poll: <Result>(fetch: () => Promise<Result>, condition: (data: Result) => boolean, waitMs?: number) => Promise<Result>;
export declare function waitForever(): Promise<unknown>;
export declare function formatSize(n: number): string;
export declare function formatDuration(ms: number): string;
export declare function getCurrentTimeString(): string;
export declare function findParentConfigs(ctx: Context): Promise<{
    parentPackageJson: string;
    parentConvexJson?: string;
}>;
/**
 * Returns whether there's an existing project config. Throws
 * if this is not a valid directory for a project config.
 */
export declare function isInExistingProject(ctx: Context): Promise<boolean>;
export declare function getConfiguredDeploymentOrCrash(ctx: Context): Promise<string>;
export declare function getConfiguredDeployment(ctx: Context): Promise<string | null>;
export declare function spawnAsync(ctx: Context, command: string, args: ReadonlyArray<string>): Promise<{
    stdout: string;
    stderr: string;
    status: null | number;
    error?: Error | undefined;
}>;
export declare function spawnAsync(ctx: Context, command: string, args: ReadonlyArray<string>, options: {
    stdio: "inherit";
}): Promise<void>;
export declare function deploymentClient(deploymentURL: string): AxiosInstance;
//# sourceMappingURL=utils.d.ts.map